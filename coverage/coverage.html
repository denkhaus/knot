
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>knot: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/denkhaus/knot/cmd/knot/main.go (0.0%)</option>
				
				<option value="file1">github.com/denkhaus/knot/internal/app/app.go (62.2%)</option>
				
				<option value="file2">github.com/denkhaus/knot/internal/app/flags.go (100.0%)</option>
				
				<option value="file3">github.com/denkhaus/knot/internal/cli_test_helper.go (98.1%)</option>
				
				<option value="file4">github.com/denkhaus/knot/internal/commands/config/commands.go (96.1%)</option>
				
				<option value="file5">github.com/denkhaus/knot/internal/commands/dependency/analysis.go (0.0%)</option>
				
				<option value="file6">github.com/denkhaus/knot/internal/commands/dependency/commands.go (0.0%)</option>
				
				<option value="file7">github.com/denkhaus/knot/internal/commands/dependency/enhanced.go (0.0%)</option>
				
				<option value="file8">github.com/denkhaus/knot/internal/commands/health/commands.go (0.0%)</option>
				
				<option value="file9">github.com/denkhaus/knot/internal/commands/project/commands.go (57.5%)</option>
				
				<option value="file10">github.com/denkhaus/knot/internal/commands/task/analysis.go (3.8%)</option>
				
				<option value="file11">github.com/denkhaus/knot/internal/commands/task/bulk.go (0.0%)</option>
				
				<option value="file12">github.com/denkhaus/knot/internal/commands/task/commands.go (50.4%)</option>
				
				<option value="file13">github.com/denkhaus/knot/internal/commands/task/deletion.go (0.0%)</option>
				
				<option value="file14">github.com/denkhaus/knot/internal/commands/task/get_started.go (0.0%)</option>
				
				<option value="file15">github.com/denkhaus/knot/internal/commands/task/hierarchy.go (0.0%)</option>
				
				<option value="file16">github.com/denkhaus/knot/internal/commands/task/hierarchy_helpers.go (0.0%)</option>
				
				<option value="file17">github.com/denkhaus/knot/internal/commands/template/commands.go (0.0%)</option>
				
				<option value="file18">github.com/denkhaus/knot/internal/commands/template/helpers.go (0.0%)</option>
				
				<option value="file19">github.com/denkhaus/knot/internal/commands/validation/commands.go (0.0%)</option>
				
				<option value="file20">github.com/denkhaus/knot/internal/config/config.go (0.0%)</option>
				
				<option value="file21">github.com/denkhaus/knot/internal/errors/enhanced_errors.go (100.0%)</option>
				
				<option value="file22">github.com/denkhaus/knot/internal/errors/helpers.go (0.0%)</option>
				
				<option value="file23">github.com/denkhaus/knot/internal/logger/logger.go (0.0%)</option>
				
				<option value="file24">github.com/denkhaus/knot/internal/manager/interfaces.go (100.0%)</option>
				
				<option value="file25">github.com/denkhaus/knot/internal/manager/manager.go (40.0%)</option>
				
				<option value="file26">github.com/denkhaus/knot/internal/manager/service.go (25.1%)</option>
				
				<option value="file27">github.com/denkhaus/knot/internal/repository/inmemory/repository.go (0.0%)</option>
				
				<option value="file28">github.com/denkhaus/knot/internal/repository/sqlite/config.go (68.0%)</option>
				
				<option value="file29">github.com/denkhaus/knot/internal/repository/sqlite/context_operations.go (0.0%)</option>
				
				<option value="file30">github.com/denkhaus/knot/internal/repository/sqlite/dependency_operations.go (0.0%)</option>
				
				<option value="file31">github.com/denkhaus/knot/internal/repository/sqlite/ent/client.go (0.0%)</option>
				
				<option value="file32">github.com/denkhaus/knot/internal/repository/sqlite/ent/ent.go (0.0%)</option>
				
				<option value="file33">github.com/denkhaus/knot/internal/repository/sqlite/ent/enttest/enttest.go (0.0%)</option>
				
				<option value="file34">github.com/denkhaus/knot/internal/repository/sqlite/ent/hook/hook.go (0.0%)</option>
				
				<option value="file35">github.com/denkhaus/knot/internal/repository/sqlite/ent/migrate/migrate.go (0.0%)</option>
				
				<option value="file36">github.com/denkhaus/knot/internal/repository/sqlite/ent/migrate/schema.go (0.0%)</option>
				
				<option value="file37">github.com/denkhaus/knot/internal/repository/sqlite/ent/mutation.go (0.0%)</option>
				
				<option value="file38">github.com/denkhaus/knot/internal/repository/sqlite/ent/project.go (0.0%)</option>
				
				<option value="file39">github.com/denkhaus/knot/internal/repository/sqlite/ent/project/project.go (0.0%)</option>
				
				<option value="file40">github.com/denkhaus/knot/internal/repository/sqlite/ent/project/where.go (0.0%)</option>
				
				<option value="file41">github.com/denkhaus/knot/internal/repository/sqlite/ent/project_create.go (0.0%)</option>
				
				<option value="file42">github.com/denkhaus/knot/internal/repository/sqlite/ent/project_delete.go (0.0%)</option>
				
				<option value="file43">github.com/denkhaus/knot/internal/repository/sqlite/ent/project_query.go (0.0%)</option>
				
				<option value="file44">github.com/denkhaus/knot/internal/repository/sqlite/ent/project_update.go (0.0%)</option>
				
				<option value="file45">github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext.go (0.0%)</option>
				
				<option value="file46">github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext/projectcontext.go (0.0%)</option>
				
				<option value="file47">github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext/where.go (0.0%)</option>
				
				<option value="file48">github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext_create.go (0.0%)</option>
				
				<option value="file49">github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext_delete.go (0.0%)</option>
				
				<option value="file50">github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext_query.go (0.0%)</option>
				
				<option value="file51">github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext_update.go (0.0%)</option>
				
				<option value="file52">github.com/denkhaus/knot/internal/repository/sqlite/ent/runtime.go (0.0%)</option>
				
				<option value="file53">github.com/denkhaus/knot/internal/repository/sqlite/ent/schema/project.go (0.0%)</option>
				
				<option value="file54">github.com/denkhaus/knot/internal/repository/sqlite/ent/schema/projectcontext.go (0.0%)</option>
				
				<option value="file55">github.com/denkhaus/knot/internal/repository/sqlite/ent/schema/task.go (0.0%)</option>
				
				<option value="file56">github.com/denkhaus/knot/internal/repository/sqlite/ent/schema/taskdependency.go (0.0%)</option>
				
				<option value="file57">github.com/denkhaus/knot/internal/repository/sqlite/ent/task.go (0.0%)</option>
				
				<option value="file58">github.com/denkhaus/knot/internal/repository/sqlite/ent/task/task.go (0.0%)</option>
				
				<option value="file59">github.com/denkhaus/knot/internal/repository/sqlite/ent/task/where.go (0.0%)</option>
				
				<option value="file60">github.com/denkhaus/knot/internal/repository/sqlite/ent/task_create.go (0.0%)</option>
				
				<option value="file61">github.com/denkhaus/knot/internal/repository/sqlite/ent/task_delete.go (0.0%)</option>
				
				<option value="file62">github.com/denkhaus/knot/internal/repository/sqlite/ent/task_query.go (0.0%)</option>
				
				<option value="file63">github.com/denkhaus/knot/internal/repository/sqlite/ent/task_update.go (0.0%)</option>
				
				<option value="file64">github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency.go (0.0%)</option>
				
				<option value="file65">github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency/taskdependency.go (0.0%)</option>
				
				<option value="file66">github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency/where.go (0.0%)</option>
				
				<option value="file67">github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency_create.go (0.0%)</option>
				
				<option value="file68">github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency_delete.go (0.0%)</option>
				
				<option value="file69">github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency_query.go (0.0%)</option>
				
				<option value="file70">github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency_update.go (0.0%)</option>
				
				<option value="file71">github.com/denkhaus/knot/internal/repository/sqlite/ent/tx.go (0.0%)</option>
				
				<option value="file72">github.com/denkhaus/knot/internal/repository/sqlite/errors.go (2.9%)</option>
				
				<option value="file73">github.com/denkhaus/knot/internal/repository/sqlite/health.go (0.0%)</option>
				
				<option value="file74">github.com/denkhaus/knot/internal/repository/sqlite/mappers.go (69.2%)</option>
				
				<option value="file75">github.com/denkhaus/knot/internal/repository/sqlite/options.go (76.5%)</option>
				
				<option value="file76">github.com/denkhaus/knot/internal/repository/sqlite/pool_optimization.go (44.7%)</option>
				
				<option value="file77">github.com/denkhaus/knot/internal/repository/sqlite/project_operations.go (63.6%)</option>
				
				<option value="file78">github.com/denkhaus/knot/internal/repository/sqlite/repository.go (67.2%)</option>
				
				<option value="file79">github.com/denkhaus/knot/internal/repository/sqlite/task_operations.go (40.3%)</option>
				
				<option value="file80">github.com/denkhaus/knot/internal/repository/sqlite/task_queries.go (6.7%)</option>
				
				<option value="file81">github.com/denkhaus/knot/internal/repository/sqlite/transactions.go (27.0%)</option>
				
				<option value="file82">github.com/denkhaus/knot/internal/shared/context.go (20.0%)</option>
				
				<option value="file83">github.com/denkhaus/knot/internal/shared/shared.go (17.6%)</option>
				
				<option value="file84">github.com/denkhaus/knot/internal/templates/embedded.go (0.0%)</option>
				
				<option value="file85">github.com/denkhaus/knot/internal/templates/metadata.go (0.0%)</option>
				
				<option value="file86">github.com/denkhaus/knot/internal/templates/seeding.go (0.0%)</option>
				
				<option value="file87">github.com/denkhaus/knot/internal/templates/user.go (0.0%)</option>
				
				<option value="file88">github.com/denkhaus/knot/internal/testutil/testutil.go (0.0%)</option>
				
				<option value="file89">github.com/denkhaus/knot/internal/validation/input_validation.go (96.9%)</option>
				
				<option value="file90">github.com/denkhaus/knot/internal/validation/state_validation.go (89.8%)</option>
				
				<option value="file91">github.com/denkhaus/knot/magefiles/build.go (0.0%)</option>
				
				<option value="file92">github.com/denkhaus/knot/magefiles/main.go (0.0%)</option>
				
				<option value="file93">github.com/denkhaus/knot/magefiles/release.go (0.0%)</option>
				
				<option value="file94">github.com/denkhaus/knot/magefiles/test.go (0.0%)</option>
				
				<option value="file95">github.com/denkhaus/knot/magefiles/util.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "os"

        "github.com/denkhaus/knot/internal/app"
)

// Version, commit, and build date are set by ldflags during build
var (
        version = "dev"
        commit  = "unknown"
        date    = "unknown"
)

func main() <span class="cov0" title="0">{
        // Set version information from build variables
        app.SetVersionFromBuild(version, commit, date)

        // Create and run the application
        application, err := app.New()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize application: %v", err)
        }</span>

        <span class="cov0" title="0">if err := application.Run(os.Args); err != nil </span><span class="cov0" title="0">{
                // Error has already been printed by the Run method
                // Just exit with error code without additional logging
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "fmt"
        "os"
        "strings"

        configCommands "github.com/denkhaus/knot/internal/commands/config"
        "github.com/denkhaus/knot/internal/commands/dependency"
        "github.com/denkhaus/knot/internal/commands/health"
        "github.com/denkhaus/knot/internal/commands/project"
        "github.com/denkhaus/knot/internal/commands/task"
        "github.com/denkhaus/knot/internal/commands/template"
        validationCommands "github.com/denkhaus/knot/internal/commands/validation"
        "github.com/denkhaus/knot/internal/errors"
        "github.com/denkhaus/knot/internal/logger"
        "github.com/denkhaus/knot/internal/manager"
        "github.com/denkhaus/knot/internal/repository/inmemory"
        "github.com/denkhaus/knot/internal/repository/sqlite"
        "github.com/denkhaus/knot/internal/shared"
        "github.com/denkhaus/knot/internal/templates"
        "github.com/denkhaus/knot/internal/types"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// Version variables that will be set by ldflags during build
var (
        version = "dev"
        commit  = "unknown" // nolint:unused // set by ldflags during build
        date    = "unknown" // nolint:unused // set by ldflags during build
)

// SetVersionFromBuild allows setting version information from build time variables
func SetVersionFromBuild(v, c, d string) <span class="cov8" title="1">{
        version = v
        commit = c
        date = d
}</span>

// App represents the CLI application
type App struct {
        *cli.App
        context *shared.AppContext
}

// isUserInputError checks if an error is due to user input (like missing required flags)
// rather than an internal application error
func isUserInputError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if it's an EnhancedError - these are user-facing validation errors
        <span class="cov8" title="1">if _, ok := err.(*errors.EnhancedError); ok </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">errMsg := err.Error()

        // Common user input errors from urfave/cli
        userErrorPatterns := []string{
                "Required flag",
                "flag provided but not defined",
                "invalid value",
                "command not found",
                "incorrect usage",
                "flag needs an argument",
                "No help topic for",
        }

        for _, pattern := range userErrorPatterns </span><span class="cov8" title="1">{
                if strings.Contains(errMsg, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// New creates a new CLI application with all dependencies initialized
func New() (*App, error) <span class="cov8" title="1">{
        // Initialize logger
        appLogger := logger.GetLogger()

        // Initialize repository (SQLite with fallback to in-memory)
        var repo types.Repository
        var err error

        repo, err = sqlite.NewRepository(
                sqlite.WithLogger(appLogger),
                sqlite.WithAutoMigrate(true),
        )
        if err != nil </span><span class="cov0" title="0">{
                appLogger.Warn("Failed to initialize SQLite repository, falling back to in-memory", zap.Error(err))
                repo = inmemory.NewMemoryRepository()
        }</span> else<span class="cov8" title="1"> {
                appLogger.Info("SQLite repository initialized successfully")
                
                // Initialize templates automatically after successful database setup
                if err := templates.CheckAndSeedIfNeeded(); err != nil </span><span class="cov0" title="0">{
                        appLogger.Warn("Failed to seed templates during initialization", zap.Error(err))
                }</span> else<span class="cov8" title="1"> {
                        appLogger.Debug("Template seeding check completed successfully")
                }</span>
        }

        // Initialize project manager
        <span class="cov8" title="1">config := manager.DefaultConfig()
        projectManager := manager.NewManagerWithRepository(repo, config)

        // Create application context
        appCtx := shared.NewAppContext(projectManager, appLogger)

        // Create CLI app
        cliApp := &amp;cli.App{
                Name:    "knot",
                Usage:   "A CLI tool for hierarchical project and task management with dependencies",
                Description: `A CLI tool for hierarchical project and task management with dependencies.
Designed to be the best friend of every LLM agent with structured, parsable outputs and comprehensive error handling.
For new users or LLM agents, run 'knot get-started' for a comprehensive guide to all available commands and usage.`,
                Version: version,
                Authors: []*cli.Author{
                        {
                                Name:  "denkhaus",
                                Email: "denkhaus@example.com",
                        },
                },
                Flags: []cli.Flag{
                        &amp;cli.StringFlag{
                                Name:    "actor",
                                Usage:   "Actor name for audit trail (default: $USER)",
                                EnvVars: []string{"KNOT_ACTOR", "USER"},
                        },
                        NewLogLevelFlag(),
                },
                Before: func(c *cli.Context) error </span><span class="cov0" title="0">{
                        // Configure logger based on log-level flag
                        logLevel := c.String("log-level")
                        logger.SetLogLevel(logLevel)
                        
                        // Update appCtx logger reference after reconfiguration
                        appCtx.Logger = logger.GetLogger()
                        
                        appCtx.SetActor(c.String("actor"))
                        appCtx.Logger.Info("Knot CLI started", zap.String("version", version))
                        return nil
                }</span>,
                Commands: []*cli.Command{
                        {
                                Name:        "project",
                                Aliases:     []string{"p"},
                                Usage:       "Project management commands",
                                Subcommands: project.Commands(appCtx),
                        },
                        {
                                Name:        "task",
                                Aliases:     []string{"t"},
                                Usage:       "Task management commands",
                                Subcommands: task.Commands(appCtx),
                        },
                        {
                                Name:        "template",
                                Aliases:     []string{"tmpl"},
                                Usage:       "Task template management commands",
                                Subcommands: template.Commands(appCtx),
                        },
                        {
                                Name:        "dependency",
                                Aliases:     []string{"dep"},
                                Usage:       "Task dependency management",
                                Subcommands: dependency.Commands(appCtx),
                        },
                        {
                                Name:        "config",
                                Aliases:     []string{"cfg"},
                                Usage:       "Configuration management",
                                Subcommands: configCommands.Commands(appCtx),
                        },
                        {
                                Name:        "health",
                                Usage:       "Database health and connectivity checks",
                                Subcommands: health.Commands(appCtx),
                        },
                        {
                                Name:        "validate",
                                Usage:       "Task state validation and transition checks",
                                Subcommands: validationCommands.Commands(appCtx),
                        },
                        {
                                Name:   "ready",
                                Usage:  "Show tasks with no blockers (ready to work on)",
                                Action: task.ReadyAction(appCtx),
                                Flags: []cli.Flag{
                                        NewTaskLimitFlag(),
                                        NewJSONFlag(),
                                },
                        },
                        {
                                Name:   "blocked",
                                Usage:  "Show tasks blocked by dependencies",
                                Action: task.BlockedAction(appCtx),
                                Flags: []cli.Flag{
                                        NewTaskLimitFlag(),
                                        NewJSONFlag(),
                                },
                        },
                        {
                                Name:   "actionable",
                                Usage:  "Find the next actionable task in a project",
                                Action: task.ActionableAction(appCtx),
                                Flags: []cli.Flag{
                                        NewJSONFlag(),
                                },
                        },
                        {
                                Name:   "breakdown",
                                Usage:  "Find tasks that need breakdown based on complexity",
                                Action: task.BreakdownAction(appCtx),
                                Flags: []cli.Flag{
                                        NewTaskLimitFlag(),
                                        NewJSONFlag(),
                                        &amp;cli.IntFlag{
                                                Name:    "threshold",
                                                Aliases: []string{"t"},
                                                Usage:   "Complexity threshold for breakdown (default: 8)",
                                                Value:   8,
                                                EnvVars: []string{"KNOT_COMPLEXITY_THRESHOLD"},
                                        },
                                },
                        },
                        {
                                Name:   "get-started",
                                Usage:  "Get started guide for LLM agents with available commands and usage",
                                Action: task.GetStartedAction(appCtx),
                        },
                },
        }

        <span class="cov8" title="1">return &amp;App{
                App:     cliApp,
                context: appCtx,
        }, nil</span>
}

// Run starts the CLI application
func (a *App) Run(args []string) error <span class="cov8" title="1">{
        defer logger.Sync()

        if err := a.App.Run(args); err != nil </span><span class="cov0" title="0">{
                // For user input errors, print them cleanly without JSON logging
                if isUserInputError(err) </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                        fmt.Fprintf(os.Stderr, "üí° For help getting started with Knot and a list of all commands, run: knot get-started\n")
                        return err
                }</span>

                // For internal errors, use the logger but also suggest the get-started command
                <span class="cov0" title="0">a.context.Logger.Error("Application error", zap.Error(err))
                fmt.Fprintf(os.Stderr, "üí° For help getting started with Knot and a list of all commands, run: knot get-started\n")
                return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "github.com/urfave/cli/v2"
)


func NewTaskLimitFlag() cli.Flag <span class="cov8" title="1">{
        return &amp;cli.IntFlag{
                Name:    "limit",
                Aliases: []string{"l"},
                Usage:   "Maximum number of tasks to show (default: 10)",
                Value:   10,
                EnvVars: []string{"KNOT_TASK_LIMIT"},
        }
}</span>

func NewJSONFlag() cli.Flag <span class="cov8" title="1">{
        return &amp;cli.BoolFlag{
                Name:    "json",
                Aliases: []string{"j"},
                Usage:   "Output in JSON format",
        }
}</span>

func NewLogLevelFlag() cli.Flag <span class="cov8" title="1">{
        return &amp;cli.StringFlag{
                Name:  "log-level",
                Usage: "Log level (off, error, warn, info, debug)",
                Value: "off",
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package internal

import (
        "bytes"
        "io"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "testing"

        "github.com/denkhaus/knot/internal/app"
        "github.com/stretchr/testify/require"
)

// CLITestHelper provides utilities for testing CLI commands
type CLITestHelper struct {
        tempDir     string
        originalDir string
        app         *app.App
        t           *testing.T
}

// NewCLITestHelper creates a new CLI test helper with isolated environment
func NewCLITestHelper(t *testing.T) *CLITestHelper <span class="cov8" title="1">{
        // Create temporary directory for test database
        tempDir, err := os.MkdirTemp("", "knot_cli_test_*")
        require.NoError(t, err)
        
        // Save original directory
        originalDir, err := os.Getwd()
        require.NoError(t, err)
        
        // Change to temp directory
        err = os.Chdir(tempDir)
        require.NoError(t, err)
        
        // Create .knot directory
        knotDir := filepath.Join(tempDir, ".knot")
        err = os.MkdirAll(knotDir, 0755)
        require.NoError(t, err)
        
        // Create application
        application, err := app.New()
        require.NoError(t, err)
        
        return &amp;CLITestHelper{
                tempDir:     tempDir,
                originalDir: originalDir,
                app:         application,
                t:           t,
        }
}</span>

// RunCommand executes a CLI command and returns output and error
func (h *CLITestHelper) RunCommand(args ...string) (string, string, error) <span class="cov8" title="1">{
        // Prepare full args with program name
        fullArgs := append([]string{"knot"}, args...)
        
        // Capture stdout and stderr
        oldStdout := os.Stdout
        oldStderr := os.Stderr
        
        rOut, wOut, _ := os.Pipe()
        rErr, wErr, _ := os.Pipe()
        
        os.Stdout = wOut
        os.Stderr = wErr
        
        // Run the command
        err := h.app.Run(fullArgs)
        
        // Close writers and restore
        wOut.Close()
        wErr.Close()
        os.Stdout = oldStdout
        os.Stderr = oldStderr
        
        // Read captured output
        var stdout, stderr bytes.Buffer
        _, _ = io.Copy(&amp;stdout, rOut)
        _, _ = io.Copy(&amp;stderr, rErr)
        
        return stdout.String(), stderr.String(), err
}</span>

// RunCommandExpectSuccess runs a command and expects it to succeed
func (h *CLITestHelper) RunCommandExpectSuccess(args ...string) (string, string) <span class="cov8" title="1">{
        stdout, stderr, err := h.RunCommand(args...)
        require.NoError(h.t, err, "Command should succeed: %v", args)
        return stdout, stderr
}</span>

// RunCommandExpectError runs a command and expects it to fail
func (h *CLITestHelper) RunCommandExpectError(args ...string) (string, string, error) <span class="cov8" title="1">{
        stdout, stderr, err := h.RunCommand(args...)
        require.Error(h.t, err, "Command should fail: %v", args)
        return stdout, stderr, err
}</span>

// ExtractProjectID extracts project ID from create project output
func (h *CLITestHelper) ExtractProjectID(output string) string <span class="cov8" title="1">{
        // Look for pattern like "ID: uuid"
        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.Contains(line, "ID:") </span><span class="cov8" title="1">{
                        parts := strings.Split(line, "ID:")
                        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                id := strings.TrimSpace(strings.Split(parts[1], ")")[0])
                                return strings.Trim(id, "()")
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// ExtractTaskID extracts task ID from create task output
func (h *CLITestHelper) ExtractTaskID(output string) string <span class="cov8" title="1">{
        return h.ExtractProjectID(output) // Same pattern
}</span>

// Cleanup cleans up the test environment
func (h *CLITestHelper) Cleanup() <span class="cov8" title="1">{
        _ = os.Chdir(h.originalDir)
        _ = os.RemoveAll(h.tempDir)
}</span>

// CreateTestProject creates a test project and returns its ID
func (h *CLITestHelper) CreateTestProject(title, description string) string <span class="cov8" title="1">{
        stdout, _ := h.RunCommandExpectSuccess("project", "create", "--title", title, "--description", description)
        projectID := h.ExtractProjectID(stdout)
        require.NotEmpty(h.t, projectID, "Should extract project ID from output")
        return projectID
}</span>

// CreateTestTask creates a test task and returns its ID
func (h *CLITestHelper) CreateTestTask(projectID, title, description string, complexity int) string <span class="cov8" title="1">{
        // First select the project
        h.RunCommandExpectSuccess("project", "select", "--id", projectID)
        
        // Then create the task
        stdout, _ := h.RunCommandExpectSuccess("task", "create", 
                "--title", title,
                "--description", description,
                "--complexity", strconv.Itoa(complexity),
                "--priority", "medium")
        taskID := h.ExtractTaskID(stdout)
        require.NotEmpty(h.t, taskID, "Should extract task ID from output")
        return taskID
}</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"

        "github.com/denkhaus/knot/internal/manager"
        "github.com/denkhaus/knot/internal/shared"
        "github.com/urfave/cli/v2"
)

// Commands returns the config management commands
func Commands(appCtx *shared.AppContext) []*cli.Command <span class="cov8" title="1">{
        return []*cli.Command{
                {
                        Name:   "show",
                        Usage:  "Show current configuration",
                        Action: ShowAction(appCtx),
                },
                {
                        Name:   "set",
                        Usage:  "Set configuration value",
                        Action: SetAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "key",
                                        Aliases:  []string{"k"},
                                        Usage:    "Configuration key (complexity-threshold, max-depth, max-tasks-per-depth, max-description-length, auto-reduce-complexity)",
                                        Required: true,
                                },
                                &amp;cli.IntFlag{
                                        Name:     "value",
                                        Aliases:  []string{"v"},
                                        Usage:    "Configuration value",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "reset",
                        Usage:  "Reset configuration to defaults",
                        Action: ResetAction(appCtx),
                },
        }
}</span>

// ShowAction displays the current configuration
func ShowAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                config := appCtx.ProjectManager.GetConfig()

                fmt.Println("Current Knot Configuration:")
                fmt.Println()
                fmt.Printf("  Complexity Threshold:    %d (tasks &gt;= this need breakdown)\n", config.ComplexityThreshold)
                fmt.Printf("  Max Depth:               %d (maximum hierarchy levels)\n", config.MaxDepth)
                fmt.Printf("  Max Tasks Per Depth:     %d (maximum tasks per level)\n", config.MaxTasksPerDepth)
                fmt.Printf("  Max Description Length:  %d (maximum characters)\n", config.MaxDescriptionLength)
                fmt.Printf("  Auto Reduce Complexity:  %t (automatically reduce parent complexity when subtasks added)\n", config.AutoReduceComplexity)
                fmt.Println()

                // Show config file location - TODO: implement GetConfigPath method
                // configPath, err := config.GetConfigPath()
                // if err == nil {
                //         fmt.Printf("Configuration file: %s\n", configPath)
                // }

                return nil
        }</span>
}

// SetAction sets a configuration value
func SetAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                key := c.String("key")
                value := c.Int("value")

                // Get current config
                currentConfig := appCtx.ProjectManager.GetConfig()
                newConfig := *currentConfig // Copy current config

                // Update the specified key
                switch key </span>{
                case "complexity-threshold":<span class="cov8" title="1">
                        if value &lt; 1 || value &gt; 10 </span><span class="cov8" title="1">{
                                return fmt.Errorf("complexity-threshold must be between 1 and 10, got %d", value)
                        }</span>
                        <span class="cov8" title="1">newConfig.ComplexityThreshold = value</span>
                case "max-depth":<span class="cov8" title="1">
                        if value &lt; 1 </span><span class="cov8" title="1">{
                                return fmt.Errorf("max-depth must be at least 1, got %d", value)
                        }</span>
                        <span class="cov8" title="1">newConfig.MaxDepth = value</span>
                case "max-tasks-per-depth":<span class="cov8" title="1">
                        if value &lt; 1 </span><span class="cov8" title="1">{
                                return fmt.Errorf("max-tasks-per-depth must be at least 1, got %d", value)
                        }</span>
                        <span class="cov8" title="1">newConfig.MaxTasksPerDepth = value</span>
                case "max-description-length":<span class="cov8" title="1">
                        if value &lt; 1 </span><span class="cov8" title="1">{
                                return fmt.Errorf("max-description-length must be at least 1, got %d", value)
                        }</span>
                        <span class="cov8" title="1">newConfig.MaxDescriptionLength = value</span>
                case "auto-reduce-complexity":<span class="cov8" title="1">
                        // Convert int to bool: 0 = false, 1 = true
                        if value != 0 &amp;&amp; value != 1 </span><span class="cov8" title="1">{
                                return fmt.Errorf("auto-reduce-complexity must be 0 (false) or 1 (true), got %d", value)
                        }</span>
                        <span class="cov8" title="1">newConfig.AutoReduceComplexity = value == 1</span>
                default:<span class="cov8" title="1">
                        return fmt.Errorf("unknown configuration key: %s. Valid keys: complexity-threshold, max-depth, max-tasks-per-depth, max-description-length, auto-reduce-complexity", key)</span>
                }

                // Update and save config
                <span class="cov8" title="1">appCtx.ProjectManager.UpdateConfig(&amp;newConfig)
                if err := appCtx.ProjectManager.SaveConfigToFile(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save configuration: %w", err)
                }</span>

                <span class="cov8" title="1">fmt.Printf("Configuration updated: %s = %d\n", key, value)
                return nil</span>
        }
}

// ResetAction resets configuration to defaults
func ResetAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                // Reset to default config
                defaultConfig := manager.DefaultConfig()
                appCtx.ProjectManager.UpdateConfig(defaultConfig)

                // Save to file
                if err := appCtx.ProjectManager.SaveConfigToFile(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save configuration: %w", err)
                }</span>

                <span class="cov8" title="1">fmt.Println("Configuration reset to defaults:")
                fmt.Printf("  Complexity Threshold:    %d\n", defaultConfig.ComplexityThreshold)
                fmt.Printf("  Max Depth:               %d\n", defaultConfig.MaxDepth)
                fmt.Printf("  Max Tasks Per Depth:     %d\n", defaultConfig.MaxTasksPerDepth)
                fmt.Printf("  Max Description Length:  %d\n", defaultConfig.MaxDescriptionLength)
                fmt.Printf("  Auto Reduce Complexity:  %t\n", defaultConfig.AutoReduceComplexity)

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package dependency

import (
        "context"
        "fmt"

        "github.com/denkhaus/knot/internal/manager"
        "github.com/denkhaus/knot/internal/shared"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// chainAction shows the dependency chain for a task
func chainAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("task-id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid task ID: %w", err)
                }</span>

                <span class="cov0" title="0">upstream := c.Bool("upstream")
                downstream := c.Bool("downstream")

                // If neither specified, show upstream by default
                if !upstream &amp;&amp; !downstream </span><span class="cov0" title="0">{
                        upstream = true
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Showing dependency chain",
                        zap.String("taskID", taskID.String()),
                        zap.Bool("upstream", upstream),
                        zap.Bool("downstream", downstream))

                // Get the original task
                task, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get task", zap.Error(err))
                        return fmt.Errorf("failed to get task: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Dependency chain for '%s' (ID: %s):\n\n", task.Title, taskID)

                if upstream </span><span class="cov0" title="0">{
                        fmt.Println("üìà UPSTREAM DEPENDENCIES (what this task depends on):")
                        if err := showUpstreamChain(appCtx.ProjectManager, taskID, 0); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to show upstream chain: %w", err)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">if downstream </span><span class="cov0" title="0">{
                        fmt.Println("üìâ DOWNSTREAM DEPENDENCIES (what depends on this task):")
                        if err := showDownstreamChain(appCtx.ProjectManager, taskID, 0); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to show downstream chain: %w", err)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

// showUpstreamChain recursively shows what a task depends on
func showUpstreamChain(projectManager manager.ProjectManager, taskID uuid.UUID, depth int) error <span class="cov0" title="0">{
        dependencies, err := projectManager.GetTaskDependencies(context.Background(), taskID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(dependencies) == 0 </span><span class="cov0" title="0">{
                if depth == 0 </span><span class="cov0" title="0">{
                        fmt.Println("  No upstream dependencies")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">for _, dep := range dependencies </span><span class="cov0" title="0">{
                indent := ""
                for i := 0; i &lt; depth; i++ </span><span class="cov0" title="0">{
                        indent += "  "
                }</span>
                <span class="cov0" title="0">fmt.Printf("%s  ‚îú‚îÄ %s (ID: %s) - %s\n", indent, dep.Title, dep.ID, dep.State)

                // Recursively show dependencies of this dependency
                if err := showUpstreamChain(projectManager, dep.ID, depth+1); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// showDownstreamChain recursively shows what depends on a task
func showDownstreamChain(projectManager manager.ProjectManager, taskID uuid.UUID, depth int) error <span class="cov0" title="0">{
        dependents, err := projectManager.GetDependentTasks(context.Background(), taskID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(dependents) == 0 </span><span class="cov0" title="0">{
                if depth == 0 </span><span class="cov0" title="0">{
                        fmt.Println("  No downstream dependencies")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">for _, dep := range dependents </span><span class="cov0" title="0">{
                indent := ""
                for i := 0; i &lt; depth; i++ </span><span class="cov0" title="0">{
                        indent += "  "
                }</span>
                <span class="cov0" title="0">fmt.Printf("%s  ‚îú‚îÄ %s (ID: %s) - %s\n", indent, dep.Title, dep.ID, dep.State)

                // Recursively show dependents of this dependent
                if err := showDownstreamChain(projectManager, dep.ID, depth+1); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// cyclesAction detects circular dependencies in a project
func cyclesAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectIDStr := c.String("project-id")
                projectID, err := uuid.Parse(projectIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid project ID: %w", err)
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Detecting dependency cycles", zap.String("projectID", projectID.String()))

                // Get all tasks in the project
                tasks, err := appCtx.ProjectManager.ListTasksForProject(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get project tasks", zap.Error(err))
                        return fmt.Errorf("failed to get project tasks: %w", err)
                }</span>

                <span class="cov0" title="0">cycles := detectCycles(tasks)

                fmt.Printf("Circular dependency analysis for project %s:\n\n", projectID)

                if len(cycles) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("‚úÖ No circular dependencies detected!")
                        return nil
                }</span>

                <span class="cov0" title="0">fmt.Printf("‚ö†Ô∏è  Found %d circular dependency cycle(s):\n\n", len(cycles))

                for i, cycle := range cycles </span><span class="cov0" title="0">{
                        fmt.Printf("Cycle %d:\n", i+1)
                        for j, taskID := range cycle </span><span class="cov0" title="0">{
                                // Find task details
                                var task *types.Task
                                for _, t := range tasks </span><span class="cov0" title="0">{
                                        if t.ID == taskID </span><span class="cov0" title="0">{
                                                task = t
                                                break</span>
                                        }
                                }

                                <span class="cov0" title="0">if task != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("  %d. %s (ID: %s)\n", j+1, task.Title, taskID)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("  %d. Unknown task (ID: %s)\n", j+1, taskID)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("  ‚îî‚îÄ Back to: %s\n\n", cycle[0])</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

// detectCycles uses DFS to detect circular dependencies
func detectCycles(tasks []*types.Task) [][]uuid.UUID <span class="cov0" title="0">{
        // Build adjacency list
        graph := make(map[uuid.UUID][]uuid.UUID)
        for _, task := range tasks </span><span class="cov0" title="0">{
                graph[task.ID] = task.Dependencies
        }</span>

        <span class="cov0" title="0">var cycles [][]uuid.UUID
        visited := make(map[uuid.UUID]bool)
        recStack := make(map[uuid.UUID]bool)
        path := make([]uuid.UUID, 0)

        var dfs func(uuid.UUID) bool
        dfs = func(taskID uuid.UUID) bool </span><span class="cov0" title="0">{
                visited[taskID] = true
                recStack[taskID] = true
                path = append(path, taskID)

                for _, depID := range graph[taskID] </span><span class="cov0" title="0">{
                        if !visited[depID] </span><span class="cov0" title="0">{
                                if dfs(depID) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        } else<span class="cov0" title="0"> if recStack[depID] </span><span class="cov0" title="0">{
                                // Found a cycle - extract it from path
                                cycleStart := -1
                                for i, id := range path </span><span class="cov0" title="0">{
                                        if id == depID </span><span class="cov0" title="0">{
                                                cycleStart = i
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if cycleStart &gt;= 0 </span><span class="cov0" title="0">{
                                        cycle := make([]uuid.UUID, len(path)-cycleStart)
                                        copy(cycle, path[cycleStart:])
                                        cycles = append(cycles, cycle)
                                }</span>
                                <span class="cov0" title="0">return true</span>
                        }
                }

                <span class="cov0" title="0">recStack[taskID] = false
                path = path[:len(path)-1]
                return false</span>
        }

        // Check all nodes
        <span class="cov0" title="0">for _, task := range tasks </span><span class="cov0" title="0">{
                if !visited[task.ID] </span><span class="cov0" title="0">{
                        dfs(task.ID)
                }</span>
        }

        <span class="cov0" title="0">return cycles</span>
}

// validateAction validates all dependencies in a project
func validateAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectIDStr := c.String("project-id")
                projectID, err := uuid.Parse(projectIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid project ID: %w", err)
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Validating dependencies", zap.String("projectID", projectID.String()))

                // Get all tasks in the project
                tasks, err := appCtx.ProjectManager.ListTasksForProject(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get project tasks", zap.Error(err))
                        return fmt.Errorf("failed to get project tasks: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Dependency validation for project %s:\n\n", projectID)

                // Create task map for quick lookup
                taskMap := make(map[uuid.UUID]*types.Task)
                for _, task := range tasks </span><span class="cov0" title="0">{
                        taskMap[task.ID] = task
                }</span>

                <span class="cov0" title="0">var issues []string
                orphanedDeps := 0
                totalDeps := 0

                // Validate each task's dependencies
                for _, task := range tasks </span><span class="cov0" title="0">{
                        for _, depID := range task.Dependencies </span><span class="cov0" title="0">{
                                totalDeps++
                                if _, exists := taskMap[depID]; !exists </span><span class="cov0" title="0">{
                                        issues = append(issues, fmt.Sprintf("Task '%s' (ID: %s) depends on non-existent task %s",
                                                task.Title, task.ID, depID))
                                        orphanedDeps++
                                }</span>
                        }
                }

                // Check for cycles
                <span class="cov0" title="0">cycles := detectCycles(tasks)

                // Report results
                fmt.Printf("üìä VALIDATION SUMMARY:\n")
                fmt.Printf("  Total tasks: %d\n", len(tasks))
                fmt.Printf("  Total dependencies: %d\n", totalDeps)
                fmt.Printf("  Orphaned dependencies: %d\n", orphanedDeps)
                fmt.Printf("  Circular dependencies: %d\n", len(cycles))
                fmt.Println()

                if len(issues) == 0 &amp;&amp; len(cycles) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("‚úÖ All dependencies are valid!")
                        return nil
                }</span>

                <span class="cov0" title="0">if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  ORPHANED DEPENDENCIES (%d):\n", len(issues))
                        for i, issue := range issues </span><span class="cov0" title="0">{
                                fmt.Printf("  %d. %s\n", i+1, issue)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">if len(cycles) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("‚ö†Ô∏è  CIRCULAR DEPENDENCIES (%d cycles detected)\n", len(cycles))
                        fmt.Println("  Run 'knot dependency cycles' for detailed cycle information")
                        fmt.Println()
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package dependency

import (
        "context"
        "fmt"

        "github.com/denkhaus/knot/internal/errors"
        "github.com/denkhaus/knot/internal/shared"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// Commands returns all dependency-related CLI commands
func Commands(appCtx *shared.AppContext) []*cli.Command <span class="cov0" title="0">{
        // Basic commands
        basicCommands := []*cli.Command{
                {
                        Name:   "add",
                        Usage:  "Add task dependency",
                        Action: addAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-id",
                                        Usage:    "Task ID",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:     "depends-on",
                                        Usage:    "Task ID that this task depends on",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "remove",
                        Usage:  "Remove task dependency",
                        Action: removeAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-id",
                                        Usage:    "Task ID",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:     "depends-on",
                                        Usage:    "Task ID to remove dependency from",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "list",
                        Usage:  "List task dependencies",
                        Action: listAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-id",
                                        Usage:    "Task ID",
                                        Required: true,
                                },
                        },
                },
        }

        // Enhanced commands
        enhancedCommands := EnhancedCommands(appCtx)

        // Combine all commands
        allCommands := make([]*cli.Command, 0, len(basicCommands)+len(enhancedCommands))
        allCommands = append(allCommands, basicCommands...)
        allCommands = append(allCommands, enhancedCommands...)

        return allCommands
}</span>

func addAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("task-id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.InvalidUUIDError("task-id", taskIDStr)
                }</span>

                <span class="cov0" title="0">dependsOnStr := c.String("depends-on")
                dependsOnID, err := uuid.Parse(dependsOnStr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.InvalidUUIDError("depends-on", dependsOnStr)
                }</span>

                <span class="cov0" title="0">actor := c.String("actor")

                appCtx.Logger.Info("Adding task dependency",
                        zap.String("taskID", taskID.String()),
                        zap.String("dependsOnID", dependsOnID.String()),
                        zap.String("actor", actor))

                _, err = appCtx.ProjectManager.AddTaskDependency(context.Background(), taskID, dependsOnID, actor)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to add dependency", zap.Error(err))
                        return errors.WrapWithSuggestion(err, "adding task dependency")
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Dependency added successfully", zap.String("actor", actor))
                fmt.Printf("Added dependency: %s now depends on %s\n", taskID, dependsOnID)
                fmt.Printf("  Added by: %s\n", actor)
                return nil</span>
        }
}

func removeAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("task-id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid task ID: %w", err)
                }</span>

                <span class="cov0" title="0">dependsOnStr := c.String("depends-on")
                dependsOnID, err := uuid.Parse(dependsOnStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid depends-on ID: %w", err)
                }</span>

                <span class="cov0" title="0">actor := c.String("actor")

                appCtx.Logger.Info("Removing task dependency",
                        zap.String("taskID", taskID.String()),
                        zap.String("dependsOnID", dependsOnID.String()),
                        zap.String("actor", actor))

                _, err = appCtx.ProjectManager.RemoveTaskDependency(context.Background(), taskID, dependsOnID, actor)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to remove dependency", zap.Error(err))
                        return fmt.Errorf("failed to remove dependency: %w", err)
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Dependency removed successfully", zap.String("actor", actor))
                fmt.Printf("Removed dependency: %s no longer depends on %s\n", taskID, dependsOnID)
                fmt.Printf("  Removed by: %s\n", actor)
                return nil</span>
        }
}

func listAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("task-id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid task ID: %w", err)
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Listing task dependencies", zap.String("taskID", taskID.String()))

                dependencies, err := appCtx.ProjectManager.GetTaskDependencies(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get dependencies", zap.Error(err))
                        return fmt.Errorf("failed to get dependencies: %w", err)
                }</span>

                <span class="cov0" title="0">dependents, err := appCtx.ProjectManager.GetDependentTasks(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get dependents", zap.Error(err))
                        return fmt.Errorf("failed to get dependents: %w", err)
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Dependencies retrieved",
                        zap.Int("dependencies", len(dependencies)),
                        zap.Int("dependents", len(dependents)))

                fmt.Printf("Dependencies for task %s:\n\n", taskID)

                if len(dependencies) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("This task depends on:")
                        for _, dep := range dependencies </span><span class="cov0" title="0">{
                                fmt.Printf("  ‚Ä¢ %s (ID: %s) - %s\n", dep.Title, dep.ID, dep.State)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println("This task has no dependencies.")
                }</span>

                <span class="cov0" title="0">fmt.Println()

                if len(dependents) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("Tasks that depend on this task:")
                        for _, dep := range dependents </span><span class="cov0" title="0">{
                                fmt.Printf("  ‚Ä¢ %s (ID: %s) - %s\n", dep.Title, dep.ID, dep.State)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println("No tasks depend on this task.")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package dependency

import (
        "context"
        "fmt"
        "sort"

        "github.com/denkhaus/knot/internal/manager"
        "github.com/denkhaus/knot/internal/shared"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// EnhancedCommands returns enhanced dependency-related CLI commands
func EnhancedCommands(appCtx *shared.AppContext) []*cli.Command <span class="cov0" title="0">{
        return []*cli.Command{
                {
                        Name:   "dependents",
                        Usage:  "List tasks that depend on this task",
                        Action: dependentsAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-id",
                                        Usage:    "Task ID",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "recursive",
                                        Usage: "Show all transitive dependents (tasks that depend on dependents)",
                                        Value: false,
                                },
                        },
                },
                {
                        Name:   "chain",
                        Usage:  "Show dependency chain for a task",
                        Action: chainAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-id",
                                        Usage:    "Task ID",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "upstream",
                                        Usage: "Show upstream dependencies (what this task depends on)",
                                        Value: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "downstream",
                                        Usage: "Show downstream dependencies (what depends on this task)",
                                        Value: false,
                                },
                        },
                },
                {
                        Name:   "cycles",
                        Usage:  "Detect circular dependencies in project",
                        Action: cyclesAction(appCtx),
                },
                {
                        Name:   "validate",
                        Usage:  "Validate all dependencies in project",
                        Action: validateAction(appCtx),
                },
        }
}</span>

func dependentsAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("task-id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid task ID: %w", err)
                }</span>

                <span class="cov0" title="0">recursive := c.Bool("recursive")

                appCtx.Logger.Info("Getting dependent tasks",
                        zap.String("taskID", taskID.String()),
                        zap.Bool("recursive", recursive))

                var dependents []*types.Task
                if recursive </span><span class="cov0" title="0">{
                        dependents, err = getAllTransitiveDependents(appCtx.ProjectManager, taskID)
                }</span> else<span class="cov0" title="0"> {
                        dependents, err = appCtx.ProjectManager.GetDependentTasks(context.Background(), taskID)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get dependents", zap.Error(err))
                        return fmt.Errorf("failed to get dependents: %w", err)
                }</span>

                // Get the original task for context
                <span class="cov0" title="0">task, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get task", zap.Error(err))
                        return fmt.Errorf("failed to get task: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Tasks that depend on '%s' (ID: %s):\n\n", task.Title, taskID)

                if len(dependents) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No tasks depend on this task.")
                        return nil
                }</span>

                // Sort by state and title for consistent output
                <span class="cov0" title="0">sort.Slice(dependents, func(i, j int) bool </span><span class="cov0" title="0">{
                        if dependents[i].State != dependents[j].State </span><span class="cov0" title="0">{
                                return dependents[i].State &lt; dependents[j].State
                        }</span>
                        <span class="cov0" title="0">return dependents[i].Title &lt; dependents[j].Title</span>
                })

                <span class="cov0" title="0">for i, dep := range dependents </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s (ID: %s)\n", i+1, dep.Title, dep.ID)
                        if dep.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   %s\n", dep.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("   State: %s | Complexity: %d\n", dep.State, dep.Complexity)
                        if dep.Depth &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("   Depth: %d", dep.Depth)
                                if dep.ParentID != nil </span><span class="cov0" title="0">{
                                        fmt.Printf(" | Parent: %s", *dep.ParentID)
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">if recursive </span><span class="cov0" title="0">{
                        fmt.Printf("Total: %d transitive dependents\n", len(dependents))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Total: %d direct dependents\n", len(dependents))
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

// getAllTransitiveDependents recursively gets all tasks that depend on the given task
func getAllTransitiveDependents(projectManager manager.ProjectManager, taskID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        visited := make(map[uuid.UUID]bool)
        var result []*types.Task

        var collectDependents func(uuid.UUID) error
        collectDependents = func(id uuid.UUID) error </span><span class="cov0" title="0">{
                if visited[id] </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">visited[id] = true

                dependents, err := projectManager.GetDependentTasks(context.Background(), id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, dep := range dependents </span><span class="cov0" title="0">{
                        if !visited[dep.ID] </span><span class="cov0" title="0">{
                                result = append(result, dep)
                                if err := collectDependents(dep.ID); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if err := collectDependents(taskID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package health

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/denkhaus/knot/internal/logger"
        "github.com/denkhaus/knot/internal/shared"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// Commands returns health check related CLI commands
func Commands(appCtx *shared.AppContext) []*cli.Command <span class="cov0" title="0">{
        return []*cli.Command{
                {
                        Name:   "check",
                        Usage:  "Check database connection health",
                        Action: checkAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.BoolFlag{
                                        Name:  "json",
                                        Usage: "Output health status as JSON",
                                        Value: false,
                                },
                                &amp;cli.DurationFlag{
                                        Name:  "timeout",
                                        Usage: "Health check timeout",
                                        Value: time.Second * 10,
                                },
                        },
                },
                {
                        Name:   "ping",
                        Usage:  "Simple database connectivity test",
                        Action: pingAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.DurationFlag{
                                        Name:  "timeout",
                                        Usage: "Ping timeout",
                                        Value: time.Second * 5,
                                },
                        },
                },
                {
                        Name:   "validate",
                        Usage:  "Comprehensive database connection validation",
                        Action: validateAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.DurationFlag{
                                        Name:  "timeout",
                                        Usage: "Validation timeout",
                                        Value: time.Second * 30,
                                },
                        },
                },
        }
}</span>

func checkAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                timeout := c.Duration("timeout")
                jsonOutput := c.Bool("json")

                ctx, cancel := context.WithTimeout(context.Background(), timeout)
                defer cancel()

                logger.Log.Info("Performing database health check", zap.Duration("timeout", timeout))

                // Get health status from repository
                // Note: This requires extending the manager interface to expose health checks
                health, err := performHealthCheck(ctx, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("Health check failed", zap.Error(err))
                        return fmt.Errorf("health check failed: %w", err)
                }</span>

                <span class="cov0" title="0">if jsonOutput </span><span class="cov0" title="0">{
                        jsonData, err := json.MarshalIndent(health, "", "  ")
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to marshal health status: %w", err)
                        }</span>
                        <span class="cov0" title="0">fmt.Println(string(jsonData))</span>
                } else<span class="cov0" title="0"> {
                        printHealthStatus(health)
                }</span>

                <span class="cov0" title="0">if !health.Healthy </span><span class="cov0" title="0">{
                        return fmt.Errorf("database connection is unhealthy")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

func pingAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                timeout := c.Duration("timeout")

                ctx, cancel := context.WithTimeout(context.Background(), timeout)
                defer cancel()

                logger.Log.Info("Pinging database", zap.Duration("timeout", timeout))

                start := time.Now()
                err := performPing(ctx, appCtx)
                latency := time.Since(start)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("Database ping failed", zap.Error(err), zap.Duration("latency", latency))
                        fmt.Printf("Database ping failed: %v\n", err)
                        fmt.Printf("Latency: %v\n", latency)
                        return err
                }</span>

                <span class="cov0" title="0">logger.Log.Info("Database ping successful", zap.Duration("latency", latency))
                fmt.Printf("Database ping successful\n")
                fmt.Printf("Latency: %v\n", latency)

                if latency &gt; time.Millisecond*100 </span><span class="cov0" title="0">{
                        fmt.Printf("High latency detected (&gt;100ms)\n")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

func validateAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                timeout := c.Duration("timeout")

                ctx, cancel := context.WithTimeout(context.Background(), timeout)
                defer cancel()

                logger.Log.Info("Validating database connection", zap.Duration("timeout", timeout))

                err := performValidation(ctx, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("Database validation failed", zap.Error(err))
                        fmt.Printf("Database validation failed: %v\n", err)
                        return err
                }</span>

                <span class="cov0" title="0">logger.Log.Info("Database validation successful")
                fmt.Printf("‚úÖ Database connection validation successful\n")
                fmt.Printf("   All checks passed\n")

                return nil</span>
        }
}

// HealthStatus represents database health information
type HealthStatus struct {
        Healthy          bool          `json:"healthy"`
        ConnectionActive bool          `json:"connection_active"`
        PingLatency      time.Duration `json:"ping_latency"`
        OpenConnections  int           `json:"open_connections"`
        IdleConnections  int           `json:"idle_connections"`
        InUseConnections int           `json:"in_use_connections"`
        ErrorMessage     string        `json:"error_message,omitempty"`
        LastChecked      time.Time     `json:"last_checked"`
        DatabasePath     string        `json:"database_path"`
        WALModeEnabled   bool          `json:"wal_mode_enabled"`
        ForeignKeys      bool          `json:"foreign_keys_enabled"`
}

// performHealthCheck performs a health check using the project manager
func performHealthCheck(ctx context.Context, appCtx *shared.AppContext) (*HealthStatus, error) <span class="cov0" title="0">{
        // For now, we'll implement a basic health check
        // TODO: Extend manager interface to expose repository health checks

        start := time.Now()

        // Test basic functionality by listing projects
        _, err := appCtx.ProjectManager.ListProjects(ctx)
        latency := time.Since(start)

        health := &amp;HealthStatus{
                LastChecked:      time.Now(),
                PingLatency:      latency,
                ConnectionActive: err == nil,
                Healthy:          err == nil,
                DatabasePath:     ".knot/knot.db", // Default path
        }

        if err != nil </span><span class="cov0" title="0">{
                health.ErrorMessage = err.Error()
        }</span>

        <span class="cov0" title="0">return health, nil</span>
}

// performPing performs a simple connectivity test
func performPing(ctx context.Context, appCtx *shared.AppContext) error <span class="cov0" title="0">{
        // Test basic connectivity by attempting to list projects
        _, err := appCtx.ProjectManager.ListProjects(ctx)
        return err
}</span>

// performValidation performs comprehensive validation
func performValidation(ctx context.Context, appCtx *shared.AppContext) error <span class="cov0" title="0">{
        // Test multiple operations to validate connection
        tests := []struct {
                name string
                test func() error
        }{
                {"List Projects", func() error </span><span class="cov0" title="0">{
                        _, err := appCtx.ProjectManager.ListProjects(ctx)
                        return err
                }</span>},
                {"Get Config", func() error <span class="cov0" title="0">{
                        config := appCtx.ProjectManager.GetConfig()
                        if config == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("config is nil")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }},
        }

        <span class="cov0" title="0">for _, test := range tests </span><span class="cov0" title="0">{
                if err := test.test(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s failed: %w", test.name, err)
                }</span>
                <span class="cov0" title="0">logger.Log.Debug("Validation test passed", zap.String("test", test.name))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// printHealthStatus prints health status in human-readable format
func printHealthStatus(health *HealthStatus) <span class="cov0" title="0">{
        fmt.Printf("Database Health Status:\n\n")

        if health.Healthy </span><span class="cov0" title="0">{
                fmt.Printf("‚úÖ Status: Healthy\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("‚ùå Status: Unhealthy\n")
                if health.ErrorMessage != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   Error: %s\n", health.ErrorMessage)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("üìä Connection Details:\n")
        fmt.Printf("   Active: %v\n", health.ConnectionActive)
        fmt.Printf("   Latency: %v\n", health.PingLatency)
        fmt.Printf("   Database: %s\n", health.DatabasePath)
        fmt.Printf("   Last Checked: %v\n", health.LastChecked.Format(time.RFC3339))

        if health.OpenConnections &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("üîó Connection Pool:\n")
                fmt.Printf("   Open: %d\n", health.OpenConnections)
                fmt.Printf("   Idle: %d\n", health.IdleConnections)
                fmt.Printf("   In Use: %d\n", health.InUseConnections)
        }</span>

        <span class="cov0" title="0">if health.WALModeEnabled || health.ForeignKeys </span><span class="cov0" title="0">{
                fmt.Printf("‚öôÔ∏è  SQLite Settings:\n")
                if health.WALModeEnabled </span><span class="cov0" title="0">{
                        fmt.Printf("   WAL Mode: ‚úÖ Enabled\n")
                }</span>
                <span class="cov0" title="0">if health.ForeignKeys </span><span class="cov0" title="0">{
                        fmt.Printf("   Foreign Keys: ‚úÖ Enabled\n")
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package project

import (
        "context"
        "encoding/json"
        "fmt"
        "os"

        "github.com/denkhaus/knot/internal/errors"
        "github.com/denkhaus/knot/internal/shared"
        "github.com/denkhaus/knot/internal/types"
        "github.com/denkhaus/knot/internal/validation"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)


// Commands returns all project-related CLI commands
func Commands(appCtx *shared.AppContext) []*cli.Command <span class="cov0" title="0">{
        return []*cli.Command{
                {
                        Name:   "create",
                        Usage:  "Create a new project",
                        Action: createAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "title",
                                        Aliases:  []string{"t"},
                                        Usage:    "Project title",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:    "description",
                                        Aliases: []string{"d"},
                                        Usage:   "Project description",
                                },
                        },
                },
                {
                        Name:   "list",
                        Usage:  "List all projects",
                        Action: listAction(appCtx),
                },
                {
                        Name:   "get",
                        Usage:  "Get project details",
                        Action: getAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "id",
                                        Usage:    "Project ID",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "delete",
                        Usage:  "Delete a project with two-step confirmation",
                        Action: deleteAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "id",
                                        Usage:    "Project ID to delete",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "dry-run",
                                        Usage: "Show what would be deleted without actually deleting",
                                        Value: false,
                                },
                        },
                },
                {
                        Name:   "select",
                        Usage:  "Select a project as the current context",
                        Action: selectAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "id",
                                        Usage:    "Project ID to select",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "get-selected",
                        Usage:  "Show the currently selected project",
                        Action: getSelectedAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.BoolFlag{
                                        Name:    "json",
                                        Aliases: []string{"j"},
                                        Usage:   "Output in JSON format",
                                },
                        },
                },
                {
                        Name:   "clear-selection",
                        Usage:  "Clear the currently selected project",
                        Action: clearSelectionAction(appCtx),
                },
        }
}</span>

func createAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                title := c.String("title")
                description := c.String("description")
                actor := c.String("actor")

                // Create input validator
                validator := validation.NewInputValidator()

                // Validate inputs
                if err := validator.ValidateProjectTitle(title); err != nil </span><span class="cov8" title="1">{
                        return errors.NewValidationError("invalid project title", err)
                }</span>

                <span class="cov8" title="1">if err := validator.ValidateProjectDescription(description); err != nil </span><span class="cov8" title="1">{
                        return errors.NewValidationError("invalid project description", err)
                }</span>

                // Default to $USER if actor is not provided
                <span class="cov8" title="1">if actor == "" </span><span class="cov8" title="1">{
                        actor = os.Getenv("USER")
                        if actor == "" </span><span class="cov0" title="0">{
                                actor = "unknown"
                        }</span>
                }

                <span class="cov8" title="1">appCtx.Logger.Info("Creating project", zap.String("title", title), zap.String("description", description), zap.String("actor", actor))

                project, err := appCtx.ProjectManager.CreateProject(context.Background(), title, description, actor)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to create project", zap.Error(err))
                        return errors.WrapWithSuggestion(err, "creating project")
                }</span>

                <span class="cov8" title="1">appCtx.Logger.Info("Project created successfully", zap.String("projectID", project.ID.String()), zap.String("title", project.Title), zap.String("actor", actor))
                fmt.Printf("Created project: %s (ID: %s)\n", project.Title, project.ID)
                fmt.Printf("  Created by: %s\n", actor)
                if project.Description != "" </span><span class="cov8" title="1">{
                        fmt.Printf("  Description: %s\n", project.Description)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func listAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                appCtx.Logger.Info("Listing projects")

                projects, err := appCtx.ProjectManager.ListProjects(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to list projects", zap.Error(err))
                        return errors.WrapWithSuggestion(err, "listing projects")
                }</span>

                <span class="cov8" title="1">appCtx.Logger.Info("Projects retrieved", zap.Int("count", len(projects)))

                if len(projects) == 0 </span><span class="cov8" title="1">{
                        return errors.EmptyResultError("list projects", "current workspace")
                }</span>

                <span class="cov8" title="1">fmt.Printf("Found %d project(s):\n\n", len(projects))
                for _, project := range projects </span><span class="cov8" title="1">{
                        fmt.Printf("‚Ä¢ %s (ID: %s)\n", project.Title, project.ID)
                        if project.Description != "" </span><span class="cov8" title="1">{
                                fmt.Printf("  %s\n", project.Description)
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("  Progress: %.1f%% (%d/%d tasks completed)\n",
                                project.Progress, project.CompletedTasks, project.TotalTasks)
                        fmt.Println()</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
}

func getAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                idStr := c.String("id")
                projectID, err := uuid.Parse(idStr)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid project ID: %w", err)
                }</span>

                <span class="cov8" title="1">appCtx.Logger.Info("Getting project", zap.String("projectID", projectID.String()))

                project, err := appCtx.ProjectManager.GetProject(context.Background(), projectID)
                if err != nil </span><span class="cov8" title="1">{
                        appCtx.Logger.Error("Failed to get project", zap.Error(err))
                        return fmt.Errorf("failed to get project: %w", err)
                }</span>

                <span class="cov8" title="1">fmt.Printf("Project: %s\n", project.Title)
                fmt.Printf("ID: %s\n", project.ID)
                if project.Description != "" </span><span class="cov8" title="1">{
                        fmt.Printf("Description: %s\n", project.Description)
                }</span>
                <span class="cov8" title="1">fmt.Printf("Progress: %.1f%% (%d/%d tasks completed)\n",
                        project.Progress, project.CompletedTasks, project.TotalTasks)
                fmt.Printf("Created: %s\n", project.CreatedAt.Format("2006-01-02 15:04:05"))
                fmt.Printf("Updated: %s\n", project.UpdatedAt.Format("2006-01-02 15:04:05"))

                return nil</span>
        }
}

func deleteAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectIDStr := c.String("id")
                projectID, err := uuid.Parse(projectIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;errors.EnhancedError{
                                Operation:   "parsing project ID",
                                Cause:       err,
                                Suggestion:  "Provide a valid UUID for the project ID",
                                Example:     "knot project delete --id 550e8400-e29b-41d4-a716-446655440000",
                                HelpCommand: "knot project delete --help",
                        }
                }</span>

                <span class="cov0" title="0">dryRun := c.Bool("dry-run")

                // Get project details
                project, err := appCtx.ProjectManager.GetProject(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;errors.EnhancedError{
                                Operation:   "retrieving project",
                                Cause:       err,
                                Suggestion:  "Verify the project ID exists",
                                Example:     "knot project list",
                                HelpCommand: "knot project get --help",
                        }
                }</span>

                // Check if project has tasks
                <span class="cov0" title="0">tasks, err := appCtx.ProjectManager.ListTasksForProject(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;errors.EnhancedError{
                                Operation:   "checking project tasks",
                                Cause:       err,
                                Suggestion:  "Unable to verify if project has tasks",
                                HelpCommand: "knot task list --help",
                        }
                }</span>

                // Two-step deletion process
                <span class="cov0" title="0">if project.State == types.ProjectStateDeletionPending </span><span class="cov0" title="0">{
                        // Second call - actually delete the project
                        if dryRun </span><span class="cov0" title="0">{
                                fmt.Printf("üîç DRY RUN: Project would be permanently deleted (no actual changes made)\n")
                                return nil
                        }</span>

                        // Show what will be deleted
                        <span class="cov0" title="0">fmt.Printf("üóëÔ∏è  Final deletion of project:\n")
                        fmt.Printf("  ‚Ä¢ %s (ID: %s)\n", project.Title, project.ID)
                        if project.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("    %s\n", project.Description)
                        }</span>
                        <span class="cov0" title="0">if len(tasks) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("    ‚ö†Ô∏è  This will also delete %d task(s)\n", len(tasks))
                        }</span>

                        // Perform deletion
                        <span class="cov0" title="0">err = appCtx.ProjectManager.DeleteProject(context.Background(), projectID)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;errors.EnhancedError{
                                        Operation:   "deleting project",
                                        Cause:       err,
                                        Suggestion:  "Check if the project still exists or if there are constraint violations",
                                        HelpCommand: "knot project get --help",
                                }
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("‚úÖ Project permanently deleted: %s\n", project.Title)
                        return nil</span>
                } else<span class="cov0" title="0"> {
                        // First call - mark for deletion
                        if dryRun </span><span class="cov0" title="0">{
                                fmt.Printf("üîç DRY RUN: Project would be marked for deletion (no actual changes made)\n")
                                return nil
                        }</span>

                        // Show what will be marked for deletion
                        <span class="cov0" title="0">fmt.Printf("üìã Project to be marked for deletion:\n")
                        fmt.Printf("  ‚Ä¢ %s (ID: %s)\n", project.Title, project.ID)
                        if project.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("    %s\n", project.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("    Current State: %s\n", project.State)
                        fmt.Printf("    Progress: %.1f%% (%d/%d tasks)\n", project.Progress, project.CompletedTasks, project.TotalTasks)

                        if len(tasks) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("\n  ‚ö†Ô∏è  This project contains %d task(s):\n", len(tasks))
                                for i, task := range tasks </span><span class="cov0" title="0">{
                                        if i &lt; 5 </span><span class="cov0" title="0">{ // Show first 5 tasks
                                                fmt.Printf("    ‚Ä¢ %s (%s)\n", task.Title, task.State)
                                        }</span> else<span class="cov0" title="0"> if i == 5 </span><span class="cov0" title="0">{
                                                fmt.Printf("    ‚Ä¢ ... and %d more task(s)\n", len(tasks)-5)
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">fmt.Printf("    All tasks will be deleted with the project.\n")</span>
                        }

                        // Mark project for deletion
                        <span class="cov0" title="0">_, err = appCtx.ProjectManager.UpdateProjectState(context.Background(), projectID, types.ProjectStateDeletionPending, appCtx.Actor)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;errors.EnhancedError{
                                        Operation:   "marking project for deletion",
                                        Cause:       err,
                                        Suggestion:  "Check if the project state transition is valid",
                                        HelpCommand: "knot project get --help",
                                }
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("\n‚ö†Ô∏è  Project marked for deletion. To confirm deletion, run the same command again:\n")
                        fmt.Printf("    knot project delete --id %s\n", projectID)
                        fmt.Printf("\nüí° To cancel deletion, change the project state:\n")
                        fmt.Printf("    knot project update-state --id %s --state active\n", projectID)

                        return nil</span>
                }
        }
}

// selectAction selects a project as the current context
func selectAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                projectIDStr := c.String("id")
                projectID, err := uuid.Parse(projectIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.InvalidUUIDError("project-id", projectIDStr)
                }</span>

                // Verify project exists
                <span class="cov8" title="1">project, err := appCtx.ProjectManager.GetProject(context.Background(), projectID)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("project not found: %w", err)
                }</span>

                // Set as selected project
                <span class="cov8" title="1">actor := appCtx.GetActor()
                err = appCtx.ProjectManager.SetSelectedProject(context.Background(), projectID, actor)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to select project: %w", err)
                }</span>

                <span class="cov8" title="1">fmt.Printf("Selected project: %s (ID: %s)\n", project.Title, project.ID)
                return nil</span>
        }
}

// getSelectedAction shows the currently selected project
func getSelectedAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                selectedProjectID, err := appCtx.ProjectManager.GetSelectedProject(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get selected project: %w", err)
                }</span>

                <span class="cov8" title="1">if selectedProjectID == nil </span><span class="cov8" title="1">{
                        if c.Bool("json") </span><span class="cov0" title="0">{
                                fmt.Println("null")
                                return nil
                        }</span>
                        <span class="cov8" title="1">fmt.Println("No project currently selected")
                        fmt.Println("Use 'knot project select --id &lt;project-id&gt;' to select a project")
                        return nil</span>
                }

                // Get project details
                <span class="cov8" title="1">project, err := appCtx.ProjectManager.GetProject(context.Background(), *selectedProjectID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("selected project not found: %w", err)
                }</span>

                <span class="cov8" title="1">if c.Bool("json") </span><span class="cov0" title="0">{
                        projectJSON, err := json.Marshal(project)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to marshal project: %w", err)
                        }</span>
                        <span class="cov0" title="0">fmt.Println(string(projectJSON))
                        return nil</span>
                }

                <span class="cov8" title="1">fmt.Printf("Currently selected project:\n\n")
                fmt.Printf("* %s (ID: %s)\n", project.Title, project.ID)
                if project.Description != "" </span><span class="cov8" title="1">{
                        fmt.Printf("  %s\n", project.Description)
                }</span>
                <span class="cov8" title="1">fmt.Printf("  State: %s | Progress: %.1f%%\n", project.State, project.Progress)
                fmt.Printf("  Tasks: %d total, %d completed\n", project.TotalTasks, project.CompletedTasks)
                return nil</span>
        }
}

// clearSelectionAction clears the currently selected project
func clearSelectionAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                // Check if there's a selection to clear
                hasSelected, err := appCtx.ProjectManager.HasSelectedProject(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check selected project: %w", err)
                }</span>

                <span class="cov8" title="1">if !hasSelected </span><span class="cov8" title="1">{
                        fmt.Println("No project currently selected")
                        return nil
                }</span>

                // Clear the selection
                <span class="cov8" title="1">err = appCtx.ProjectManager.ClearSelectedProject(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear selected project: %w", err)
                }</span>

                <span class="cov8" title="1">fmt.Println("Project selection cleared")
                fmt.Println("Use 'knot project select --id &lt;project-id&gt;' to select a project")
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package task

import (
        "context"
        "fmt"

        "github.com/denkhaus/knot/internal/shared"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// analysis.go contains task analysis and discovery commands
// - actionable: find next actionable task
// - breakdown: find tasks needing breakdown
// - ready: show ready tasks (moved from commands.go)
// - blocked: show blocked tasks (moved from commands.go)

// isTaskReady checks if a task has all its dependencies completed
func isTaskReady(task *types.Task, taskMap map[uuid.UUID]*types.Task) bool <span class="cov8" title="1">{
        // If task has no dependencies, it's ready
        if len(task.Dependencies) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check if all dependencies are completed
        <span class="cov8" title="1">for _, depID := range task.Dependencies </span><span class="cov8" title="1">{
                depTask, exists := taskMap[depID]
                if !exists || depTask.State != types.TaskStateCompleted </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// ActionableAction finds the next actionable task in a project
func ActionableAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Finding next actionable task", zap.String("projectID", projectID.String()))

                // Get all tasks in the project
                allTasks, err := appCtx.ProjectManager.ListTasksForProject(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get project tasks", zap.Error(err))
                        return fmt.Errorf("failed to get project tasks: %w", err)
                }</span>

                // Create a map of task IDs to tasks for quick lookup
                <span class="cov0" title="0">taskMap := make(map[uuid.UUID]*types.Task)
                for _, task := range allTasks </span><span class="cov0" title="0">{
                        taskMap[task.ID] = task
                }</span>

                // Separate tasks by state
                <span class="cov0" title="0">var pendingTasks, inProgressTasks []*types.Task
                for _, task := range allTasks </span><span class="cov0" title="0">{
                        switch task.State </span>{
                        case types.TaskStatePending:<span class="cov0" title="0">
                                pendingTasks = append(pendingTasks, task)</span>
                        case types.TaskStateInProgress:<span class="cov0" title="0">
                                inProgressTasks = append(inProgressTasks, task)</span>
                        }
                }

                // Show project context indicator
                <span class="cov0" title="0">shared.ShowProjectContextWithSeparator(c, appCtx)

                // Prioritize in-progress tasks first
                if len(inProgressTasks) &gt; 0 </span><span class="cov0" title="0">{
                        // For in-progress tasks, find one that has all its dependencies met
                        for _, task := range inProgressTasks </span><span class="cov0" title="0">{
                                if isTaskReady(task, taskMap) </span><span class="cov0" title="0">{
                                        fmt.Printf("Next actionable task (in-progress):\n\n")
                                        fmt.Printf("* %s (ID: %s)\n", task.Title, task.ID)
                                        if task.Description != "" </span><span class="cov0" title="0">{
                                                fmt.Printf("  %s\n", task.Description)
                                        }</span>
                                        <span class="cov0" title="0">fmt.Printf("  State: %s | Complexity: %d\n", task.State, task.Complexity)
                                        if task.Depth &gt; 0 </span><span class="cov0" title="0">{
                                                fmt.Printf("  Depth: %d", task.Depth)
                                                if task.ParentID != nil </span><span class="cov0" title="0">{
                                                        fmt.Printf(" | Parent: %s", *task.ParentID)
                                                }</span>
                                                <span class="cov0" title="0">fmt.Println()</span>
                                        }
                                        <span class="cov0" title="0">return nil</span>
                                }
                        }
                        // If no in-progress task has its dependencies met, this indicates an inconsistency
                        <span class="cov0" title="0">fmt.Println("Warning: In-progress tasks exist but none have all dependencies met - possible data inconsistency")</span>
                }

                // For pending tasks, find one that has all its dependencies met
                <span class="cov0" title="0">for _, task := range pendingTasks </span><span class="cov0" title="0">{
                        if isTaskReady(task, taskMap) </span><span class="cov0" title="0">{
                                fmt.Printf("Next actionable task:\n\n")
                                fmt.Printf("* %s (ID: %s)\n", task.Title, task.ID)
                                if task.Description != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("  %s\n", task.Description)
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("  State: %s | Complexity: %d\n", task.State, task.Complexity)
                                if task.Depth &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("  Depth: %d", task.Depth)
                                        if task.ParentID != nil </span><span class="cov0" title="0">{
                                                fmt.Printf(" | Parent: %s", *task.ParentID)
                                        }</span>
                                        <span class="cov0" title="0">fmt.Println()</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        }
                }

                // If we reach here, check for specific scenarios
                <span class="cov0" title="0">if len(pendingTasks) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("No actionable tasks found: All pending tasks have unmet dependencies (possible deadlock scenario)")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("No actionable tasks found: No pending or in-progress tasks available")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

// ReadyAction shows tasks that are ready to work on (no blockers)
func ReadyAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Finding ready tasks", zap.String("projectID", projectID.String()))

                // Get all tasks in the project
                allTasks, err := appCtx.ProjectManager.ListTasksForProject(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get project tasks", zap.Error(err))
                        return fmt.Errorf("failed to get project tasks: %w", err)
                }</span>

                // Create a map for quick task lookup
                <span class="cov0" title="0">taskMap := make(map[uuid.UUID]*types.Task)
                for _, task := range allTasks </span><span class="cov0" title="0">{
                        taskMap[task.ID] = task
                }</span>

                // Find ready tasks (pending/in-progress with no blockers)
                <span class="cov0" title="0">var readyTasks []*types.Task
                for _, task := range allTasks </span><span class="cov0" title="0">{
                        if task.State == types.TaskStatePending || task.State == types.TaskStateInProgress </span><span class="cov0" title="0">{
                                if isTaskReady(task, taskMap) </span><span class="cov0" title="0">{
                                        readyTasks = append(readyTasks, task)
                                }</span>
                        }
                }

                <span class="cov0" title="0">appCtx.Logger.Info("Ready tasks found", zap.Int("count", len(readyTasks)))

                if len(readyTasks) == 0 </span><span class="cov0" title="0">{
                        if c.Bool("json") </span><span class="cov0" title="0">{
                                fmt.Println("[]")
                                return nil
                        }</span>
                        <span class="cov0" title="0">fmt.Println("No ready tasks found. All tasks are either completed, blocked, or cancelled.")
                        return nil</span>
                }

                // Apply limit if specified
                <span class="cov0" title="0">limit := c.Int("limit")
                if limit &gt; 0 &amp;&amp; len(readyTasks) &gt; limit </span><span class="cov0" title="0">{
                        readyTasks = readyTasks[:limit]
                }</span>

                // Check if JSON output is requested
                <span class="cov0" title="0">if c.Bool("json") </span><span class="cov0" title="0">{
                        return outputTasksAsJSON(readyTasks)
                }</span>

                // Show project context indicator
                <span class="cov0" title="0">shared.ShowProjectContextWithSeparator(c, appCtx)

                if limit &gt; 0 &amp;&amp; len(readyTasks) == limit </span><span class="cov0" title="0">{
                        fmt.Printf("Ready work (showing %d of %d tasks with no blockers):\n\n", limit, len(readyTasks))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Ready work (%d tasks with no blockers):\n\n", len(readyTasks))
                }</span>

                <span class="cov0" title="0">for i, task := range readyTasks </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s (ID: %s)\n", i+1, task.Title, task.ID)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   %s\n", task.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("   State: %s | Complexity: %d\n", task.State, task.Complexity)
                        if task.Depth &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("   Depth: %d", task.Depth)
                                if task.ParentID != nil </span><span class="cov0" title="0">{
                                        fmt.Printf(" | Parent: %s", *task.ParentID)
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

// BlockedAction shows tasks that are blocked by dependencies
func BlockedAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Finding blocked tasks", zap.String("projectID", projectID.String()))

                // Get all tasks in the project
                allTasks, err := appCtx.ProjectManager.ListTasksForProject(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get project tasks", zap.Error(err))
                        return fmt.Errorf("failed to get project tasks: %w", err)
                }</span>

                // Create a map for quick task lookup
                <span class="cov0" title="0">taskMap := make(map[uuid.UUID]*types.Task)
                for _, task := range allTasks </span><span class="cov0" title="0">{
                        taskMap[task.ID] = task
                }</span>

                // Find blocked tasks (pending/in-progress with unmet dependencies)
                <span class="cov0" title="0">var blockedTasks []*types.Task
                for _, task := range allTasks </span><span class="cov0" title="0">{
                        if task.State == types.TaskStatePending || task.State == types.TaskStateInProgress </span><span class="cov0" title="0">{
                                if !isTaskReady(task, taskMap) &amp;&amp; len(task.Dependencies) &gt; 0 </span><span class="cov0" title="0">{
                                        blockedTasks = append(blockedTasks, task)
                                }</span>
                        }
                }

                <span class="cov0" title="0">appCtx.Logger.Info("Blocked tasks found", zap.Int("count", len(blockedTasks)))

                // Show project context indicator
                shared.ShowProjectContextWithSeparator(c, appCtx)

                if len(blockedTasks) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No blocked tasks found. All tasks are either ready, completed, or have no dependencies.")
                        return nil
                }</span>

                // Apply limit if specified
                <span class="cov0" title="0">limit := c.Int("limit")
                if limit &gt; 0 &amp;&amp; len(blockedTasks) &gt; limit </span><span class="cov0" title="0">{
                        fmt.Printf("Blocked tasks (showing %d of %d):\n\n", limit, len(blockedTasks))
                        blockedTasks = blockedTasks[:limit]
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Blocked tasks (%d):\n\n", len(blockedTasks))
                }</span>

                <span class="cov0" title="0">for i, task := range blockedTasks </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s (ID: %s)\n", i+1, task.Title, task.ID)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   %s\n", task.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("   State: %s | Complexity: %d\n", task.State, task.Complexity)
                        
                        // Show blocking dependencies
                        fmt.Printf("   Blocked by %d dependencies:\n", len(task.Dependencies))
                        for _, depID := range task.Dependencies </span><span class="cov0" title="0">{
                                if depTask, exists := taskMap[depID]; exists </span><span class="cov0" title="0">{
                                        fmt.Printf("     -&gt; %s (ID: %s) - %s\n", depTask.Title, depTask.ID, depTask.State)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("     -&gt; Unknown task (ID: %s)\n", depID)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

// BreakdownAction finds tasks that need breakdown based on complexity threshold
func BreakdownAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // TODO: Get complexity threshold from config (default: 8)
                <span class="cov0" title="0">complexityThreshold := c.Int("threshold")
                if complexityThreshold == 0 </span><span class="cov0" title="0">{
                        complexityThreshold = 8 // Default from original pkg/tools/project
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Finding tasks needing breakdown", 
                        zap.String("projectID", projectID.String()),
                        zap.Int("threshold", complexityThreshold))

                // Get all tasks in the project
                allTasks, err := appCtx.ProjectManager.ListTasksForProject(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get project tasks", zap.Error(err))
                        return fmt.Errorf("failed to get project tasks: %w", err)
                }</span>

                // Find tasks with complexity &gt;= threshold that have no children
                <span class="cov0" title="0">var needsBreakdown []*types.Task
                for _, task := range allTasks </span><span class="cov0" title="0">{
                        if task.Complexity &gt;= complexityThreshold </span><span class="cov0" title="0">{
                                // Check if task has children by looking for tasks with this task as parent
                                hasChildren := false
                                for _, otherTask := range allTasks </span><span class="cov0" title="0">{
                                        if otherTask.ParentID != nil &amp;&amp; *otherTask.ParentID == task.ID </span><span class="cov0" title="0">{
                                                hasChildren = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !hasChildren </span><span class="cov0" title="0">{
                                        needsBreakdown = append(needsBreakdown, task)
                                }</span>
                        }
                }

                <span class="cov0" title="0">appCtx.Logger.Info("Tasks needing breakdown found", zap.Int("count", len(needsBreakdown)))

                if len(needsBreakdown) == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("No tasks need breakdown (complexity &gt;= %d with no subtasks)\n", complexityThreshold)
                        return nil
                }</span>

                // Apply limit if specified
                <span class="cov0" title="0">limit := c.Int("limit")
                if limit &gt; 0 &amp;&amp; len(needsBreakdown) &gt; limit </span><span class="cov0" title="0">{
                        fmt.Printf("Tasks needing breakdown (showing %d of %d with complexity &gt;= %d):\n\n", 
                                limit, len(needsBreakdown), complexityThreshold)
                        needsBreakdown = needsBreakdown[:limit]
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Tasks needing breakdown (%d tasks with complexity &gt;= %d):\n\n", 
                                len(needsBreakdown), complexityThreshold)
                }</span>

                <span class="cov0" title="0">for i, task := range needsBreakdown </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s (ID: %s)\n", i+1, task.Title, task.ID)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   %s\n", task.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("   State: %s | Complexity: %d (&gt;= %d threshold)\n", 
                                task.State, task.Complexity, complexityThreshold)
                        if task.Depth &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("   Depth: %d", task.Depth)
                                if task.ParentID != nil </span><span class="cov0" title="0">{
                                        fmt.Printf(" | Parent: %s", *task.ParentID)
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}</pre>
		
		<pre class="file" id="file11" style="display: none">package task

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "github.com/denkhaus/knot/internal/shared"

        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// bulk.go contains bulk operations on tasks
// - bulk-update: update multiple tasks at once
// - duplicate: duplicate tasks
// - state filtering and bulk operations

// TODO: Implement bulk operations
// REFERENCE: pkg/tools/project/main.go line 133 (bulkUpdateTasksTool)
// REFERENCE: pkg/tools/project/main.go line 134 (duplicateTaskTool)

// BulkUpdateAction updates multiple tasks simultaneously
func BulkUpdateAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDsStr := c.String("task-ids")
                if taskIDsStr == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("task-ids are required")
                }</span>

                // Parse comma-separated task IDs
                <span class="cov0" title="0">taskIDStrings := strings.Split(taskIDsStr, ",")
                var taskIDs []uuid.UUID
                for _, idStr := range taskIDStrings </span><span class="cov0" title="0">{
                        idStr = strings.TrimSpace(idStr)
                        taskID, err := uuid.Parse(idStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid task ID '%s': %w", idStr, err)
                        }</span>
                        <span class="cov0" title="0">taskIDs = append(taskIDs, taskID)</span>
                }

                <span class="cov0" title="0">if len(taskIDs) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no valid task IDs provided")
                }</span>

                // Build updates struct
                <span class="cov0" title="0">var updates types.TaskUpdates

                if stateStr := c.String("state"); stateStr != "" </span><span class="cov0" title="0">{
                        state := types.TaskState(stateStr)
                        updates.State = &amp;state
                }</span>

                <span class="cov0" title="0">if complexity := c.Int("complexity"); complexity &gt; 0 </span><span class="cov0" title="0">{
                        updates.Complexity = &amp;complexity
                }</span>

                <span class="cov0" title="0">if updates.State == nil &amp;&amp; updates.Complexity == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("at least one field (state or complexity) must be specified")
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Bulk updating tasks",
                        zap.Int("taskCount", len(taskIDs)),
                        zap.Any("updates", updates))

                err := appCtx.ProjectManager.BulkUpdateTasks(context.Background(), taskIDs, updates)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to bulk update tasks", zap.Error(err))
                        return fmt.Errorf("failed to bulk update tasks: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Successfully updated %d tasks\n", len(taskIDs))
                if updates.State != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  State: %s\n", *updates.State)
                }</span>
                <span class="cov0" title="0">if updates.Complexity != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  Complexity: %d\n", *updates.Complexity)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

// DuplicateAction creates a copy of a task
func DuplicateAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("task-id")
                if taskIDStr == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("task-id is required")
                }</span>

                <span class="cov0" title="0">taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid task ID: %w", err)
                }</span>

                <span class="cov0" title="0">projectIDStr := c.String("target-project-id")
                if projectIDStr == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("target-project-id is required")
                }</span>

                <span class="cov0" title="0">targetProjectID, err := uuid.Parse(projectIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid target project ID: %w", err)
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Duplicating task",
                        zap.String("taskID", taskID.String()),
                        zap.String("targetProjectID", targetProjectID.String()))

                duplicatedTask, err := appCtx.ProjectManager.DuplicateTask(context.Background(), taskID, targetProjectID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to duplicate task", zap.Error(err))
                        return fmt.Errorf("failed to duplicate task: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Task duplicated successfully:\n")
                fmt.Printf("  Original: %s\n", taskID)
                fmt.Printf("  New: %s (ID: %s)\n", duplicatedTask.Title, duplicatedTask.ID)
                fmt.Printf("  Target Project: %s\n", targetProjectID)
                fmt.Printf("  State: %s (reset to pending)\n", duplicatedTask.State)
                fmt.Printf("  Complexity: %d\n", duplicatedTask.Complexity)

                return nil</span>
        }
}

// ListByStateAction lists tasks filtered by state
func ListByStateAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">stateStr := c.String("state")
                if stateStr == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("state is required")
                }</span>

                <span class="cov0" title="0">state := types.TaskState(stateStr)

                appCtx.Logger.Info("Listing tasks by state",
                        zap.String("projectID", projectID.String()),
                        zap.String("state", stateStr))

                tasks, err := appCtx.ProjectManager.ListTasksByState(context.Background(), projectID, state)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to list tasks by state", zap.Error(err))
                        return fmt.Errorf("failed to list tasks by state: %w", err)
                }</span>

                <span class="cov0" title="0">if len(tasks) == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("No tasks found with state '%s' in project %s\n", state, projectID)
                        return nil
                }</span>

                // Check if JSON output is requested
                <span class="cov0" title="0">if c.Bool("json") </span><span class="cov0" title="0">{
                        return outputTasksAsJSON(tasks)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Tasks with state '%s' (%d found):\n\n", state, len(tasks))
                for i, task := range tasks </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s (ID: %s)\n", i+1, task.Title, task.ID)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   %s\n", task.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("   Complexity: %d | Depth: %d\n", task.Complexity, task.Depth)
                        if task.ParentID != nil </span><span class="cov0" title="0">{
                                fmt.Printf("   Parent: %s\n", *task.ParentID)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

// BulkCreateAction creates multiple tasks from JSON input
func BulkCreateAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">inputFile := c.String("file")
                if inputFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("file is required")
                }</span>

                // Read input file
                <span class="cov0" title="0">data, err := os.ReadFile(inputFile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read file: %w", err)
                }</span>

                // Parse JSON input
                <span class="cov0" title="0">var taskInputs []struct {
                        Title       string  `json:"title"`
                        Description string  `json:"description"`
                        Complexity  int     `json:"complexity"`
                        ParentID    *string `json:"parent_id,omitempty"`
                }

                if err := json.Unmarshal(data, &amp;taskInputs); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse JSON: %w", err)
                }</span>

                <span class="cov0" title="0">if len(taskInputs) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no tasks found in input file")
                }</span>

                <span class="cov0" title="0">actor := c.String("actor")
                if actor == "" </span><span class="cov0" title="0">{
                        actor = os.Getenv("USER")
                        if actor == "" </span><span class="cov0" title="0">{
                                actor = "unknown"
                        }</span>
                }

                <span class="cov0" title="0">appCtx.Logger.Info("Bulk creating tasks",
                        zap.Int("taskCount", len(taskInputs)),
                        zap.String("projectID", projectID.String()),
                        zap.String("actor", actor))

                var createdTasks []types.Task
                for i, input := range taskInputs </span><span class="cov0" title="0">{
                        // Validate input
                        if input.Title == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("task %d: title is required", i+1)
                        }</span>
                        <span class="cov0" title="0">if input.Complexity &lt;= 0 </span><span class="cov0" title="0">{
                                input.Complexity = 5 // Default complexity
                        }</span>

                        <span class="cov0" title="0">var parentID *uuid.UUID
                        if input.ParentID != nil &amp;&amp; *input.ParentID != "" </span><span class="cov0" title="0">{
                                parsed, err := uuid.Parse(*input.ParentID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("task %d: invalid parent ID '%s': %w", i+1, *input.ParentID, err)
                                }</span>
                                <span class="cov0" title="0">parentID = &amp;parsed</span>
                        }

                        // Create task
                        <span class="cov0" title="0">task, err := appCtx.ProjectManager.CreateTask(
                                context.Background(),
                                projectID,
                                parentID,
                                input.Title,
                                input.Description,
                                input.Complexity,
                                types.TaskPriorityMedium,
                                actor,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                appCtx.Logger.Error("Failed to create task", zap.Error(err), zap.Int("taskIndex", i))
                                return fmt.Errorf("failed to create task %d ('%s'): %w", i+1, input.Title, err)
                        }</span>

                        <span class="cov0" title="0">createdTasks = append(createdTasks, *task)</span>
                }

                <span class="cov0" title="0">fmt.Printf("Successfully created %d tasks:\n", len(createdTasks))
                for i, task := range createdTasks </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s (ID: %s)\n", i+1, task.Title, task.ID)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   %s\n", task.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("   Complexity: %d | State: %s\n", task.Complexity, task.State)</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Created by: %s\n", actor)

                return nil</span>
        }
}

// BulkDeleteAction deletes multiple tasks with safety checks
func BulkDeleteAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDsStr := c.String("task-ids")
                if taskIDsStr == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("task-ids are required")
                }</span>

                // Parse comma-separated task IDs
                <span class="cov0" title="0">taskIDStrings := strings.Split(taskIDsStr, ",")
                var taskIDs []uuid.UUID
                for _, idStr := range taskIDStrings </span><span class="cov0" title="0">{
                        idStr = strings.TrimSpace(idStr)
                        taskID, err := uuid.Parse(idStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid task ID '%s': %w", idStr, err)
                        }</span>
                        <span class="cov0" title="0">taskIDs = append(taskIDs, taskID)</span>
                }

                <span class="cov0" title="0">if len(taskIDs) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no valid task IDs provided")
                }</span>

                <span class="cov0" title="0">dryRun := c.Bool("dry-run")
                force := c.Bool("force")

                appCtx.Logger.Info("Bulk deleting tasks",
                        zap.Int("taskCount", len(taskIDs)),
                        zap.Bool("dryRun", dryRun),
                        zap.Bool("force", force))

                // Get task details for confirmation
                var tasksToDelete []types.Task
                for _, taskID := range taskIDs </span><span class="cov0" title="0">{
                        task, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                        if err != nil </span><span class="cov0" title="0">{
                                appCtx.Logger.Error("Failed to get task", zap.Error(err), zap.String("taskID", taskID.String()))
                                return fmt.Errorf("failed to get task %s: %w", taskID, err)
                        }</span>
                        <span class="cov0" title="0">tasksToDelete = append(tasksToDelete, *task)</span>
                }

                // Show what will be deleted
                <span class="cov0" title="0">fmt.Printf("Tasks to be deleted (%d):\n", len(tasksToDelete))
                for i, task := range tasksToDelete </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s (ID: %s)\n", i+1, task.Title, task.ID)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   %s\n", task.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("   State: %s | Complexity: %d\n", task.State, task.Complexity)</span>
                }

                <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                        fmt.Println("\nDry run mode - no tasks were actually deleted.")
                        return nil
                }</span>

                // Confirmation prompt (unless force flag is used)
                <span class="cov0" title="0">if !force </span><span class="cov0" title="0">{
                        fmt.Printf("\nAre you sure you want to delete these %d tasks? (y/N): ", len(tasksToDelete))
                        var response string
                        _, _ = fmt.Scanln(&amp;response)
                        if response != "y" &amp;&amp; response != "Y" &amp;&amp; response != "yes" &amp;&amp; response != "YES" </span><span class="cov0" title="0">{
                                fmt.Println("Deletion cancelled.")
                                return nil
                        }</span>
                }

                // Get actor for deletion
                <span class="cov0" title="0">actor := c.String("actor")
                if actor == "" </span><span class="cov0" title="0">{
                        actor = os.Getenv("USER")
                        if actor == "" </span><span class="cov0" title="0">{
                                actor = "unknown"
                        }</span>
                }

                // Delete tasks
                <span class="cov0" title="0">var deletedCount int
                for _, taskID := range taskIDs </span><span class="cov0" title="0">{
                        err := appCtx.ProjectManager.DeleteTask(context.Background(), taskID, actor)
                        if err != nil </span><span class="cov0" title="0">{
                                appCtx.Logger.Error("Failed to delete task", zap.Error(err), zap.String("taskID", taskID.String()))
                                fmt.Printf("Failed to delete task %s: %v\n", taskID, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">deletedCount++</span>
                }

                <span class="cov0" title="0">fmt.Printf("Successfully deleted %d out of %d tasks\n", deletedCount, len(taskIDs))
                if deletedCount &lt; len(taskIDs) </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: %d tasks could not be deleted (see errors above)\n", len(taskIDs)-deletedCount)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

// BulkCommands returns bulk operation CLI commands
func BulkCommands(appCtx *shared.AppContext) []*cli.Command <span class="cov0" title="0">{
        return []*cli.Command{
                {
                        Name:   "bulk-update",
                        Usage:  "Update multiple tasks simultaneously",
                        Action: BulkUpdateAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-ids",
                                        Usage:    "Comma-separated list of task IDs",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:  "state",
                                        Usage: "New state (pending, in-progress, completed, blocked, cancelled)",
                                },
                                &amp;cli.IntFlag{
                                        Name:  "complexity",
                                        Usage: "New complexity (1-10)",
                                },
                        },
                },
                {
                        Name:   "bulk-create",
                        Usage:  "Create multiple tasks from JSON file",
                        Action: BulkCreateAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "file",
                                        Aliases:  []string{"f"},
                                        Usage:    "JSON file containing task definitions",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "bulk-delete",
                        Usage:  "Delete multiple tasks with safety checks",
                        Action: BulkDeleteAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-ids",
                                        Usage:    "Comma-separated list of task IDs",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "dry-run",
                                        Usage: "Show what would be deleted without actually deleting",
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "force",
                                        Usage: "Skip confirmation prompt",
                                },
                        },
                },
                {
                        Name:   "duplicate",
                        Usage:  "Duplicate a task to another project",
                        Action: DuplicateAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-id",
                                        Usage:    "Task ID to duplicate",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:     "target-project-id",
                                        Usage:    "Target project ID",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "list-by-state",
                        Usage:  "List tasks filtered by state",
                        Action: ListByStateAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "state",
                                        Aliases:  []string{"s"},
                                        Usage:    "Task state (pending, in-progress, completed, blocked, cancelled)",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:    "json",
                                        Aliases: []string{"j"},
                                        Usage:   "Output in JSON format",
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package task

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "sort"
        "strings"

        "github.com/denkhaus/knot/internal/shared"

        "github.com/denkhaus/knot/internal/errors"
        "github.com/denkhaus/knot/internal/types"
        "github.com/denkhaus/knot/internal/validation"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// validateProjectID validates and returns the project ID from the CLI context

// Commands returns all task-related CLI commands
func Commands(appCtx *shared.AppContext) []*cli.Command <span class="cov0" title="0">{
        // Basic task commands
        basicCommands := []*cli.Command{
                {
                        Name:   "create",
                        Usage:  "Create a new task",
                        Action: createAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "title",
                                        Aliases:  []string{"t"},
                                        Usage:    "Task title",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:    "description",
                                        Aliases: []string{"d"},
                                        Usage:   "Task description",
                                },
                                &amp;cli.StringFlag{
                                        Name:  "parent-id",
                                        Usage: "Parent task ID (for subtasks)",
                                },
                                &amp;cli.IntFlag{
                                        Name:    "complexity",
                                        Aliases: []string{"c"},
                                        Usage:   "Task complexity (1-10)",
                                        Value:   5,
                                        EnvVars: []string{"KNOT_DEFAULT_COMPLEXITY"},
                                },
                                &amp;cli.StringFlag{
                                        Name:    "priority",
                                        Aliases: []string{"p"},
                                        Usage:   "Task priority (low, medium, high)",
                                        Value:   "medium",
                                },
                        },
                },
                {
                        Name:   "list",
                        Usage:  "List tasks with advanced filtering options",
                        Action: listAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.BoolFlag{
                                        Name:    "json",
                                        Aliases: []string{"j"},
                                        Usage:   "Output in JSON format",
                                },
                                &amp;cli.StringFlag{
                                        Name:    "state",
                                        Aliases: []string{"s"},
                                        Usage:   "Filter by task state (pending, in-progress, completed, blocked, cancelled)",
                                },
                                &amp;cli.StringFlag{
                                        Name:    "priority",
                                        Aliases: []string{"p"},
                                        Usage:   "Filter by task priority (low, medium, high)",
                                },
                                &amp;cli.IntFlag{
                                        Name:  "complexity-min",
                                        Usage: "Filter by minimum complexity (1-10)",
                                },
                                &amp;cli.IntFlag{
                                        Name:  "complexity-max",
                                        Usage: "Filter by maximum complexity (1-10)",
                                },
                                &amp;cli.IntFlag{
                                        Name:  "complexity",
                                        Usage: "Filter by exact complexity (1-10)",
                                },
                                &amp;cli.StringFlag{
                                        Name:    "search",
                                        Aliases: []string{"q"},
                                        Usage:   "Search in task titles and descriptions",
                                },
                                &amp;cli.IntFlag{
                                        Name:  "depth-max",
                                        Usage: "Filter by maximum depth in hierarchy",
                                },
                                &amp;cli.IntFlag{
                                        Name:    "limit",
                                        Aliases: []string{"l"},
                                        Usage:   "Maximum number of tasks to show",
                                },
                                &amp;cli.StringFlag{
                                        Name:  "sort",
                                        Usage: "Sort by field (title, complexity, state, priority, created, depth)",
                                        Value: "created",
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "reverse",
                                        Usage: "Reverse sort order",
                                },
                        },
                },
                {
                        Name:   "update-state",
                        Usage:  "Update task state",
                        Action: updateStateAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "id",
                                        Usage:    "Task ID",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:     "state",
                                        Aliases:  []string{"s"},
                                        Usage:    "New state (pending, in-progress, completed, blocked, cancelled)",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "update-title",
                        Usage:  "Update task title",
                        Action: updateTitleAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "id",
                                        Usage:    "Task ID",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:     "title",
                                        Aliases:  []string{"t"},
                                        Usage:    "New task title",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "update-description",
                        Usage:  "Update task description",
                        Action: updateDescriptionAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "id",
                                        Usage:    "Task ID",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:     "description",
                                        Aliases:  []string{"d"},
                                        Usage:    "New task description",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "update-priority",
                        Usage:  "Update task priority",
                        Action: updatePriorityAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "id",
                                        Usage:    "Task ID",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:     "priority",
                                        Aliases:  []string{"p"},
                                        Usage:    "New task priority (low, medium, high)",
                                        Required: true,
                                },
                        },
                },
        }

        // Hierarchy navigation commands
        hierarchyCommands := HierarchyCommands(appCtx)

        // Task deletion commands
        deletionCommands := DeletionCommands(appCtx)

        // Bulk operation commands
        bulkCommands := BulkCommands(appCtx)

        // Combine all commands
        allCommands := make([]*cli.Command, 0, len(basicCommands)+len(hierarchyCommands)+len(deletionCommands)+len(bulkCommands))
        allCommands = append(allCommands, basicCommands...)
        allCommands = append(allCommands, hierarchyCommands...)
        allCommands = append(allCommands, deletionCommands...)
        allCommands = append(allCommands, bulkCommands...)

        return allCommands
}</span>

func createAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">title := c.String("title")
                description := c.String("description")
                complexity := c.Int("complexity")
                priority := c.String("priority")
                actor := c.String("actor")

                // Create input validator
                validator := validation.NewInputValidator()

                // Validate inputs
                if err := validator.ValidateTaskTitle(title); err != nil </span><span class="cov8" title="1">{
                        return errors.NewValidationError("invalid task title", err)
                }</span>

                <span class="cov8" title="1">if err := validator.ValidateTaskDescription(description); err != nil </span><span class="cov8" title="1">{
                        return errors.NewValidationError("invalid task description", err)
                }</span>

                <span class="cov8" title="1">if err := validator.ValidateComplexity(complexity); err != nil </span><span class="cov8" title="1">{
                        return errors.NewValidationError("invalid complexity", err)
                }</span>

                // Validate priority
                <span class="cov8" title="1">if err := validator.ValidateTaskPriority(priority); err != nil </span><span class="cov0" title="0">{
                        return errors.NewValidationError("invalid priority", err)
                }</span>

                // Default to $USER if actor is not provided
                <span class="cov8" title="1">if actor == "" </span><span class="cov0" title="0">{
                        actor = os.Getenv("USER")
                        if actor == "" </span><span class="cov0" title="0">{
                                actor = "unknown"
                        }</span>
                }

                // Validate complexity
                <span class="cov8" title="1">if err := errors.ValidateComplexity(complexity); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">var parentID *uuid.UUID
                if parentIDStr := c.String("parent-id"); parentIDStr != "" </span><span class="cov0" title="0">{
                        parsed, err := uuid.Parse(parentIDStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.InvalidUUIDError("parent-id", parentIDStr)
                        }</span>
                        <span class="cov0" title="0">parentID = &amp;parsed</span>
                }

                <span class="cov8" title="1">appCtx.Logger.Info("Creating task",
                        zap.String("title", title),
                        zap.String("projectID", projectID.String()),
                        zap.Int("complexity", complexity),
                        zap.String("priority", priority),
                        zap.String("actor", actor))

                task, err := appCtx.ProjectManager.CreateTask(context.Background(), projectID, parentID, title, description, complexity, types.TaskPriority(priority), actor)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to create task", zap.Error(err))
                        return errors.WrapWithSuggestion(err, "creating task")
                }</span>

                <span class="cov8" title="1">appCtx.Logger.Info("Task created successfully", zap.String("taskID", task.ID.String()), zap.String("actor", actor))

                fmt.Printf("Created task: %s (ID: %s)\n", task.Title, task.ID)
                fmt.Printf("  Created by: %s\n", actor)
                if task.Description != "" </span><span class="cov8" title="1">{
                        fmt.Printf("  Description: %s\n", task.Description)
                }</span>
                <span class="cov8" title="1">fmt.Printf("  Complexity: %d\n", task.Complexity)
                fmt.Printf("  Priority: %s\n", task.Priority)
                fmt.Printf("  State: %s\n", task.State)
                if parentID != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  Parent: %s\n", *parentID)
                }</span>

                // Show workflow reminder for task state management
                <span class="cov8" title="1">fmt.Printf("\nReminder: Set this task to 'in-progress' before starting work:\n")
                fmt.Printf("  knot task update-state --id %s --state in-progress\n", task.ID)

                // Show breakdown suggestion for high complexity tasks
                if complexity &gt;= 8 </span><span class="cov0" title="0">{
                        fmt.Printf("\nNote: This task has high complexity (%d &gt;= 8 threshold).\n", complexity)
                        fmt.Printf("Consider breaking it down into smaller subtasks:\n")
                        fmt.Printf("  knot task create --parent-id %s --title \"Subtask 1\"\n", task.ID)
                        fmt.Printf("  knot breakdown  # to see all tasks needing breakdown\n")
                }</span>

                <span class="cov8" title="1">return nil</span>
        }
}

func listAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">appCtx.Logger.Info("Listing tasks", zap.String("projectID", projectID.String()))

                tasks, err := appCtx.ProjectManager.ListTasksForProject(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to list tasks", zap.Error(err))
                        return errors.WrapWithSuggestion(err, "listing tasks")
                }</span>

                // Apply filters
                <span class="cov8" title="1">filteredTasks := applyTaskFilters(tasks, c)

                // Apply sorting
                sortedTasks := applyTaskSorting(filteredTasks, c)

                // Apply limit
                finalTasks := applyTaskLimit(sortedTasks, c)

                appCtx.Logger.Info("Tasks filtered and sorted",
                        zap.Int("originalCount", len(tasks)),
                        zap.Int("filteredCount", len(finalTasks)))

                if len(finalTasks) == 0 </span><span class="cov8" title="1">{
                        fmt.Printf("No tasks found matching the specified criteria.\n")
                        return nil
                }</span>

                // Check if JSON output is requested
                <span class="cov8" title="1">if c.Bool("json") </span><span class="cov0" title="0">{
                        return outputTasksAsJSON(finalTasks)
                }</span>

                // Show project context indicator
                <span class="cov8" title="1">shared.ShowProjectContextWithSeparator(c, appCtx)

                // Show filter summary if filters were applied
                if hasFiltersApplied(c) </span><span class="cov8" title="1">{
                        fmt.Printf("Found %d task(s) matching criteria (out of %d total):\n\n", len(finalTasks), len(tasks))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Found %d task(s):\n\n", len(finalTasks))
                }</span>

                <span class="cov8" title="1">for _, task := range finalTasks </span><span class="cov8" title="1">{
                        indent := ""
                        for i := 0; i &lt; task.Depth; i++ </span><span class="cov0" title="0">{
                                indent += "  "
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("%s* %s (ID: %s)\n", indent, task.Title, task.ID)
                        if task.Description != "" </span><span class="cov8" title="1">{
                                fmt.Printf("%s  %s\n", indent, task.Description)
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("%s  State: %s | Priority: %s | Complexity: %d | Depth: %d\n", indent, task.State, task.Priority, task.Complexity, task.Depth)
                        fmt.Println()</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
}

func updateStateAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                taskIDStr := c.String("id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.InvalidUUIDError("task-id", taskIDStr)
                }</span>

                <span class="cov8" title="1">stateStr := c.String("state")
                actor := c.String("actor")

                // Default to $USER if actor is not provided
                if actor == "" </span><span class="cov0" title="0">{
                        actor = os.Getenv("USER")
                        if actor == "" </span><span class="cov0" title="0">{
                                actor = "unknown"
                        }</span>
                }

                // Basic state validation
                <span class="cov8" title="1">if err := errors.ValidateTaskState(stateStr); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">newState := types.TaskState(stateStr)

                appCtx.Logger.Info("Updating task state",
                        zap.String("taskID", taskID.String()),
                        zap.String("newState", stateStr),
                        zap.String("actor", actor))

                // Get current task to preserve other fields
                task, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov8" title="1">{
                        appCtx.Logger.Error("Failed to get task", zap.Error(err))
                        return errors.TaskNotFoundError(taskID)
                }</span>

                // Validate state transition
                <span class="cov8" title="1">validator := validation.NewStateValidator()
                if err := validator.ValidateTransition(task.State, newState, task); err != nil </span><span class="cov0" title="0">{
                        // EnhancedError already contains user-friendly formatting
                        // No need to log this as it's a user input validation error
                        return err
                }</span>

                // Update task state
                <span class="cov8" title="1">updatedTask, err := appCtx.ProjectManager.UpdateTaskState(context.Background(), taskID, newState, actor)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to update task state", zap.Error(err))
                        return errors.WrapWithSuggestion(err, "updating task state")
                }</span>

                <span class="cov8" title="1">appCtx.Logger.Info("Task state updated successfully", zap.String("actor", actor))
                fmt.Printf("Updated task state: %s -&gt; %s\n", task.State, updatedTask.State)
                fmt.Printf("  Updated by: %s\n", actor)
                return nil</span>
        }
}

// outputTasksAsJSON outputs tasks in JSON format
func outputTasksAsJSON(tasks []*types.Task) error <span class="cov0" title="0">{
        jsonData, err := json.MarshalIndent(tasks, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal tasks to JSON: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(jsonData))
        return nil</span>
}

// outputSingleTaskAsJSON outputs a single task in JSON format
// Currently unused but kept for potential future use
// func outputSingleTaskAsJSON(task *types.Task) error {
//         jsonData, err := json.MarshalIndent(task, "", "  ")
//         if err != nil {
//                 return fmt.Errorf("failed to marshal task to JSON: %w", err)
//         }
//         fmt.Println(string(jsonData))
//         return nil
// }

func updateTitleAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov8" title="1">{
        return func(c *cli.Context) error </span><span class="cov8" title="1">{
                taskIDStr := c.String("id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.InvalidUUIDError("task-id", taskIDStr)
                }</span>

                <span class="cov8" title="1">newTitle := c.String("title")
                actor := c.String("actor")
                if newTitle == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("title cannot be empty")
                }</span>

                // Default to $USER if actor is not provided
                <span class="cov8" title="1">if actor == "" </span><span class="cov0" title="0">{
                        actor = os.Getenv("USER")
                        if actor == "" </span><span class="cov0" title="0">{
                                actor = "unknown"
                        }</span>
                }

                <span class="cov8" title="1">appCtx.Logger.Info("Updating task title",
                        zap.String("taskID", taskID.String()),
                        zap.String("newTitle", newTitle),
                        zap.String("actor", actor))

                // Get current task to check if it exists and get old title
                task, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get task", zap.Error(err))
                        return errors.TaskNotFoundError(taskID)
                }</span>

                <span class="cov8" title="1">oldTitle := task.Title

                // Update task title
                updatedTask, err := appCtx.ProjectManager.UpdateTaskTitle(context.Background(), taskID, newTitle, actor)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to update task title", zap.Error(err))
                        return errors.WrapWithSuggestion(err, "updating task title")
                }</span>

                <span class="cov8" title="1">appCtx.Logger.Info("Task title updated successfully", zap.String("actor", actor))
                fmt.Printf("Updated task title: \"%s\" -&gt; \"%s\"\n", oldTitle, updatedTask.Title)
                fmt.Printf("  Updated by: %s\n", actor)
                return nil</span>
        }
}

func updateDescriptionAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.InvalidUUIDError("task-id", taskIDStr)
                }</span>

                <span class="cov0" title="0">newDescription := c.String("description")
                actor := c.String("actor")

                // Default to $USER if actor is not provided
                if actor == "" </span><span class="cov0" title="0">{
                        actor = os.Getenv("USER")
                        if actor == "" </span><span class="cov0" title="0">{
                                actor = "unknown"
                        }</span>
                }

                <span class="cov0" title="0">appCtx.Logger.Info("Updating task description",
                        zap.String("taskID", taskID.String()),
                        zap.String("newDescription", newDescription),
                        zap.String("actor", actor))

                // Get current task to check if it exists and get old description
                task, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get task", zap.Error(err))
                        return errors.TaskNotFoundError(taskID)
                }</span>

                <span class="cov0" title="0">oldDescription := task.Description

                // Update task description
                updatedTask, err := appCtx.ProjectManager.UpdateTaskDescription(context.Background(), taskID, newDescription, actor)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to update task description", zap.Error(err))
                        return errors.WrapWithSuggestion(err, "updating task description")
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Task description updated successfully", zap.String("actor", actor))
                if oldDescription == "" </span><span class="cov0" title="0">{
                        fmt.Printf("Updated task description: (empty) -&gt; \"%s\"\n", updatedTask.Description)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Updated task description: \"%s\" -&gt; \"%s\"\n", oldDescription, updatedTask.Description)
                }</span>
                <span class="cov0" title="0">fmt.Printf("  Updated by: %s\n", actor)
                return nil</span>
        }
}

func updatePriorityAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.InvalidUUIDError("task-id", taskIDStr)
                }</span>

                <span class="cov0" title="0">priority := c.String("priority")
                actor := c.String("actor")

                // Default to $USER if actor is not provided
                if actor == "" </span><span class="cov0" title="0">{
                        actor = os.Getenv("USER")
                        if actor == "" </span><span class="cov0" title="0">{
                                actor = "unknown"
                        }</span>
                }

                // Validate priority
                <span class="cov0" title="0">validator := validation.NewInputValidator()
                if err := validator.ValidateTaskPriority(priority); err != nil </span><span class="cov0" title="0">{
                        return errors.NewValidationError("invalid priority", err)
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Updating task priority",
                        zap.String("taskID", taskID.String()),
                        zap.String("newPriority", priority),
                        zap.String("actor", actor))

                // Get current task to check if it exists and get old priority
                task, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get task", zap.Error(err))
                        return errors.TaskNotFoundError(taskID)
                }</span>

                <span class="cov0" title="0">oldPriority := task.Priority

                // Update task priority using the service method
                updatedTask, err := appCtx.ProjectManager.UpdateTaskPriority(context.Background(), taskID, types.TaskPriority(priority), actor)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to update task priority", zap.Error(err))
                        return errors.WrapWithSuggestion(err, "updating task priority")
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Task priority updated successfully", zap.String("actor", actor))
                fmt.Printf("Updated task priority: \"%s\" -&gt; \"%s\"\n", oldPriority, updatedTask.Priority)
                fmt.Printf("  Updated by: %s\n", actor)
                return nil</span>
        }
}

// Helper functions for task filtering, sorting, and limiting

// applyTaskFilters applies all specified filters to the task list
func applyTaskFilters(tasks []*types.Task, c *cli.Context) []*types.Task <span class="cov8" title="1">{
        var filtered []*types.Task

        for _, task := range tasks </span><span class="cov8" title="1">{
                // State filter
                if state := c.String("state"); state != "" </span><span class="cov0" title="0">{
                        if string(task.State) != state </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Priority filter
                <span class="cov8" title="1">if priority := c.String("priority"); priority != "" </span><span class="cov0" title="0">{
                        if string(task.Priority) != priority </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Complexity filters
                <span class="cov8" title="1">if complexity := c.Int("complexity"); complexity &gt; 0 </span><span class="cov0" title="0">{
                        if task.Complexity != complexity </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">if complexityMin := c.Int("complexity-min"); complexityMin &gt; 0 </span><span class="cov0" title="0">{
                        if task.Complexity &lt; complexityMin </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">if complexityMax := c.Int("complexity-max"); complexityMax &gt; 0 </span><span class="cov0" title="0">{
                        if task.Complexity &gt; complexityMax </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Depth filter
                <span class="cov8" title="1">if depthMax := c.Int("depth-max"); depthMax &gt;= 0 </span><span class="cov8" title="1">{
                        if task.Depth &gt; depthMax </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Search filter (case-insensitive search in title and description)
                <span class="cov8" title="1">if search := c.String("search"); search != "" </span><span class="cov0" title="0">{
                        searchLower := strings.ToLower(search)
                        titleMatch := strings.Contains(strings.ToLower(task.Title), searchLower)
                        descMatch := strings.Contains(strings.ToLower(task.Description), searchLower)
                        if !titleMatch &amp;&amp; !descMatch </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // If we get here, the task passed all filters
                <span class="cov8" title="1">filtered = append(filtered, task)</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

// applyTaskSorting sorts the task list based on the specified criteria
func applyTaskSorting(tasks []*types.Task, c *cli.Context) []*types.Task <span class="cov8" title="1">{
        sortField := c.String("sort")
        reverse := c.Bool("reverse")

        // Make a copy to avoid modifying the original slice
        sorted := make([]*types.Task, len(tasks))
        copy(sorted, tasks)

        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                var less bool

                switch sortField </span>{
                case "title":<span class="cov0" title="0">
                        less = strings.ToLower(sorted[i].Title) &lt; strings.ToLower(sorted[j].Title)</span>
                case "complexity":<span class="cov0" title="0">
                        less = sorted[i].Complexity &lt; sorted[j].Complexity</span>
                case "state":<span class="cov0" title="0">
                        less = string(sorted[i].State) &lt; string(sorted[j].State)</span>
                case "priority":<span class="cov0" title="0">
                        // Sort by priority: high -&gt; medium -&gt; low
                        priorityOrder := map[string]int{"high": 0, "medium": 1, "low": 2}
                        less = priorityOrder[string(sorted[i].Priority)] &lt; priorityOrder[string(sorted[j].Priority)]</span>
                case "depth":<span class="cov0" title="0">
                        less = sorted[i].Depth &lt; sorted[j].Depth</span>
                case "created":<span class="cov0" title="0">
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        // Default sort by creation time (using ID as proxy since tasks are created sequentially)
                        less = sorted[i].ID.String() &lt; sorted[j].ID.String()</span>
                }

                <span class="cov8" title="1">if reverse </span><span class="cov0" title="0">{
                        return !less
                }</span>
                <span class="cov8" title="1">return less</span>
        })

        <span class="cov8" title="1">return sorted</span>
}

// applyTaskLimit applies the limit to the task list
func applyTaskLimit(tasks []*types.Task, c *cli.Context) []*types.Task <span class="cov8" title="1">{
        limit := c.Int("limit")
        if limit &lt;= 0 || limit &gt;= len(tasks) </span><span class="cov8" title="1">{
                return tasks
        }</span>
        <span class="cov0" title="0">return tasks[:limit]</span>
}

// hasFiltersApplied checks if any filters were applied
func hasFiltersApplied(c *cli.Context) bool <span class="cov8" title="1">{
        return c.String("state") != "" ||
                c.String("priority") != "" ||
                c.Int("complexity") &gt; 0 ||
                c.Int("complexity-min") &gt; 0 ||
                c.Int("complexity-max") &gt; 0 ||
                c.Int("depth-max") &gt;= 0 ||
                c.String("search") != "" ||
                c.Int("limit") &gt; 0 ||
                c.String("sort") != "created" ||
                c.Bool("reverse")
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package task

import (
        "context"
        "fmt"
        "strings"

        "github.com/denkhaus/knot/internal/manager"
        "github.com/denkhaus/knot/internal/shared"

        "github.com/denkhaus/knot/internal/errors"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// DeletionCommands returns task deletion related CLI commands
func DeletionCommands(appCtx *shared.AppContext) []*cli.Command <span class="cov0" title="0">{
        return []*cli.Command{
                {
                        Name:   "delete",
                        Usage:  "Delete a single task with two-step confirmation (only if no children exist)",
                        Action: deleteAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "id",
                                        Usage:    "Task ID to delete",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "dry-run",
                                        Usage: "Show what would be deleted without actually deleting",
                                        Value: false,
                                },
                        },
                },
                {
                        Name:   "delete-subtree",
                        Usage:  "Delete a task and all its descendants recursively with two-step confirmation",
                        Action: deleteSubtreeAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "id",
                                        Usage:    "Root task ID to delete (with all children)",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "dry-run",
                                        Usage: "Show what would be deleted without actually deleting",
                                        Value: false,
                                },
                        },
                },
        }
}</span>

// deleteAction handles single task deletion with two-step confirmation
func deleteAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.InvalidUUIDError("task-id", taskIDStr)
                }</span>

                <span class="cov0" title="0">dryRun := c.Bool("dry-run")

                // Get task details
                task, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.TaskNotFoundError(taskID)
                }</span>

                // Check if task has children
                <span class="cov0" title="0">children, err := appCtx.ProjectManager.GetChildTasks(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.WrapWithSuggestion(err, "checking child tasks")
                }</span>

                <span class="cov0" title="0">if len(children) &gt; 0 </span><span class="cov0" title="0">{
                        return &amp;errors.EnhancedError{
                                Operation:   "deleting task",
                                Cause:       fmt.Errorf("task has %d child task(s)", len(children)),
                                Suggestion:  "Delete child tasks first, or use 'delete-subtree' to delete the entire hierarchy",
                                Example:     fmt.Sprintf("knot task delete-subtree --id %s", taskID),
                                HelpCommand: "knot task children --task-id " + taskID.String(),
                        }
                }</span>

                // Two-step deletion process
                <span class="cov0" title="0">if task.State == types.TaskStateDeletionPending </span><span class="cov0" title="0">{
                        // Second call - actually delete the task
                        if dryRun </span><span class="cov0" title="0">{
                                fmt.Printf("üîç DRY RUN: Task would be permanently deleted (no actual changes made)\n")
                                return nil
                        }</span>

                        // Show what will be deleted
                        <span class="cov0" title="0">fmt.Printf("üóëÔ∏è  Final deletion of task:\n")
                        fmt.Printf("  ‚Ä¢ %s (ID: %s)\n", task.Title, task.ID)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("    %s\n", task.Description)
                        }</span>

                        // Perform deletion
                        <span class="cov0" title="0">err = appCtx.ProjectManager.DeleteTask(context.Background(), taskID, appCtx.Actor)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;errors.EnhancedError{
                                        Operation:   "deleting task",
                                        Cause:       err,
                                        Suggestion:  "Check if the task still exists or if there are constraint violations",
                                        HelpCommand: "knot task get --help",
                                }
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("‚úÖ Task permanently deleted: %s\n", task.Title)
                        return nil</span>
                } else<span class="cov0" title="0"> {
                        // First call - mark for deletion
                        if dryRun </span><span class="cov0" title="0">{
                                fmt.Printf("üîç DRY RUN: Task would be marked for deletion (no actual changes made)\n")
                                return nil
                        }</span>

                        // Show what will be marked for deletion
                        <span class="cov0" title="0">fmt.Printf("üìã Task to be marked for deletion:\n")
                        fmt.Printf("  ‚Ä¢ %s (ID: %s)\n", task.Title, task.ID)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("    %s\n", task.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("    Current State: %s | Complexity: %d\n", task.State, task.Complexity)

                        // Check for dependencies
                        dependencies, err := appCtx.ProjectManager.GetTaskDependencies(context.Background(), taskID)
                        if err == nil &amp;&amp; len(dependencies) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("\n  This task depends on %d other task(s):\n", len(dependencies))
                                for _, dep := range dependencies </span><span class="cov0" title="0">{
                                        fmt.Printf("    ‚Ä¢ %s (ID: %s)\n", dep.Title, dep.ID)
                                }</span>
                        }

                        <span class="cov0" title="0">dependents, err := appCtx.ProjectManager.GetDependentTasks(context.Background(), taskID)
                        if err == nil &amp;&amp; len(dependents) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("\n  %d task(s) depend on this task:\n", len(dependents))
                                for _, dep := range dependents </span><span class="cov0" title="0">{
                                        fmt.Printf("    ‚Ä¢ %s (ID: %s)\n", dep.Title, dep.ID)
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("    These dependencies will be removed.\n")</span>
                        }

                        // Mark task for deletion
                        <span class="cov0" title="0">_, err = appCtx.ProjectManager.UpdateTask(context.Background(), task.ID, task.Title, task.Description, task.Complexity, types.TaskStateDeletionPending, appCtx.Actor)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;errors.EnhancedError{
                                        Operation:   "marking task for deletion",
                                        Cause:       err,
                                        Suggestion:  "Check if the task state transition is valid",
                                        HelpCommand: "knot task update-state --help",
                                }
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("\n‚ö†Ô∏è  Task marked for deletion. To confirm deletion, run the same command again:\n")
                        fmt.Printf("    knot task delete --id %s\n", taskID)
                        fmt.Printf("\nüí° To cancel deletion, change the task state:\n")
                        fmt.Printf("    knot task update-state --id %s --state pending\n", taskID)

                        return nil</span>
                }
        }
}

// deleteSubtreeAction handles recursive task deletion with two-step confirmation
func deleteSubtreeAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.InvalidUUIDError("task-id", taskIDStr)
                }</span>

                <span class="cov0" title="0">dryRun := c.Bool("dry-run")

                appCtx.Logger.Info("Processing task subtree deletion",
                        zap.String("taskID", taskID.String()),
                        zap.Bool("dryRun", dryRun))

                // Get task details
                task, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get task", zap.Error(err))
                        return errors.TaskNotFoundError(taskID)
                }</span>

                // Get all descendants for preview
                <span class="cov0" title="0">descendants, err := getTaskDescendants(appCtx.ProjectManager, taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get descendants", zap.Error(err))
                        return errors.WrapWithSuggestion(err, "getting task descendants")
                }</span>

                // Two-step deletion process for subtree
                <span class="cov0" title="0">if task.State == types.TaskStateDeletionPending </span><span class="cov0" title="0">{
                        // Second call - actually delete the subtree
                        if dryRun </span><span class="cov0" title="0">{
                                totalTasks := 1 + len(descendants)
                                fmt.Printf("üîç DRY RUN: Task subtree would be permanently deleted (%d tasks, no actual changes made)\n", totalTasks)
                                return nil
                        }</span>

                        // Show what will be deleted
                        <span class="cov0" title="0">fmt.Printf("üóëÔ∏è  Final deletion of task subtree:\n")
                        fmt.Printf("  üìÅ %s (ID: %s) [ROOT]\n", task.Title, task.ID)

                        if len(descendants) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  ‚îî‚îÄ‚îÄ %d descendant task(s):\n", len(descendants))
                                for _, desc := range descendants </span><span class="cov0" title="0">{
                                        indent := strings.Repeat("  ", desc.Depth-task.Depth+1)
                                        fmt.Printf("  %s‚îú‚îÄ %s (ID: %s)\n", indent, desc.Title, desc.ID)
                                }</span>
                        }

                        <span class="cov0" title="0">totalTasks := 1 + len(descendants)
                        fmt.Printf("\nTotal tasks to delete: %d\n", totalTasks)

                        // Perform deletion
                        err = appCtx.ProjectManager.DeleteTaskSubtree(context.Background(), taskID, appCtx.Actor)
                        if err != nil </span><span class="cov0" title="0">{
                                appCtx.Logger.Error("Failed to delete task subtree", zap.Error(err))
                                return errors.WrapWithSuggestion(err, "deleting task subtree")
                        }</span>

                        <span class="cov0" title="0">appCtx.Logger.Info("Task subtree deleted successfully", zap.Int("totalDeleted", totalTasks))
                        fmt.Printf("‚úÖ Task subtree permanently deleted: %d task(s) removed\n", totalTasks)
                        return nil</span>
                } else<span class="cov0" title="0"> {
                        // First call - mark subtree for deletion
                        if dryRun </span><span class="cov0" title="0">{
                                totalTasks := 1 + len(descendants)
                                fmt.Printf("üîç DRY RUN: Task subtree would be marked for deletion (%d tasks, no actual changes made)\n", totalTasks)
                                return nil
                        }</span>

                        // Show what will be marked for deletion
                        <span class="cov0" title="0">fmt.Printf("üìã Task subtree to be marked for deletion:\n")
                        fmt.Printf("  üìÅ %s (ID: %s) [ROOT]\n", task.Title, task.ID)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("    %s\n", task.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("    Current State: %s | Complexity: %d\n", task.State, task.Complexity)

                        if len(descendants) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  ‚îî‚îÄ‚îÄ %d descendant task(s):\n", len(descendants))
                                for _, desc := range descendants </span><span class="cov0" title="0">{
                                        indent := strings.Repeat("  ", desc.Depth-task.Depth+1)
                                        fmt.Printf("  %s‚îú‚îÄ %s (ID: %s) - State: %s\n", indent, desc.Title, desc.ID, desc.State)
                                }</span>
                        }

                        <span class="cov0" title="0">totalTasks := 1 + len(descendants)
                        fmt.Printf("\nTotal tasks to mark for deletion: %d\n", totalTasks)

                        // Check for dependencies on any task in the subtree
                        err = checkSubtreeDependencies(appCtx, task, descendants)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Mark root task for deletion (this will be the trigger for the subtree deletion)
                        <span class="cov0" title="0">_, err = appCtx.ProjectManager.UpdateTask(context.Background(), task.ID, task.Title, task.Description, task.Complexity, types.TaskStateDeletionPending, appCtx.Actor)
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;errors.EnhancedError{
                                        Operation:   "marking task subtree for deletion",
                                        Cause:       err,
                                        Suggestion:  "Check if the task state transition is valid",
                                        HelpCommand: "knot task update-state --help",
                                }
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("\n‚ö†Ô∏è  Task subtree marked for deletion. To confirm deletion, run the same command again:\n")
                        fmt.Printf("    knot task delete-subtree --id %s\n", taskID)
                        fmt.Printf("\nüí° To cancel deletion, change the root task state:\n")
                        fmt.Printf("    knot task update-state --id %s --state pending\n", taskID)
                        fmt.Printf("\nüìù Note: Only the root task is marked as deletion-pending. All descendants will be deleted when confirmed.\n")

                        return nil</span>
                }
        }
}

// confirmDeletion prompts user for confirmation
// Currently unused but kept for potential future use
// func confirmDeletion(itemType, itemName string) bool {
//         fmt.Printf("\nAre you sure you want to delete this %s?\n", itemType)
//         fmt.Printf("   %s\n", itemName)
//         fmt.Printf("\nThis action cannot be undone. Type 'yes' to confirm: ")
//
//         var response string
//         _, _ = fmt.Scanln(&amp;response)
//
//         return strings.ToLower(strings.TrimSpace(response)) == "yes"
// }

// getTaskDescendants recursively gets all descendants of a task (renamed to avoid conflict)
func getTaskDescendants(projectManager manager.ProjectManager, taskID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        var result []*types.Task
        visited := make(map[uuid.UUID]bool)

        var collectDescendants func(uuid.UUID) error
        collectDescendants = func(id uuid.UUID) error </span><span class="cov0" title="0">{
                if visited[id] </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">visited[id] = true

                children, err := projectManager.GetChildTasks(context.Background(), id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, child := range children </span><span class="cov0" title="0">{
                        result = append(result, child)
                        if err := collectDescendants(child.ID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if err := collectDescendants(taskID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// checkSubtreeDependencies checks for external dependencies on tasks in the subtree
func checkSubtreeDependencies(appCtx *shared.AppContext, rootTask *types.Task, descendants []*types.Task) error <span class="cov0" title="0">{
        allTasks := append([]*types.Task{rootTask}, descendants...)
        
        // Check dependencies for root task
        dependencies, err := appCtx.ProjectManager.GetTaskDependencies(context.Background(), rootTask.ID)
        if err == nil &amp;&amp; len(dependencies) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n  Root task depends on %d other task(s):\n", len(dependencies))
                for _, dep := range dependencies </span><span class="cov0" title="0">{
                        fmt.Printf("    ‚Ä¢ %s (ID: %s)\n", dep.Title, dep.ID)
                }</span>
        }

        // Check for external dependents (tasks outside the subtree that depend on tasks in the subtree)
        <span class="cov0" title="0">var externalDependents []*types.Task
        subtreeTaskIDs := make(map[uuid.UUID]bool)
        for _, task := range allTasks </span><span class="cov0" title="0">{
                subtreeTaskIDs[task.ID] = true
        }</span>

        <span class="cov0" title="0">for _, task := range allTasks </span><span class="cov0" title="0">{
                dependents, err := appCtx.ProjectManager.GetDependentTasks(context.Background(), task.ID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, dependent := range dependents </span><span class="cov0" title="0">{
                        // If the dependent is not in our subtree, it's an external dependency
                        if !subtreeTaskIDs[dependent.ID] </span><span class="cov0" title="0">{
                                externalDependents = append(externalDependents, dependent)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(externalDependents) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n  ‚ö†Ô∏è  %d external task(s) depend on tasks in this subtree:\n", len(externalDependents))
                for _, dep := range externalDependents </span><span class="cov0" title="0">{
                        fmt.Printf("    ‚Ä¢ %s (ID: %s)\n", dep.Title, dep.ID)
                }</span>
                <span class="cov0" title="0">fmt.Printf("    These dependencies will be removed when the subtree is deleted.\n")</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package task

import (
        "embed"
        "fmt"

        "github.com/denkhaus/knot/internal/shared"
        "github.com/urfave/cli/v2"
)

//go:embed get_started.md
var getStartedFS embed.FS

// GetStartedAction provides a summary of available commands for LLM agents
func GetStartedAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                content, err := getStartedFS.ReadFile("get_started.md")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read get-started content: %w", err)
                }</span>
                
                <span class="cov0" title="0">fmt.Print(string(content))
                return nil</span>
        }
}</pre>
		
		<pre class="file" id="file15" style="display: none">package task

import (
        "context"
        "fmt"
        "sort"

        "github.com/denkhaus/knot/internal/shared"

        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// HierarchyCommands returns hierarchy navigation CLI commands
func HierarchyCommands(appCtx *shared.AppContext) []*cli.Command <span class="cov0" title="0">{
        return []*cli.Command{
                {
                        Name:   "children",
                        Usage:  "Get direct children of a task",
                        Action: ChildrenAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-id",
                                        Usage:    "Parent task ID",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "recursive",
                                        Usage: "Show all descendants (children of children)",
                                        Value: false,
                                },
                        },
                },
                {
                        Name:   "parent",
                        Usage:  "Get parent task of a task",
                        Action: ParentAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-id",
                                        Usage:    "Child task ID",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "roots",
                        Usage:  "Get root tasks of a project",
                        Action: RootsAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.IntFlag{
                                        Name:  "limit",
                                        Usage: "Maximum number of root tasks to show",
                                        Value: 0, // 0 means no limit
                                },
                        },
                },
                {
                        Name:   "tree",
                        Usage:  "Show task hierarchy as a tree",
                        Action: TreeAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.IntFlag{
                                        Name:  "max-depth",
                                        Usage: "Maximum depth to show (0 = no limit)",
                                        Value: 0,
                                },
                                &amp;cli.StringFlag{
                                        Name:  "root-task-id",
                                        Usage: "Show tree starting from specific task",
                                },
                        },
                },
        }
}</span>

// ChildrenAction gets direct children of a task
func ChildrenAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("task-id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid task ID: %w", err)
                }</span>

                <span class="cov0" title="0">recursive := c.Bool("recursive")

                appCtx.Logger.Info("Getting child tasks",
                        zap.String("taskID", taskID.String()),
                        zap.Bool("recursive", recursive))

                // Get the parent task for context
                parentTask, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get parent task", zap.Error(err))
                        return fmt.Errorf("failed to get parent task: %w", err)
                }</span>

                <span class="cov0" title="0">var children []*types.Task
                if recursive </span><span class="cov0" title="0">{
                        children, err = getAllDescendants(appCtx.ProjectManager, taskID)
                }</span> else<span class="cov0" title="0"> {
                        children, err = appCtx.ProjectManager.GetChildTasks(context.Background(), taskID)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get child tasks", zap.Error(err))
                        return fmt.Errorf("failed to get child tasks: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Children of '%s' (ID: %s):\n\n", parentTask.Title, taskID)

                if len(children) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No child tasks found.")
                        return nil
                }</span>

                // Sort by depth first, then by title
                <span class="cov0" title="0">sort.Slice(children, func(i, j int) bool </span><span class="cov0" title="0">{
                        if children[i].Depth != children[j].Depth </span><span class="cov0" title="0">{
                                return children[i].Depth &lt; children[j].Depth
                        }</span>
                        <span class="cov0" title="0">return children[i].Title &lt; children[j].Title</span>
                })

                <span class="cov0" title="0">for i, child := range children </span><span class="cov0" title="0">{
                        indent := ""
                        if recursive </span><span class="cov0" title="0">{
                                // Show indentation based on relative depth
                                relativeDepth := child.Depth - parentTask.Depth - 1
                                for d := 0; d &lt; relativeDepth; d++ </span><span class="cov0" title="0">{
                                        indent += "  "
                                }</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("%s%d. %s (ID: %s)\n", indent, i+1, child.Title, child.ID)
                        if child.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("%s   %s\n", indent, child.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("%s   State: %s | Complexity: %d | Depth: %d\n",
                                indent, child.State, child.Complexity, child.Depth)
                        fmt.Println()</span>
                }

                <span class="cov0" title="0">if recursive </span><span class="cov0" title="0">{
                        fmt.Printf("Total: %d descendants\n", len(children))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Total: %d direct children\n", len(children))
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

// ParentAction gets parent task of a task
func ParentAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("task-id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid task ID: %w", err)
                }</span>

                <span class="cov0" title="0">appCtx.Logger.Info("Getting parent task", zap.String("taskID", taskID.String()))

                // Get the child task first
                childTask, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get task", zap.Error(err))
                        return fmt.Errorf("failed to get task: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Parent of '%s' (ID: %s):\n\n", childTask.Title, taskID)

                if childTask.ParentID == nil </span><span class="cov0" title="0">{
                        fmt.Println("This is a root task (no parent).")
                        return nil
                }</span>

                <span class="cov0" title="0">parentTask, err := appCtx.ProjectManager.GetParentTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get parent task", zap.Error(err))
                        return fmt.Errorf("failed to get parent task: %w", err)
                }</span>

                <span class="cov0" title="0">if parentTask == nil </span><span class="cov0" title="0">{
                        fmt.Println("Parent task not found (orphaned task).")
                        return nil
                }</span>

                <span class="cov0" title="0">fmt.Printf("* %s (ID: %s)\n", parentTask.Title, parentTask.ID)
                if parentTask.Description != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  %s\n", parentTask.Description)
                }</span>
                <span class="cov0" title="0">fmt.Printf("  State: %s | Complexity: %d | Depth: %d\n",
                        parentTask.State, parentTask.Complexity, parentTask.Depth)

                return nil</span>
        }
}

// RootsAction gets root tasks of a project
func RootsAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">limit := c.Int("limit")

                appCtx.Logger.Info("Getting root tasks",
                        zap.String("projectID", projectID.String()),
                        zap.Int("limit", limit))

                rootTasks, err := appCtx.ProjectManager.GetRootTasks(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        appCtx.Logger.Error("Failed to get root tasks", zap.Error(err))
                        return fmt.Errorf("failed to get root tasks: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Root tasks for project %s:\n\n", projectID)

                if len(rootTasks) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No root tasks found.")
                        return nil
                }</span>

                // Sort by title for consistent output
                <span class="cov0" title="0">sort.Slice(rootTasks, func(i, j int) bool </span><span class="cov0" title="0">{
                        return rootTasks[i].Title &lt; rootTasks[j].Title
                }</span>)

                // Apply limit if specified
                <span class="cov0" title="0">if limit &gt; 0 &amp;&amp; len(rootTasks) &gt; limit </span><span class="cov0" title="0">{
                        fmt.Printf("Root tasks (showing %d of %d):\n\n", limit, len(rootTasks))
                        rootTasks = rootTasks[:limit]
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Root tasks (%d total):\n\n", len(rootTasks))
                }</span>

                <span class="cov0" title="0">for i, task := range rootTasks </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s (ID: %s)\n", i+1, task.Title, task.ID)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   %s\n", task.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("   State: %s | Complexity: %d\n", task.State, task.Complexity)
                        fmt.Println()</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
} // getAllDescendants and other missing functions
</pre>
		
		<pre class="file" id="file16" style="display: none">package task

import (
        "context"
        "fmt"
        "sort"

        "github.com/denkhaus/knot/internal/manager"
        "github.com/denkhaus/knot/internal/shared"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"

        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// TreeAction shows task hierarchy as a tree
func TreeAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">maxDepth := c.Int("max-depth")
                rootTaskIDStr := c.String("root-task-id")

                appCtx.Logger.Info("Showing task tree",
                        zap.String("projectID", projectID.String()),
                        zap.Int("maxDepth", maxDepth),
                        zap.String("rootTaskID", rootTaskIDStr))

                var startingTasks []*types.Task

                if rootTaskIDStr != "" </span><span class="cov0" title="0">{
                        // Start from specific task
                        rootTaskID, err := uuid.Parse(rootTaskIDStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid root task ID: %w", err)
                        }</span>

                        <span class="cov0" title="0">task, err := appCtx.ProjectManager.GetTask(context.Background(), rootTaskID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get root task: %w", err)
                        }</span>
                        <span class="cov0" title="0">startingTasks = []*types.Task{task}
                        fmt.Printf("Task tree starting from '%s':\n\n", task.Title)</span>
                } else<span class="cov0" title="0"> {
                        // Start from project roots
                        roots, err := appCtx.ProjectManager.GetRootTasks(context.Background(), projectID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get root tasks: %w", err)
                        }</span>
                        <span class="cov0" title="0">startingTasks = roots
                        fmt.Printf("Task tree for project %s:\n\n", projectID)</span>
                }

                <span class="cov0" title="0">if len(startingTasks) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No tasks found.")
                        return nil
                }</span>

                // Sort starting tasks
                <span class="cov0" title="0">sort.Slice(startingTasks, func(i, j int) bool </span><span class="cov0" title="0">{
                        return startingTasks[i].Title &lt; startingTasks[j].Title
                }</span>)

                <span class="cov0" title="0">for _, task := range startingTasks </span><span class="cov0" title="0">{
                        if err := printTaskTree(appCtx.ProjectManager, task, 0, maxDepth, ""); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to print task tree: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

// getAllDescendants recursively gets all descendants of a task
func getAllDescendants(projectManager manager.ProjectManager, taskID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        var result []*types.Task
        visited := make(map[uuid.UUID]bool)

        var collectDescendants func(uuid.UUID) error
        collectDescendants = func(id uuid.UUID) error </span><span class="cov0" title="0">{
                if visited[id] </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">visited[id] = true

                children, err := projectManager.GetChildTasks(context.Background(), id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, child := range children </span><span class="cov0" title="0">{
                        result = append(result, child)
                        if err := collectDescendants(child.ID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if err := collectDescendants(taskID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// printTaskTree recursively prints a task and its children as a tree
func printTaskTree(projectManager manager.ProjectManager, task *types.Task, currentDepth, maxDepth int, prefix string) error <span class="cov0" title="0">{
        // Check depth limit
        if maxDepth &gt; 0 &amp;&amp; currentDepth &gt;= maxDepth </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Print current task
        <span class="cov0" title="0">fmt.Printf("%s+- %s (ID: %s) - %s\n", prefix, task.Title, task.ID, task.State)

        // Get children
        children, err := projectManager.GetChildTasks(context.Background(), task.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Sort children
        <span class="cov0" title="0">sort.Slice(children, func(i, j int) bool </span><span class="cov0" title="0">{
                return children[i].Title &lt; children[j].Title
        }</span>)

        // Print children
        <span class="cov0" title="0">for i, child := range children </span><span class="cov0" title="0">{
                childPrefix := prefix
                if i == len(children)-1 </span><span class="cov0" title="0">{
                        childPrefix += "   "
                }</span> else<span class="cov0" title="0"> {
                        childPrefix += "|  "
                }</span>

                <span class="cov0" title="0">if err := printTaskTree(projectManager, child, currentDepth+1, maxDepth, childPrefix); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package template

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "strings"

        "github.com/denkhaus/knot/internal/shared"
        "github.com/denkhaus/knot/internal/templates"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
)

// Commands returns all template-related CLI commands
func Commands(appCtx *shared.AppContext) []*cli.Command <span class="cov0" title="0">{
        return []*cli.Command{
                {
                        Name:   "list",
                        Usage:  "List available task templates",
                        Action: listAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:    "category",
                                        Aliases: []string{"c"},
                                        Usage:   "Filter by category",
                                },
                                &amp;cli.StringSliceFlag{
                                        Name:    "tags",
                                        Aliases: []string{"t"},
                                        Usage:   "Filter by tags (can specify multiple)",
                                },
                                &amp;cli.StringFlag{
                                        Name:    "search",
                                        Aliases: []string{"q"},
                                        Usage:   "Search in template names and descriptions",
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "built-in",
                                        Usage: "Show only built-in templates",
                                },
                                &amp;cli.BoolFlag{
                                        Name:    "json",
                                        Aliases: []string{"j"},
                                        Usage:   "Output in JSON format",
                                },
                        },
                },
                {
                        Name:   "show",
                        Usage:  "Show detailed information about a template",
                        Action: showAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "name",
                                        Aliases:  []string{"n"},
                                        Usage:    "Template name",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:    "json",
                                        Aliases: []string{"j"},
                                        Usage:   "Output in JSON format",
                                },
                        },
                },
                {
                        Name:   "apply",
                        Usage:  "Apply a template to create tasks",
                        Action: applyAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "name",
                                        Aliases:  []string{"n"},
                                        Usage:    "Template name",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:  "parent-id",
                                        Usage: "Parent task ID (optional)",
                                },
                                &amp;cli.StringSliceFlag{
                                        Name:    "var",
                                        Aliases: []string{"v"},
                                        Usage:   "Template variables in format key=value (can specify multiple)",
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "dry-run",
                                        Usage: "Preview what tasks would be created without actually creating them",
                                },
                                &amp;cli.BoolFlag{
                                        Name:    "json",
                                        Aliases: []string{"j"},
                                        Usage:   "Output in JSON format",
                                },
                        },
                },
                {
                        Name:   "create",
                        Usage:  "Create a new template from file",
                        Action: createAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "file",
                                        Aliases:  []string{"f"},
                                        Usage:    "Template file path (YAML format)",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "validate",
                        Usage:  "Validate a template file",
                        Action: validateAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "file",
                                        Aliases:  []string{"f"},
                                        Usage:    "Template file path (YAML format)",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "info",
                        Usage:  "Show detailed information about a template including source",
                        Action: infoAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "name",
                                        Aliases:  []string{"n"},
                                        Usage:    "Template name",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:    "json",
                                        Aliases: []string{"j"},
                                        Usage:   "Output in JSON format",
                                },
                        },
                },
                {
                        Name:   "edit",
                        Usage:  "Edit a user template in default editor",
                        Action: editAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "name",
                                        Aliases:  []string{"n"},
                                        Usage:    "Template name",
                                        Required: true,
                                },
                        },
                },
                {
                        Name:   "delete",
                        Usage:  "Delete a user template",
                        Action: deleteAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "name",
                                        Aliases:  []string{"n"},
                                        Usage:    "Template name",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "force",
                                        Usage: "Skip confirmation prompt",
                                },
                        },
                },
        }
}</span>

// listAction lists available templates
func listAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                // Load all templates (user + built-in)
                templates, err := loadAllTemplates()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load templates: %w", err)
                }</span>

                // Apply filters
                <span class="cov0" title="0">filtered := applyTemplateFilters(templates, c)

                if len(filtered) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No templates found matching the criteria.")
                        return nil
                }</span>

                // Check if JSON output is requested
                <span class="cov0" title="0">if c.Bool("json") </span><span class="cov0" title="0">{
                        return outputTemplatesAsJSON(filtered)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Found %d template(s):\n\n", len(filtered))
                for _, template := range filtered </span><span class="cov0" title="0">{
                        fmt.Printf("* %s\n", template.Name)
                        fmt.Printf("  Category: %s\n", template.Category)
                        if len(template.Tags) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  Tags: %s\n", strings.Join(template.Tags, ", "))
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("  Description: %s\n", template.Description)
                        fmt.Printf("  Tasks: %d\n", len(template.Tasks))
                        if len(template.Variables) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  Variables: %d\n", len(template.Variables))
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

// showAction shows detailed information about a template
func showAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                templateName := c.String("name")
                
                template, err := findTemplateByName(templateName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("template not found: %w", err)
                }</span>

                // Check if JSON output is requested
                <span class="cov0" title="0">if c.Bool("json") </span><span class="cov0" title="0">{
                        return outputTemplateAsJSON(template)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Template: %s\n", template.Name)
                fmt.Printf("Category: %s\n", template.Category)
                if len(template.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Tags: %s\n", strings.Join(template.Tags, ", "))
                }</span>
                <span class="cov0" title="0">fmt.Printf("Description: %s\n\n", template.Description)

                if len(template.Variables) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("Variables:")
                        for _, variable := range template.Variables </span><span class="cov0" title="0">{
                                fmt.Printf("  %s (%s)", variable.Name, variable.Type)
                                if variable.Required </span><span class="cov0" title="0">{
                                        fmt.Print(" [required]")
                                }</span>
                                <span class="cov0" title="0">if variable.DefaultValue != nil </span><span class="cov0" title="0">{
                                        fmt.Printf(" [default: %s]", *variable.DefaultValue)
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("\n    %s\n", variable.Description)
                                if variable.Type == types.VarTypeChoice &amp;&amp; len(variable.Options) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("    Options: %s\n", strings.Join(variable.Options, ", "))
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">fmt.Printf("Tasks (%d):\n", len(template.Tasks))
                for i, task := range template.Tasks </span><span class="cov0" title="0">{
                        indent := ""
                        if task.ParentID != nil </span><span class="cov0" title="0">{
                                indent = "  "
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("%s%d. %s (ID: %s)\n", indent, i+1, task.Title, task.ID)
                        fmt.Printf("%s   Complexity: %d", indent, task.Complexity)
                        if task.Estimate != nil </span><span class="cov0" title="0">{
                                fmt.Printf(" | Estimate: %d min", *task.Estimate)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("%s   %s\n", indent, task.Description)
                        }</span>
                        <span class="cov0" title="0">if len(task.Dependencies) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("%s   Dependencies: %s\n", indent, strings.Join(task.Dependencies, ", "))
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

// applyAction applies a template to create tasks
func applyAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">templateName := c.String("name")
                template, err := findTemplateByName(templateName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("template not found: %w", err)
                }</span>

                // Parse variables
                <span class="cov0" title="0">variables := make(map[string]string)
                for _, varStr := range c.StringSlice("var") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(varStr, "=", 2)
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid variable format: %s (expected key=value)", varStr)
                        }</span>
                        <span class="cov0" title="0">variables[parts[0]] = parts[1]</span>
                }

                // Validate required variables
                <span class="cov0" title="0">if err := validateTemplateVariables(template, variables); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("variable validation failed: %w", err)
                }</span>

                // Parse parent ID if provided
                <span class="cov0" title="0">var parentID *uuid.UUID
                if parentIDStr := c.String("parent-id"); parentIDStr != "" </span><span class="cov0" title="0">{
                        parsed, err := uuid.Parse(parentIDStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid parent ID: %w", err)
                        }</span>
                        <span class="cov0" title="0">parentID = &amp;parsed</span>
                }

                <span class="cov0" title="0">dryRun := c.Bool("dry-run")
                
                // Apply template
                result, err := applyTemplate(appCtx, template, projectID, parentID, variables, dryRun)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to apply template: %w", err)
                }</span>

                // Check if JSON output is requested
                <span class="cov0" title="0">if c.Bool("json") </span><span class="cov0" title="0">{
                        return outputApplyResultAsJSON(result)
                }</span>

                <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                        fmt.Printf("Template '%s' would create %d tasks:\n\n", template.Name, len(result.CreatedTasks))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Template '%s' successfully created %d tasks:\n\n", template.Name, len(result.CreatedTasks))
                }</span>

                <span class="cov0" title="0">for i, task := range result.CreatedTasks </span><span class="cov0" title="0">{
                        indent := ""
                        for j := 0; j &lt; task.Depth; j++ </span><span class="cov0" title="0">{
                                indent += "  "
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("%s%d. %s (ID: %s)\n", indent, i+1, task.Title, task.ID)
                        fmt.Printf("%s   Complexity: %d | State: %s\n", indent, task.Complexity, task.State)
                        if task.Description != "" </span><span class="cov0" title="0">{
                                fmt.Printf("%s   %s\n", indent, task.Description)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("Errors:")
                        for _, errMsg := range result.Errors </span><span class="cov0" title="0">{
                                fmt.Printf("  - %s\n", errMsg)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

// createAction creates a new template from file
func createAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                filePath := c.String("file")
                
                template, err := loadTemplateFromFile(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load template: %w", err)
                }</span>

                // Validate template
                <span class="cov0" title="0">if err := validateTemplate(template); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("template validation failed: %w", err)
                }</span>

                // TODO: Save to database when template repository is implemented
                <span class="cov0" title="0">fmt.Printf("Template '%s' loaded and validated successfully.\n", template.Name)
                fmt.Printf("Note: Template persistence not yet implemented.\n")

                return nil</span>
        }
}

// validateAction validates a template file
func validateAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                filePath := c.String("file")
                
                template, err := loadTemplateFromFile(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load template: %w", err)
                }</span>

                <span class="cov0" title="0">if err := validateTemplate(template); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("template validation failed: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Template '%s' is valid.\n", template.Name)
                fmt.Printf("  Tasks: %d\n", len(template.Tasks))
                fmt.Printf("  Variables: %d\n", len(template.Variables))

                return nil</span>
        }
}
// infoAction shows detailed information about a template including source
func infoAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                templateName := c.String("name")
                
                template, err := findTemplateByName(templateName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("template not found: %w", err)
                }</span>

                // Determine source
                <span class="cov0" title="0">source := "built-in (embedded)"
                filePath := ""
                if !template.IsBuiltIn </span><span class="cov0" title="0">{
                        source = "user"
                        userPath, err := templates.GetUserTemplateFilePath(templateName)
                        if err == nil </span><span class="cov0" title="0">{
                                filePath = userPath
                        }</span>
                }

                // Check if JSON output is requested
                <span class="cov0" title="0">if c.Bool("json") </span><span class="cov0" title="0">{
                        info := map[string]interface{}{
                                "template": template,
                                "source":   source,
                                "filePath": filePath,
                        }
                        data, err := json.MarshalIndent(info, "", "  ")
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to marshal info to JSON: %w", err)
                        }</span>
                        <span class="cov0" title="0">fmt.Println(string(data))
                        return nil</span>
                }

                <span class="cov0" title="0">fmt.Printf("Template: %s\n", template.Name)
                fmt.Printf("Source: %s\n", source)
                if filePath != "" </span><span class="cov0" title="0">{
                        fmt.Printf("File Path: %s\n", filePath)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Category: %s\n", template.Category)
                if len(template.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Tags: %s\n", strings.Join(template.Tags, ", "))
                }</span>
                <span class="cov0" title="0">fmt.Printf("Description: %s\n", template.Description)
                fmt.Printf("Tasks: %d\n", len(template.Tasks))
                fmt.Printf("Variables: %d\n", len(template.Variables))
                fmt.Printf("Built-in: %t\n", template.IsBuiltIn)

                return nil</span>
        }
}

// editAction opens a user template in the default editor
func editAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                templateName := c.String("name")
                
                // Check if template exists
                template, err := findTemplateByName(templateName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("template not found: %w", err)
                }</span>

                // Only allow editing user templates
                <span class="cov0" title="0">if template.IsBuiltIn </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot edit built-in template \"%s\". Use \"knot template create\" to create a user version first", templateName)
                }</span>

                // Get file path
                <span class="cov0" title="0">filePath, err := templates.GetUserTemplateFilePath(templateName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get template file path: %w", err)
                }</span>

                // Get editor from environment or use default
                <span class="cov0" title="0">editor := os.Getenv("EDITOR")
                if editor == "" </span><span class="cov0" title="0">{
                        editor = "nano" // Default editor
                }</span>

                // Open editor
                <span class="cov0" title="0">cmd := exec.Command(editor, filePath)
                cmd.Stdin = os.Stdin
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr

                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open editor: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Template \"%s\" edited successfully.\n", templateName)
                fmt.Printf("Use \"knot template validate --file %s\" to validate changes.\n", filePath)

                return nil</span>
        }
}

// deleteAction deletes a user template
func deleteAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                templateName := c.String("name")
                force := c.Bool("force")
                
                // Check if template exists
                template, err := findTemplateByName(templateName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("template not found: %w", err)
                }</span>

                // Only allow deleting user templates
                <span class="cov0" title="0">if template.IsBuiltIn </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot delete built-in template \"%s\"", templateName)
                }</span>

                // Confirmation prompt (unless force flag is used)
                <span class="cov0" title="0">if !force </span><span class="cov0" title="0">{
                        fmt.Printf("Are you sure you want to delete user template \"%s\"? (y/N): ", templateName)
                        var response string
                        _, _ = fmt.Scanln(&amp;response)
                        if response != "y" &amp;&amp; response != "Y" &amp;&amp; response != "yes" &amp;&amp; response != "YES" </span><span class="cov0" title="0">{
                                fmt.Println("Deletion cancelled.")
                                return nil
                        }</span>
                }

                // Delete the template
                <span class="cov0" title="0">if err := templates.DeleteUserTemplate(templateName); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete template: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("User template \"%s\" deleted successfully.\n", templateName)
                
                // Check if built-in version exists
                builtInTemplates, err := loadBuiltInTemplates()
                if err == nil </span><span class="cov0" title="0">{
                        for _, builtIn := range builtInTemplates </span><span class="cov0" title="0">{
                                if strings.EqualFold(builtIn.Name, templateName) </span><span class="cov0" title="0">{
                                        fmt.Printf("Note: Built-in template \"%s\" is still available.\n", templateName)
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package template

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/denkhaus/knot/internal/shared"
        "github.com/denkhaus/knot/internal/templates"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
)

// loadAllTemplates loads both user and built-in templates, with user templates taking precedence
func loadAllTemplates() ([]*types.TaskTemplate, error) <span class="cov0" title="0">{
        var allTemplates []*types.TaskTemplate
        templateMap := make(map[string]*types.TaskTemplate)

        // Load built-in templates first
        builtInTemplates, err := templates.LoadBuiltInTemplates()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load built-in templates: %w", err)
        }</span>

        // Add built-in templates to map
        <span class="cov0" title="0">for _, template := range builtInTemplates </span><span class="cov0" title="0">{
                templateMap[strings.ToLower(template.Name)] = template
        }</span>

        // Load user templates (these override built-in templates with same name)
        <span class="cov0" title="0">userTemplates, err := templates.LoadUserTemplates()
        if err != nil </span>{<span class="cov0" title="0">
                // Don't fail if user templates can't be loaded, just log and continue
                // In a real implementation, we'd use proper logging here
        }</span> else<span class="cov0" title="0"> {
                // User templates take precedence
                for _, template := range userTemplates </span><span class="cov0" title="0">{
                        templateMap[strings.ToLower(template.Name)] = template
                }</span>
        }

        // Convert map back to slice
        <span class="cov0" title="0">for _, template := range templateMap </span><span class="cov0" title="0">{
                allTemplates = append(allTemplates, template)
        }</span>

        <span class="cov0" title="0">return allTemplates, nil</span>
}

// loadBuiltInTemplates loads all built-in templates from embedded filesystem
func loadBuiltInTemplates() ([]*types.TaskTemplate, error) <span class="cov0" title="0">{
        return templates.LoadBuiltInTemplates()
}</span>

// loadTemplateFromFile loads a template from a YAML file (delegates to templates package)
func loadTemplateFromFile(filePath string) (*types.TaskTemplate, error) <span class="cov0" title="0">{
        return templates.LoadTemplateFromFile(filePath)
}</span>

// findTemplateByName finds a template by name from all available templates (user + built-in)
func findTemplateByName(name string) (*types.TaskTemplate, error) <span class="cov0" title="0">{
        allTemplates, err := loadAllTemplates()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, template := range allTemplates </span><span class="cov0" title="0">{
                if strings.EqualFold(template.Name, name) </span><span class="cov0" title="0">{
                        return template, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("template '%s' not found", name)</span>
}

// applyTemplateFilters applies filters to template list
func applyTemplateFilters(templates []*types.TaskTemplate, c *cli.Context) []*types.TaskTemplate <span class="cov0" title="0">{
        var filtered []*types.TaskTemplate

        for _, template := range templates </span><span class="cov0" title="0">{
                // Category filter
                if category := c.String("category"); category != "" </span><span class="cov0" title="0">{
                        if !strings.EqualFold(template.Category, category) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Tags filter
                <span class="cov0" title="0">if tags := c.StringSlice("tags"); len(tags) &gt; 0 </span><span class="cov0" title="0">{
                        hasTag := false
                        for _, filterTag := range tags </span><span class="cov0" title="0">{
                                for _, templateTag := range template.Tags </span><span class="cov0" title="0">{
                                        if strings.EqualFold(templateTag, filterTag) </span><span class="cov0" title="0">{
                                                hasTag = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if hasTag </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !hasTag </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Search filter
                <span class="cov0" title="0">if search := c.String("search"); search != "" </span><span class="cov0" title="0">{
                        searchLower := strings.ToLower(search)
                        nameMatch := strings.Contains(strings.ToLower(template.Name), searchLower)
                        descMatch := strings.Contains(strings.ToLower(template.Description), searchLower)
                        if !nameMatch &amp;&amp; !descMatch </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Built-in filter
                <span class="cov0" title="0">if c.Bool("built-in") &amp;&amp; !template.IsBuiltIn </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filtered = append(filtered, template)</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// validateTemplate validates a template structure
func validateTemplate(template *types.TaskTemplate) error <span class="cov0" title="0">{
        if template.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("template name is required")
        }</span>

        <span class="cov0" title="0">if len(template.Tasks) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("template must have at least one task")
        }</span>

        // Validate task IDs are unique
        <span class="cov0" title="0">taskIDs := make(map[string]bool)
        for _, task := range template.Tasks </span><span class="cov0" title="0">{
                if task.ID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("task ID is required")
                }</span>
                <span class="cov0" title="0">if taskIDs[task.ID] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate task ID: %s", task.ID)
                }</span>
                <span class="cov0" title="0">taskIDs[task.ID] = true

                if task.Title == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("task title is required for task %s", task.ID)
                }</span>

                <span class="cov0" title="0">if task.Complexity &lt; 1 || task.Complexity &gt; 10 </span><span class="cov0" title="0">{
                        return fmt.Errorf("task complexity must be between 1 and 10 for task %s", task.ID)
                }</span>
        }

        // Validate dependencies reference existing tasks
        <span class="cov0" title="0">for _, task := range template.Tasks </span><span class="cov0" title="0">{
                for _, depID := range task.Dependencies </span><span class="cov0" title="0">{
                        if !taskIDs[depID] </span><span class="cov0" title="0">{
                                return fmt.Errorf("task %s references non-existent dependency: %s", task.ID, depID)
                        }</span>
                }
                <span class="cov0" title="0">if task.ParentID != nil &amp;&amp; !taskIDs[*task.ParentID] </span><span class="cov0" title="0">{
                        return fmt.Errorf("task %s references non-existent parent: %s", task.ID, *task.ParentID)
                }</span>
        }

        // Validate variables
        <span class="cov0" title="0">varNames := make(map[string]bool)
        for _, variable := range template.Variables </span><span class="cov0" title="0">{
                if variable.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("variable name is required")
                }</span>
                <span class="cov0" title="0">if varNames[variable.Name] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate variable name: %s", variable.Name)
                }</span>
                <span class="cov0" title="0">varNames[variable.Name] = true

                if variable.Type == types.VarTypeChoice &amp;&amp; len(variable.Options) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("choice variable %s must have options", variable.Name)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateTemplateVariables validates that required variables are provided
func validateTemplateVariables(template *types.TaskTemplate, variables map[string]string) error <span class="cov0" title="0">{
        for _, variable := range template.Variables </span><span class="cov0" title="0">{
                value, provided := variables[variable.Name]
                
                if variable.Required &amp;&amp; !provided </span><span class="cov0" title="0">{
                        return fmt.Errorf("required variable '%s' not provided", variable.Name)
                }</span>

                <span class="cov0" title="0">if provided </span><span class="cov0" title="0">{
                        // Validate choice variables
                        if variable.Type == types.VarTypeChoice </span><span class="cov0" title="0">{
                                validOption := false
                                for _, option := range variable.Options </span><span class="cov0" title="0">{
                                        if value == option </span><span class="cov0" title="0">{
                                                validOption = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !validOption </span><span class="cov0" title="0">{
                                        return fmt.Errorf("variable '%s' must be one of: %s", variable.Name, strings.Join(variable.Options, ", "))
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// applyTemplate applies a template to create tasks
func applyTemplate(appCtx *shared.AppContext, template *types.TaskTemplate, projectID uuid.UUID, parentID *uuid.UUID, variables map[string]string, dryRun bool) (*types.TemplateApplyResult, error) <span class="cov0" title="0">{
        result := &amp;types.TemplateApplyResult{
                Success: true,
        }

        // Apply default values for missing variables
        finalVariables := make(map[string]string)
        for k, v := range variables </span><span class="cov0" title="0">{
                finalVariables[k] = v
        }</span>
        <span class="cov0" title="0">for _, variable := range template.Variables </span><span class="cov0" title="0">{
                if _, exists := finalVariables[variable.Name]; !exists &amp;&amp; variable.DefaultValue != nil </span><span class="cov0" title="0">{
                        finalVariables[variable.Name] = *variable.DefaultValue
                }</span>
        }

        // Create task ID mapping for dependencies
        <span class="cov0" title="0">taskIDMap := make(map[string]uuid.UUID)
        
        // First pass: create all tasks without dependencies
        for _, taskSpec := range template.Tasks </span><span class="cov0" title="0">{
                // Skip conditional tasks that don't match
                if shouldSkipTask(taskSpec, finalVariables) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">task := &amp;types.Task{
                        ID:          uuid.New(),
                        ProjectID:   projectID,
                        Title:       substituteVariables(taskSpec.Title, finalVariables),
                        Description: substituteVariables(taskSpec.Description, finalVariables),
                        State:       types.TaskStatePending,
                        Complexity:  taskSpec.Complexity,
                        Estimate:    taskSpec.Estimate,
                }

                // Set parent if this task has a parent in the template
                if taskSpec.ParentID != nil </span><span class="cov0" title="0">{
                        if parentTaskID, exists := taskIDMap[*taskSpec.ParentID]; exists </span><span class="cov0" title="0">{
                                task.ParentID = &amp;parentTaskID
                        }</span>
                } else<span class="cov0" title="0"> if parentID != nil </span><span class="cov0" title="0">{
                        // Use the provided parent ID for root tasks
                        task.ParentID = parentID
                }</span>

                <span class="cov0" title="0">taskIDMap[taskSpec.ID] = task.ID

                if !dryRun </span><span class="cov0" title="0">{
                        actor := appCtx.GetActor()
                        createdTask, err := appCtx.ProjectManager.CreateTask(
                                context.Background(),
                                projectID,
                                task.ParentID,
                                task.Title,
                                task.Description,
                                task.Complexity,
                                types.TaskPriorityMedium,
                                actor,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                result.Errors = append(result.Errors, fmt.Sprintf("Failed to create task '%s': %v", task.Title, err))
                                result.Success = false
                                continue</span>
                        }
                        <span class="cov0" title="0">result.CreatedTasks = append(result.CreatedTasks, createdTask)</span>
                } else<span class="cov0" title="0"> {
                        result.CreatedTasks = append(result.CreatedTasks, task)
                }</span>
        }

        // TODO: Second pass for dependencies (requires dependency management implementation)

        <span class="cov0" title="0">if !dryRun &amp;&amp; result.Success </span><span class="cov0" title="0">{
                // Create template instance record
                instance := &amp;types.TemplateInstance{
                        TemplateID:   template.ID,
                        TemplateName: template.Name,
                        Variables:    finalVariables,
                        CreatedAt:    appCtx.ProjectManager.GetCurrentTime(),
                        CreatedBy:    appCtx.GetActor(),
                }
                for _, task := range result.CreatedTasks </span><span class="cov0" title="0">{
                        instance.CreatedTasks = append(instance.CreatedTasks, task.ID)
                }</span>
                <span class="cov0" title="0">result.Instance = instance</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// shouldSkipTask determines if a task should be skipped based on conditional metadata
func shouldSkipTask(taskSpec types.TaskSpec, variables map[string]string) bool <span class="cov0" title="0">{
        if conditional, exists := taskSpec.Metadata["conditional"]; exists </span><span class="cov0" title="0">{
                // Simple boolean variable check
                if strings.HasPrefix(conditional, "{{") &amp;&amp; strings.HasSuffix(conditional, "}}") </span><span class="cov0" title="0">{
                        varName := strings.Trim(conditional, "{}")
                        if value, exists := variables[varName]; exists </span><span class="cov0" title="0">{
                                return value != "true" &amp;&amp; value != "yes" &amp;&amp; value != "1"
                        }</span>
                        <span class="cov0" title="0">return true</span> // Skip if variable not found
                }
        }
        <span class="cov0" title="0">return false</span>
}

// substituteVariables replaces template variables in text
func substituteVariables(text string, variables map[string]string) string <span class="cov0" title="0">{
        result := text
        for name, value := range variables </span><span class="cov0" title="0">{
                placeholder := fmt.Sprintf("{{%s}}", name)
                result = strings.ReplaceAll(result, placeholder, value)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Output functions
func outputTemplatesAsJSON(templates []*types.TaskTemplate) error <span class="cov0" title="0">{
        data, err := json.MarshalIndent(templates, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal templates to JSON: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(data))
        return nil</span>
}

func outputTemplateAsJSON(template *types.TaskTemplate) error <span class="cov0" title="0">{
        data, err := json.MarshalIndent(template, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal template to JSON: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(data))
        return nil</span>
}

func outputApplyResultAsJSON(result *types.TemplateApplyResult) error <span class="cov0" title="0">{
        data, err := json.MarshalIndent(result, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal result to JSON: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(data))
        return nil</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">package validation

import (
        "context"
        "fmt"
        "strings"

        "github.com/denkhaus/knot/internal/shared"
        "github.com/denkhaus/knot/internal/types"
        internalValidation "github.com/denkhaus/knot/internal/validation"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
        "go.uber.org/zap"
)

// Commands returns validation related CLI commands
func Commands(appCtx *shared.AppContext) []*cli.Command <span class="cov0" title="0">{
        return []*cli.Command{
                {
                        Name:   "states",
                        Usage:  "Show valid task states and transitions",
                        Action: statesAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:  "from",
                                        Usage: "Show valid transitions from specific state",
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "matrix",
                                        Usage: "Show complete transition matrix",
                                        Value: false,
                                },
                        },
                },
                {
                        Name:   "transition",
                        Usage:  "Validate a state transition without applying it",
                        Action: transitionAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.StringFlag{
                                        Name:     "task-id",
                                        Usage:    "Task ID to validate transition for",
                                        Required: true,
                                },
                                &amp;cli.StringFlag{
                                        Name:     "to",
                                        Usage:    "Target state to validate",
                                        Required: true,
                                },
                                &amp;cli.BoolFlag{
                                        Name:  "lenient",
                                        Usage: "Use lenient validation (show warnings instead of errors)",
                                        Value: false,
                                },
                        },
                },
                {
                        Name:   "project",
                        Usage:  "Validate all task states in a project",
                        Action: projectAction(appCtx),
                        Flags: []cli.Flag{
                                &amp;cli.BoolFlag{
                                        Name:  "fix",
                                        Usage: "Attempt to fix invalid states automatically",
                                        Value: false,
                                },
                        },
                },
        }
}</span>

func statesAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                fromState := c.String("from")
                showMatrix := c.Bool("matrix")

                validator := internalValidation.NewStateValidator()

                if showMatrix </span><span class="cov0" title="0">{
                        fmt.Println("Task State Transition Matrix:")
                        matrix := validator.GetStateTransitionMatrix()

                        for state, transitions := range matrix </span><span class="cov0" title="0">{
                                fmt.Printf("* %s:\n", strings.ToUpper(state))
                                if len(transitions) == 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("   (no valid transitions)\n")
                                }</span> else<span class="cov0" title="0"> {
                                        for _, target := range transitions </span><span class="cov0" title="0">{
                                                fmt.Printf("   ‚úÖ ‚Üí %s\n", target)
                                        }</span>
                                }
                                <span class="cov0" title="0">fmt.Println()</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if fromState != "" </span><span class="cov0" title="0">{
                        if !validator.IsValidState(fromState) </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid state: %s", fromState)
                        }</span>

                        <span class="cov0" title="0">matrix := validator.GetStateTransitionMatrix()
                        transitions := matrix[fromState]

                        fmt.Printf("Valid transitions from '%s':\n\n", strings.ToUpper(fromState))
                        if len(transitions) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("   (no valid transitions)\n")
                        }</span> else<span class="cov0" title="0"> {
                                for _, target := range transitions </span><span class="cov0" title="0">{
                                        fmt.Printf("   ‚úÖ %s ‚Üí %s\n", fromState, target)
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }

                // Show all valid states
                <span class="cov0" title="0">fmt.Println("Valid Task States:")
                states := validator.GetAllValidStates()
                for _, state := range states </span><span class="cov0" title="0">{
                        fmt.Printf("   * %s\n", strings.ToUpper(string(state)))
                }</span>

                <span class="cov0" title="0">fmt.Println("\nUse --matrix to see all valid transitions")
                fmt.Println("Use --from &lt;state&gt; to see transitions from a specific state")

                return nil</span>
        }
}

func transitionAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                taskIDStr := c.String("task-id")
                taskID, err := uuid.Parse(taskIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid task ID: %w", err)
                }</span>

                <span class="cov0" title="0">toState := c.String("to")
                lenient := c.Bool("lenient")

                // Get task
                task, err := appCtx.ProjectManager.GetTask(context.Background(), taskID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get task: %w", err)
                }</span>

                <span class="cov0" title="0">validator := internalValidation.NewStateValidator()

                // Basic state validation
                if !validator.IsValidState(toState) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid target state: %s", toState)
                }</span>

                <span class="cov0" title="0">targetState := types.TaskState(toState)

                fmt.Printf("Validating transition for task '%s':\n", task.Title)
                fmt.Printf("  Current State: %s\n", strings.ToUpper(string(task.State)))
                fmt.Printf("  Target State:  %s\n", strings.ToUpper(string(targetState)))
                fmt.Println()

                if lenient </span><span class="cov0" title="0">{
                        err, warnings := validator.ValidateTransitionLenient(task.State, targetState, task)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Transition INVALID: %v\n", err)
                                return err
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Transition VALID\n")
                        if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("\nWarnings:\n")
                                for _, warning := range warnings </span><span class="cov0" title="0">{
                                        fmt.Printf("   %s\n", warning)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        err := validator.ValidateTransition(task.State, targetState, task)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Transition INVALID: %v\n", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("Transition VALID\n")</span>
                }

                <span class="cov0" title="0">fmt.Printf("\nTo apply this transition:\n")
                fmt.Printf("   knot task update-state --id %s --state %s\n", taskID, toState)

                return nil</span>
        }
}

func projectAction(appCtx *shared.AppContext) cli.ActionFunc <span class="cov0" title="0">{
        return func(c *cli.Context) error </span><span class="cov0" title="0">{
                projectID, err := shared.ResolveProjectID(c, appCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">fix := c.Bool("fix")

                appCtx.Logger.Info("Validating project task states", zap.String("projectID", projectID.String()))

                // Get all tasks
                tasks, err := appCtx.ProjectManager.ListTasksForProject(context.Background(), projectID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get project tasks: %w", err)
                }</span>

                <span class="cov0" title="0">validator := internalValidation.NewStateValidator()
                var issues []string
                var fixedCount int

                fmt.Printf("Validating %d tasks in project %s:\n\n", len(tasks), projectID)

                for _, task := range tasks </span><span class="cov0" title="0">{
                        // Check if state is valid
                        if !validator.IsValidState(string(task.State)) </span><span class="cov0" title="0">{
                                issue := fmt.Sprintf("Task '%s' has invalid state: %s", task.Title, task.State)
                                issues = append(issues, issue)

                                if fix </span><span class="cov0" title="0">{
                                        // Attempt to fix by setting to pending
                                        appCtx.Logger.Info("Fixing invalid state",
                                                zap.String("taskID", task.ID.String()),
                                                zap.String("invalidState", string(task.State)))

                                        _, err := appCtx.ProjectManager.UpdateTaskState(context.Background(), task.ID, types.TaskStatePending, appCtx.Actor)
                                        if err != nil </span><span class="cov0" title="0">{
                                                fmt.Printf("Failed to fix task %s: %v\n", task.ID, err)
                                        }</span> else<span class="cov0" title="0"> {
                                                fmt.Printf("Fixed task '%s': %s ‚Üí pending\n", task.Title, task.State)
                                                fixedCount++
                                        }</span>
                                }
                        }

                        // Additional validations could be added here
                        // e.g., check if blocked tasks have dependencies, etc.
                }

                <span class="cov0" title="0">fmt.Printf("\nüìä Validation Summary:\n")
                fmt.Printf("   Total Tasks: %d\n", len(tasks))
                fmt.Printf("   Issues Found: %d\n", len(issues))

                if fix &amp;&amp; fixedCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   Issues Fixed: %d\n", fixedCount)
                }</span>

                <span class="cov0" title="0">if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("\nIssues Found:\n")
                        for i, issue := range issues </span><span class="cov0" title="0">{
                                fmt.Printf("   %d. %s\n", i+1, issue)
                        }</span>

                        <span class="cov0" title="0">if !fix </span><span class="cov0" title="0">{
                                fmt.Printf("\nUse --fix to automatically repair invalid states\n")
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("\nAll task states are valid!\n")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/denkhaus/knot/internal/manager"
)

// ConfigFile provides file-based configuration management for Knot
// Uses the existing manager.Config struct but adds file persistence
// REFERENCE: pkg/tools/project/interfaces.go lines 64-80 (original Config struct)


// GetConfigPath returns the path to the knot configuration file
func GetConfigPath() (string, error) <span class="cov0" title="0">{
        // Use .knot directory for configuration (same as database)
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current working directory: %w", err)
        }</span>
        
        <span class="cov0" title="0">knotDir := filepath.Join(cwd, ".knot")
        configPath := filepath.Join(knotDir, "config.json")
        return configPath, nil</span>
}


// ValidateConfig checks if the configuration values are valid
func ValidateConfig(c *manager.Config) error <span class="cov0" title="0">{
        if c.MaxTasksPerDepth &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("max_tasks_per_depth must be at least 1, got %d", c.MaxTasksPerDepth)
        }</span>
        <span class="cov0" title="0">if c.ComplexityThreshold &lt; 1 || c.ComplexityThreshold &gt; 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("complexity_threshold must be between 1 and 10, got %d", c.ComplexityThreshold)
        }</span>
        <span class="cov0" title="0">if c.MaxDepth &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("max_depth must be at least 1, got %d", c.MaxDepth)
        }</span>
        <span class="cov0" title="0">if c.MaxDescriptionLength &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("max_description_length must be at least 1, got %d", c.MaxDescriptionLength)
        }</span>
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package errors

import (
        "fmt"
        "strings"

        "github.com/google/uuid"
)

// EnhancedError wraps an error with helpful suggestions and examples
type EnhancedError struct {
        Operation   string
        Cause       error
        Suggestion  string
        Example     string
        HelpCommand string
}

func (e *EnhancedError) Error() string <span class="cov8" title="1">{
        var parts []string
        
        // Main error message
        if e.Cause != nil </span><span class="cov8" title="1">{
                parts = append(parts, e.Cause.Error())
        }</span> else<span class="cov8" title="1"> {
                parts = append(parts, fmt.Sprintf("Error in %s", e.Operation))
        }</span>
        
        // Add suggestion if available
        <span class="cov8" title="1">if e.Suggestion != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("Suggestion: %s", e.Suggestion))
        }</span>
        
        // Add example if available
        <span class="cov8" title="1">if e.Example != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("Example: %s", e.Example))
        }</span>
        
        // Add help command if available
        <span class="cov8" title="1">if e.HelpCommand != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("For more help: %s", e.HelpCommand))
        }</span>
        
        <span class="cov8" title="1">return strings.Join(parts, "\n")</span>
}

func (e *EnhancedError) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

// Common error enhancement functions

// InvalidUUIDError creates an enhanced error for invalid UUID parsing
func InvalidUUIDError(fieldName, value string) *EnhancedError <span class="cov8" title="1">{
        return &amp;EnhancedError{
                Operation:   fmt.Sprintf("parsing %s", fieldName),
                Cause:       fmt.Errorf("invalid %s format: '%s'", fieldName, value),
                Suggestion:  fmt.Sprintf("Ensure %s is a valid UUID (36 characters with hyphens)", fieldName),
                Example:     "550e8400-e29b-41d4-a716-446655440000",
                HelpCommand: "knot project list  # to see available project IDs",
        }
}</span>

// TaskNotFoundError creates an enhanced error for missing tasks
func TaskNotFoundError(taskID uuid.UUID) *EnhancedError <span class="cov8" title="1">{
        return &amp;EnhancedError{
                Operation:   "finding task",
                Cause:       fmt.Errorf("task not found: %s", taskID),
                Suggestion:  "Verify the task ID exists in the current project",
                Example:     "knot task list  # to see available tasks",
                HelpCommand: "knot project list  # to see available projects",
        }
}</span>

// ProjectNotFoundError creates an enhanced error for missing projects
func ProjectNotFoundError(projectID uuid.UUID) *EnhancedError <span class="cov8" title="1">{
        return &amp;EnhancedError{
                Operation:   "finding project",
                Cause:       fmt.Errorf("project not found: %s", projectID),
                Suggestion:  "Check if the project exists or create a new one",
                Example:     "knot project create --title \"My Project\" --description \"Description\"",
                HelpCommand: "knot project list  # to see available projects",
        }
}</span>

// InvalidTaskStateError creates an enhanced error for invalid task states
func InvalidTaskStateError(state string) *EnhancedError <span class="cov8" title="1">{
        validStates := []string{"pending", "in-progress", "completed", "blocked", "cancelled"}
        return &amp;EnhancedError{
                Operation:   "validating task state",
                Cause:       fmt.Errorf("invalid task state: '%s'", state),
                Suggestion:  fmt.Sprintf("Use one of the valid states: %s", strings.Join(validStates, ", ")),
                Example:     "knot task update-state --id &lt;task-id&gt; --state completed",
                HelpCommand: "knot task update-state --help",
        }
}</span>

// CircularDependencyError creates an enhanced error for circular dependencies
func CircularDependencyError(taskID, dependsOnID uuid.UUID) *EnhancedError <span class="cov8" title="1">{
        return &amp;EnhancedError{
                Operation:   "adding task dependency",
                Cause:       fmt.Errorf("circular dependency detected between %s and %s", taskID, dependsOnID),
                Suggestion:  "Remove existing dependencies that create a cycle, or restructure your task hierarchy",
                Example:     "knot dependency cycles  # to detect all cycles",
                HelpCommand: "knot dependency validate",
        }
}</span>

// DatabaseConnectionError creates an enhanced error for database issues
func DatabaseConnectionError(operation string, cause error) *EnhancedError <span class="cov8" title="1">{
        return &amp;EnhancedError{
                Operation:  operation,
                Cause:      cause,
                Suggestion: "Check if the .knot directory exists and is writable, or try running from a different directory",
                Example:    "ls -la .knot/  # check database directory permissions",
                HelpCommand: "knot project list  # test database connectivity",
        }
}</span>

// MissingRequiredFlagError creates an enhanced error for missing CLI flags
func MissingRequiredFlagError(flagName, commandContext string) *EnhancedError <span class="cov8" title="1">{
        var example string
        var helpCommand string
        
        if commandContext == "" </span><span class="cov8" title="1">{
                commandContext = "command"
        }</span>
        
        <span class="cov8" title="1">switch flagName </span>{
        case "project-id":<span class="cov8" title="1">
                example = "knot " + commandContext + " (select a project first with: knot project select --id &lt;project-id&gt;)"
                helpCommand = "knot project list  # to see available projects"</span>
        case "task-id":<span class="cov8" title="1">
                example = "knot " + commandContext + " --task-id &lt;task-id&gt;"
                helpCommand = "knot task list  # to see available tasks"</span>
        default:<span class="cov8" title="1">
                example = "knot " + commandContext + " --" + flagName + " &lt;value&gt;"
                helpCommand = "knot --help"</span>
        }
        
        // Safe help command generation
        <span class="cov8" title="1">if commandContext != "" &amp;&amp; commandContext != "command" </span><span class="cov8" title="1">{
                fields := strings.Fields(commandContext)
                if len(fields) &gt; 0 </span><span class="cov8" title="1">{
                        helpCommand = "knot " + fields[0] + " --help"
                }</span>
        }
        
        <span class="cov8" title="1">var flagType string
        if flagName == "project-id" </span><span class="cov8" title="1">{
                // project-id is no longer a global flag, suggest using project selection instead
                return &amp;EnhancedError{
                        Operation:   "project context resolution",
                        Cause:       fmt.Errorf("no project is currently selected"),
                        Suggestion:  "Select a project first using the project selection command",
                        Example:     "knot project select --id &lt;project-id&gt;",
                        HelpCommand: "knot project list  # to see available projects",
                }
        }</span> else<span class="cov8" title="1"> {
                flagType = "required flag"
        }</span>
        
        <span class="cov8" title="1">return &amp;EnhancedError{
                Operation:   "parsing command flags",
                Cause:       fmt.Errorf("%s --%s not provided", flagType, flagName),
                Suggestion:  fmt.Sprintf("Add the --%s flag with a valid value", flagName),
                Example:     example,
                HelpCommand: helpCommand,
        }</span>
}

// ComplexityOutOfRangeError creates an enhanced error for invalid complexity values
func ComplexityOutOfRangeError(complexity int) *EnhancedError <span class="cov8" title="1">{
        return &amp;EnhancedError{
                Operation:   "validating task complexity",
                Cause:       fmt.Errorf("complexity %d is out of range", complexity),
                Suggestion:  "Use a complexity value between 1 and 10 (1=very simple, 10=very complex)",
                Example:     "knot task create --title \"Task\" --complexity 5",
                HelpCommand: "knot task create --help",
        }
}</span>

// TooManyTasksError creates an enhanced error for task limits
func TooManyTasksError(currentCount, maxAllowed int, depth int) *EnhancedError <span class="cov8" title="1">{
        return &amp;EnhancedError{
                Operation:   "creating task",
                Cause:       fmt.Errorf("maximum tasks per depth exceeded: %d/%d at depth %d", currentCount, maxAllowed, depth),
                Suggestion:  "Break down existing complex tasks into subtasks, or increase the limit via environment variable",
                Example:     "export KNOT_MAX_TASKS_PER_DEPTH=200  # increase limit",
                HelpCommand: "knot breakdown  # find tasks to break down",
        }
}</span>

// NewValidationError creates an enhanced error for validation failures
func NewValidationError(message string, cause error) *EnhancedError <span class="cov8" title="1">{
        return &amp;EnhancedError{
                Operation:   "input validation",
                Cause:       cause,
                Suggestion:  "Check your input and try again with valid values",
                Example:     "Ensure titles are under 200 characters and descriptions under 2000 characters",
                HelpCommand: "knot --help",
        }
}</span>

// EmptyResultError creates an enhanced error for empty query results
func EmptyResultError(operation, context string) *EnhancedError <span class="cov8" title="1">{
        var suggestion, example string
        
        switch operation </span>{
        case "list tasks":<span class="cov8" title="1">
                suggestion = "Create some tasks first, or check if you're using the correct project ID"
                example = "knot task create --title \"First Task\""</span>
        case "list projects":<span class="cov8" title="1">
                suggestion = "Create a project first to get started"
                example = "knot project create --title \"My Project\" --description \"Project description\""</span>
        case "find actionable tasks":<span class="cov8" title="1">
                suggestion = "Check if all tasks are completed, blocked, or have unmet dependencies"
                example = "knot ready  # see tasks ready to work on"</span>
        default:<span class="cov8" title="1">
                suggestion = "Check your query parameters or create the required resources first"
                example = "knot --help  # see available commands"</span>
        }
        
        <span class="cov8" title="1">return &amp;EnhancedError{
                Operation:   operation,
                Cause:       fmt.Errorf("no results found for %s", context),
                Suggestion:  suggestion,
                Example:     example,
                HelpCommand: "knot --help",
        }</span>
}
// NoProjectContextError creates an enhanced error when no project context is available
func NoProjectContextError() *EnhancedError <span class="cov8" title="1">{
        return &amp;EnhancedError{
                Operation:   "project context resolution",
                Cause:       fmt.Errorf("no project is currently selected"),
                Suggestion:  "Select a project first to work with tasks and other project-specific commands",
                Example:     "knot project select --id &lt;project-id&gt;",
                HelpCommand: "knot project list  # to see available projects",
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package errors

import (
        "fmt"
        "strings"

        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
)

// WrapWithSuggestion wraps any error with helpful suggestions based on context
func WrapWithSuggestion(err error, operation string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">errStr := err.Error()
        
        // UUID parsing errors
        if strings.Contains(errStr, "invalid UUID") </span><span class="cov0" title="0">{
                if strings.Contains(operation, "project") </span><span class="cov0" title="0">{
                        return InvalidUUIDError("project-id", extractValueFromError(errStr))
                }</span>
                <span class="cov0" title="0">if strings.Contains(operation, "task") </span><span class="cov0" title="0">{
                        return InvalidUUIDError("task-id", extractValueFromError(errStr))
                }</span>
        }
        
        // Not found errors
        <span class="cov0" title="0">if strings.Contains(errStr, "not found") </span><span class="cov0" title="0">{
                if strings.Contains(operation, "project") </span><span class="cov0" title="0">{
                        if id := extractUUIDFromError(errStr); id != uuid.Nil </span><span class="cov0" title="0">{
                                return ProjectNotFoundError(id)
                        }</span>
                }
                <span class="cov0" title="0">if strings.Contains(operation, "task") </span><span class="cov0" title="0">{
                        if id := extractUUIDFromError(errStr); id != uuid.Nil </span><span class="cov0" title="0">{
                                return TaskNotFoundError(id)
                        }</span>
                }
        }
        
        // Database connection errors
        <span class="cov0" title="0">if strings.Contains(errStr, "database") || strings.Contains(errStr, "connection") </span><span class="cov0" title="0">{
                return DatabaseConnectionError(operation, err)
        }</span>
        
        // State validation errors
        <span class="cov0" title="0">if strings.Contains(errStr, "invalid.*state") || strings.Contains(operation, "state") </span><span class="cov0" title="0">{
                if state := extractValueFromError(errStr); state != "" </span><span class="cov0" title="0">{
                        return InvalidTaskStateError(state)
                }</span>
        }
        
        // Circular dependency errors
        <span class="cov0" title="0">if strings.Contains(errStr, "circular") || strings.Contains(errStr, "cycle") </span><span class="cov0" title="0">{
                return CircularDependencyError(uuid.Nil, uuid.Nil) // Generic circular dependency error
        }</span>
        
        // Return original error if no enhancement is available
        <span class="cov0" title="0">return err</span>
}

// HandleCLIError provides enhanced error handling for CLI commands
func HandleCLIError(c *cli.Context, err error, operation string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Check for missing required flags
        <span class="cov0" title="0">if strings.Contains(err.Error(), "Required flag") </span><span class="cov0" title="0">{
                flagName := extractFlagNameFromError(err.Error())
                commandContext := buildCommandContext(c)
                return MissingRequiredFlagError(flagName, commandContext)
        }</span>
        
        // Wrap with context-aware suggestions
        <span class="cov0" title="0">return WrapWithSuggestion(err, operation)</span>
}

// extractValueFromError extracts a value from error messages like "invalid format: 'value'"
func extractValueFromError(errStr string) string <span class="cov0" title="0">{
        // Look for patterns like 'value' or "value"
        if start := strings.Index(errStr, "'"); start != -1 </span><span class="cov0" title="0">{
                if end := strings.Index(errStr[start+1:], "'"); end != -1 </span><span class="cov0" title="0">{
                        return errStr[start+1 : start+1+end]
                }</span>
        }
        <span class="cov0" title="0">if start := strings.Index(errStr, "\""); start != -1 </span><span class="cov0" title="0">{
                if end := strings.Index(errStr[start+1:], "\""); end != -1 </span><span class="cov0" title="0">{
                        return errStr[start+1 : start+1+end]
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// extractUUIDFromError attempts to extract a UUID from error messages
func extractUUIDFromError(errStr string) uuid.UUID <span class="cov0" title="0">{
        words := strings.Fields(errStr)
        for _, word := range words </span><span class="cov0" title="0">{
                if id, err := uuid.Parse(word); err == nil </span><span class="cov0" title="0">{
                        return id
                }</span>
        }
        <span class="cov0" title="0">return uuid.Nil</span>
}

// extractFlagNameFromError extracts flag name from CLI error messages
func extractFlagNameFromError(errStr string) string <span class="cov0" title="0">{
        // Look for patterns like "Required flag \"flag-name\""
        if start := strings.Index(errStr, "\""); start != -1 </span><span class="cov0" title="0">{
                if end := strings.Index(errStr[start+1:], "\""); end != -1 </span><span class="cov0" title="0">{
                        return errStr[start+1 : start+1+end]
                }</span>
        }
        <span class="cov0" title="0">return "unknown"</span>
}

// buildCommandContext builds a command context string for help messages
func buildCommandContext(c *cli.Context) string <span class="cov0" title="0">{
        var parts []string
        
        // Add command hierarchy
        if c.Command != nil </span><span class="cov0" title="0">{
                parts = append(parts, c.Command.Name)
        }</span>
        
        // Add parent command if available
        <span class="cov0" title="0">if c.Command != nil &amp;&amp; c.Command.Category != "" </span><span class="cov0" title="0">{
                parts = append([]string{c.Command.Category}, parts...)
        }</span>
        
        // Fallback to app name
        <span class="cov0" title="0">if len(parts) == 0 &amp;&amp; c.App != nil </span><span class="cov0" title="0">{
                parts = append(parts, c.App.Name)
        }</span>
        
        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}

// ValidateComplexity validates task complexity and returns enhanced error if invalid
func ValidateComplexity(complexity int) error <span class="cov0" title="0">{
        if complexity &lt; 1 || complexity &gt; 10 </span><span class="cov0" title="0">{
                return ComplexityOutOfRangeError(complexity)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateTaskState validates task state and returns enhanced error if invalid
func ValidateTaskState(state string) error <span class="cov0" title="0">{
        validStates := map[string]bool{
                "pending":     true,
                "in-progress": true,
                "completed":   true,
                "blocked":     true,
                "cancelled":   true,
        }
        
        if !validStates[state] </span><span class="cov0" title="0">{
                return InvalidTaskStateError(state)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FormatSuggestionList formats a list of suggestions for display
func FormatSuggestionList(title string, suggestions []string) string <span class="cov0" title="0">{
        if len(suggestions) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">var parts []string
        parts = append(parts, fmt.Sprintf("üí° %s:", title))
        
        for i, suggestion := range suggestions </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("   %d. %s", i+1, suggestion))
        }</span>
        
        <span class="cov0" title="0">return strings.Join(parts, "\n")</span>
}</pre>
		
		<pre class="file" id="file23" style="display: none">package logger

import (
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

var Log *zap.Logger

func init() <span class="cov0" title="0">{
        // Initialize with no-op logger by default
        // Will be configured later via SetLogLevel when CLI flags are parsed
        Log = zap.NewNop()
}</span>

// GetLogger returns the global logger instance
func GetLogger() *zap.Logger <span class="cov0" title="0">{
        return Log
}</span>

// SetLogLevel configures the global logger with the specified log level
func SetLogLevel(logLevel string) <span class="cov0" title="0">{
        var err error

        switch logLevel </span>{
        case "debug":<span class="cov0" title="0">
                // Development logger for debug mode
                Log, err = zap.NewDevelopment()
                if err != nil </span><span class="cov0" title="0">{
                        Log = zap.NewNop()
                }</span>
        case "info", "warn", "error":<span class="cov0" title="0">
                // For CLI usage, we want human-readable console output
                config := zap.NewDevelopmentConfig()
                config.EncoderConfig.TimeKey = ""     // Remove timestamp for cleaner CLI output
                config.EncoderConfig.CallerKey = ""   // Remove caller info for cleaner CLI output
                config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder // Colored level names
                config.OutputPaths = []string{"stderr"} // Send to stderr to not interfere with CLI output

                // Set log level
                switch logLevel </span>{
                case "info":<span class="cov0" title="0">
                        config.Level = zap.NewAtomicLevelAt(zap.InfoLevel)</span>
                case "warn":<span class="cov0" title="0">
                        config.Level = zap.NewAtomicLevelAt(zap.WarnLevel)</span>
                case "error":<span class="cov0" title="0">
                        config.Level = zap.NewAtomicLevelAt(zap.ErrorLevel)</span>
                }

                <span class="cov0" title="0">Log, err = config.Build()
                if err != nil </span><span class="cov0" title="0">{
                        Log = zap.NewNop() // Fallback to no-op logger
                }</span>
        case "off", "":<span class="cov0" title="0">
                // No logging at all (default)
                Log = zap.NewNop()</span>
        default:<span class="cov0" title="0">
                // Invalid log level, use no-op logger
                Log = zap.NewNop()</span>
        }
}

// Sync flushes any buffered log entries
func Sync() <span class="cov0" title="0">{
        if Log != nil </span><span class="cov0" title="0">{
                _ = Log.Sync()
        }</span>
}</pre>
		
		<pre class="file" id="file24" style="display: none">package manager

import (
        "context"
        "time"

        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
)

// ProjectManager defines the public interface for project task management
type ProjectManager interface {
        // Project operations
        CreateProject(ctx context.Context, title, description, actor string) (*types.Project, error)
        GetProject(ctx context.Context, projectID uuid.UUID) (*types.Project, error)
        UpdateProject(ctx context.Context, projectID uuid.UUID, title, description string, actor string) (*types.Project, error)
        UpdateProjectDescription(ctx context.Context, projectID uuid.UUID, description string, actor string) (*types.Project, error)
        UpdateProjectState(ctx context.Context, projectID uuid.UUID, state types.ProjectState, actor string) (*types.Project, error)
        DeleteProject(ctx context.Context, projectID uuid.UUID) error
        ListProjects(ctx context.Context) ([]*types.Project, error)

        // Task operations
        CreateTask(ctx context.Context, projectID uuid.UUID, parentID *uuid.UUID, title, description string, complexity int, priority types.TaskPriority, actor string) (*types.Task, error)
        GetTask(ctx context.Context, taskID uuid.UUID) (*types.Task, error)
        UpdateTask(ctx context.Context, taskID uuid.UUID, title, description string, complexity int, state types.TaskState, actor string) (*types.Task, error)
        UpdateTaskDescription(ctx context.Context, taskID uuid.UUID, description string, actor string) (*types.Task, error)
        UpdateTaskTitle(ctx context.Context, taskID uuid.UUID, title string, actor string) (*types.Task, error)
        UpdateTaskPriority(ctx context.Context, taskID uuid.UUID, priority types.TaskPriority, actor string) (*types.Task, error)
        UpdateTaskState(ctx context.Context, taskID uuid.UUID, state types.TaskState, actor string) (*types.Task, error)
        DeleteTask(ctx context.Context, taskID uuid.UUID, actor string) error
        DeleteTaskSubtree(ctx context.Context, taskID uuid.UUID, actor string) error

        // Task queries and analysis
        GetParentTask(ctx context.Context, taskID uuid.UUID) (*types.Task, error)
        GetChildTasks(ctx context.Context, taskID uuid.UUID) ([]*types.Task, error)
        GetRootTasks(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error)
        ListTasksForProject(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error)
        FindNextActionableTask(ctx context.Context, projectID uuid.UUID) (*types.Task, error)
        FindTasksNeedingBreakdown(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error)
        GetProjectProgress(ctx context.Context, projectID uuid.UUID) (*types.ProjectProgress, error)
        ListTasksByState(ctx context.Context, projectID uuid.UUID, state types.TaskState) ([]*types.Task, error)
        BulkUpdateTasks(ctx context.Context, taskIDs []uuid.UUID, updates types.TaskUpdates) error
        DuplicateTask(ctx context.Context, taskID uuid.UUID, newProjectID uuid.UUID) (*types.Task, error)
        SetTaskEstimate(ctx context.Context, taskID uuid.UUID, estimate int64) (*types.Task, error)

        // Agent assignment management
        AssignTaskToAgent(ctx context.Context, taskID uuid.UUID, agentID uuid.UUID) (*types.Task, error)
        UnassignTaskFromAgent(ctx context.Context, taskID uuid.UUID) (*types.Task, error)
        ListTasksByAgent(ctx context.Context, projectID uuid.UUID, agentID uuid.UUID) ([]*types.Task, error)
        ListUnassignedTasks(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error)

        // Dependency management
        AddTaskDependency(ctx context.Context, taskID uuid.UUID, dependsOnTaskID uuid.UUID, actor string) (*types.Task, error)
        RemoveTaskDependency(ctx context.Context, taskID uuid.UUID, dependsOnTaskID uuid.UUID, actor string) (*types.Task, error)
        GetTaskDependencies(ctx context.Context, taskID uuid.UUID) ([]*types.Task, error)
        GetDependentTasks(ctx context.Context, taskID uuid.UUID) ([]*types.Task, error)

        // Configuration
        GetConfig() *Config
        UpdateConfig(config *Config)
        LoadConfigFromFile() error
        SaveConfigToFile() error

        // Project context management
        GetSelectedProject(ctx context.Context) (*uuid.UUID, error)
        SetSelectedProject(ctx context.Context, projectID uuid.UUID, actor string) error
        ClearSelectedProject(ctx context.Context) error
        HasSelectedProject(ctx context.Context) (bool, error)

        // Utility methods
        GetCurrentTime() time.Time
}

// ToolSetProvider defines the interface for creating project task tool sets (not used in CLI)
// type ToolSetProvider interface {
//        CreateToolSet(opts ...Option) (tool.ToolSet, error)
// }

// Config holds configuration for the task management system
type Config struct {
        MaxTasksPerDepth     int  // Maximum tasks allowed per depth level (applies to all depths)
        ComplexityThreshold  int  // Threshold for task breakdown suggestions
        MaxDepth             int  // Maximum allowed depth
        MaxDescriptionLength int  // Maximum length for descriptions
        AutoReduceComplexity bool // Automatically reduce parent task complexity when subtasks are added
}

// DefaultConfig returns a sensible default configuration
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                MaxTasksPerDepth:     100,  // Increased from 20 to 100 for better scalability
                ComplexityThreshold:  8,
                MaxDepth:             5,
                MaxDescriptionLength: 2000, // Default maximum description length
                AutoReduceComplexity: true, // Enable auto-reduce by default
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package manager

import (
        "github.com/denkhaus/knot/internal/repository/inmemory"
        "github.com/denkhaus/knot/internal/types"
)

// NewManager creates a new project task manager with default in-memory repository
func NewManager(config *Config) ProjectManager <span class="cov0" title="0">{
        repo := inmemory.NewMemoryRepository()
        svc := newService(repo, config)
        return svc
}</span>

// NewManagerWithRepository creates a new project task manager with custom repository
func NewManagerWithRepository(repo types.Repository, config *Config) ProjectManager <span class="cov8" title="1">{
        svc := newService(repo, config)
        return svc
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package manager

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "time"

        knoterrors "github.com/denkhaus/knot/internal/errors"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
)

// service provides business logic for project task management
type service struct {
        repo   types.Repository
        config *Config
}

// newService creates a new task management service
func newService(repo types.Repository, config *Config) *service <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>
        <span class="cov8" title="1">return &amp;service{
                repo:   repo,
                config: config,
        }</span>
}

// Ensure service implements ProjectManager
var _ ProjectManager = (*service)(nil)

// Project operations

func (s *service) CreateProject(ctx context.Context, title, description, actor string) (*types.Project, error) <span class="cov8" title="1">{
        if err := s.validateProjectInput(title, description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">project := &amp;types.Project{
                ID:          uuid.New(),
                Title:       title,
                Description: description,
                State:       types.ProjectStateActive, // Set initial state to active
                CreatedBy:   actor,
                UpdatedBy:   actor,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        if err := s.repo.CreateProject(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create project: %w", err)
        }</span>

        <span class="cov8" title="1">return s.repo.GetProject(ctx, project.ID)</span>
}

func (s *service) GetProject(ctx context.Context, projectID uuid.UUID) (*types.Project, error) <span class="cov8" title="1">{
        return s.repo.GetProject(ctx, projectID)
}</span>

func (s *service) UpdateProject(ctx context.Context, projectID uuid.UUID, title, description string, actor string) (*types.Project, error) <span class="cov8" title="1">{
        if err := s.validateProjectInput(title, description); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">project, err := s.repo.GetProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">project.Title = title
        project.Description = description
        project.UpdatedBy = actor

        if err := s.repo.UpdateProject(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update project: %w", err)
        }</span>

        <span class="cov8" title="1">return s.repo.GetProject(ctx, projectID)</span>
}

func (s *service) UpdateProjectDescription(ctx context.Context, projectID uuid.UUID, description string, actor string) (*types.Project, error) <span class="cov0" title="0">{
        // Validate description length
        if len(description) &gt; s.config.MaxDescriptionLength </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("description cannot exceed %d characters", s.config.MaxDescriptionLength)
        }</span>

        <span class="cov0" title="0">project, err := s.repo.GetProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">project.Description = description
        project.UpdatedBy = actor

        if err := s.repo.UpdateProject(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update project description: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.GetProject(ctx, projectID)</span>
}

func (s *service) UpdateProjectState(ctx context.Context, projectID uuid.UUID, state types.ProjectState, actor string) (*types.Project, error) <span class="cov0" title="0">{
        project, err := s.repo.GetProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate state transition
        <span class="cov0" title="0">if !isValidProjectStateTransition(project.State, state) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid project state transition from '%s' to '%s'", project.State, state)
        }</span>

        <span class="cov0" title="0">project.State = state
        project.UpdatedBy = actor
        project.UpdatedAt = time.Now()

        if err := s.repo.UpdateProject(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update project state: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.GetProject(ctx, projectID)</span>
}

func (s *service) DeleteProject(ctx context.Context, projectID uuid.UUID) error <span class="cov8" title="1">{
        return s.repo.DeleteProject(ctx, projectID)
}</span>

func (s *service) ListProjects(ctx context.Context) ([]*types.Project, error) <span class="cov8" title="1">{
        return s.repo.ListProjects(ctx)
}</span>

// Task operations

func (s *service) CreateTask(ctx context.Context, projectID uuid.UUID, parentID *uuid.UUID, title, description string, complexity int, priority types.TaskPriority, actor string) (*types.Task, error) <span class="cov8" title="1">{
        if err := s.validateTaskInput(title, description, complexity); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Validate project exists
        <span class="cov8" title="1">if _, err := s.repo.GetProject(ctx, projectID); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("project not found: %w", err)
        }</span>

        // Calculate depth and validate constraints
        <span class="cov8" title="1">depth := 0
        if parentID != nil </span><span class="cov8" title="1">{
                parentTask, err := s.repo.GetTask(ctx, *parentID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parent task not found: %w", err)
                }</span>
                <span class="cov8" title="1">if parentTask.ProjectID != projectID </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parent task must be in the same project")
                }</span>
                <span class="cov8" title="1">depth = parentTask.Depth + 1</span>
        }

        // Check depth constraints
        <span class="cov8" title="1">if depth &gt; s.config.MaxDepth </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("maximum depth of %d exceeded", s.config.MaxDepth)
        }</span>

        // Check task count constraints for this depth
        <span class="cov8" title="1">counts, err := s.repo.GetTaskCountByDepth(ctx, projectID, depth)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check task count constraints: %w", err)
        }</span>
        <span class="cov8" title="1">if counts[depth] &gt;= s.config.MaxTasksPerDepth </span><span class="cov0" title="0">{
                return nil, knoterrors.TooManyTasksError(counts[depth], s.config.MaxTasksPerDepth, depth)
        }</span>

        <span class="cov8" title="1">task := &amp;types.Task{
                ID:          uuid.New(),
                ProjectID:   projectID,
                ParentID:    parentID,
                Title:       title,
                Description: description,
                State:       types.TaskStatePending,
                Priority:    priority,
                Complexity:  complexity,
                Depth:       depth,
                CreatedBy:   actor,
                UpdatedBy:   actor,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        if err := s.repo.CreateTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create task: %w", err)
        }</span>

        // Auto-reduce parent complexity if enabled and this is a subtask
        <span class="cov8" title="1">if s.config.AutoReduceComplexity &amp;&amp; parentID != nil </span><span class="cov8" title="1">{
                if err := s.autoReduceParentComplexity(ctx, *parentID); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the task creation
                        // The task was successfully created, complexity reduction is a bonus feature
                        fmt.Printf("Warning: Failed to auto-reduce parent complexity: %v\n", err)
                }</span>
        }

        <span class="cov8" title="1">return s.repo.GetTask(ctx, task.ID)</span>
}

func (s *service) GetTask(ctx context.Context, taskID uuid.UUID) (*types.Task, error) <span class="cov8" title="1">{
        return s.repo.GetTask(ctx, taskID)
}</span>

func (s *service) UpdateTaskState(ctx context.Context, taskID uuid.UUID, state types.TaskState, actor string) (*types.Task, error) <span class="cov8" title="1">{
        task, err := s.repo.GetTask(ctx, taskID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Validate state transition
        <span class="cov8" title="1">if !isValidTaskStateTransition(task.State, state) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid state transition from '%s' to '%s'", task.State, state)
        }</span>

        <span class="cov8" title="1">task.State = state
        task.UpdatedBy = actor
        task.UpdatedAt = time.Now()

        // Set completion timestamp if transitioning to completed
        if state == types.TaskStateCompleted &amp;&amp; task.CompletedAt == nil </span><span class="cov8" title="1">{
                now := time.Now()
                task.CompletedAt = &amp;now
        }</span> else<span class="cov8" title="1"> if state != types.TaskStateCompleted &amp;&amp; task.CompletedAt != nil </span><span class="cov0" title="0">{
                // Clear completion timestamp if moving away from completed
                task.CompletedAt = nil
        }</span>

        <span class="cov8" title="1">if err := s.repo.UpdateTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task state: %w", err)
        }</span>

        <span class="cov8" title="1">return s.repo.GetTask(ctx, taskID)</span>
}

func (s *service) UpdateTask(ctx context.Context, taskID uuid.UUID, title, description string, complexity int, state types.TaskState, actor string) (*types.Task, error) <span class="cov0" title="0">{
        if err := s.validateTaskInput(title, description, complexity); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">task, err := s.repo.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">task.Title = title
        task.Description = description
        task.Complexity = complexity
        task.State = state
        task.UpdatedBy = actor
        task.UpdatedAt = time.Now()

        if err := s.repo.UpdateTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.GetTask(ctx, taskID)</span>
}

func (s *service) UpdateTaskDescription(ctx context.Context, taskID uuid.UUID, description string, actor string) (*types.Task, error) <span class="cov8" title="1">{
        // Validate description length
        if len(description) &gt; s.config.MaxDescriptionLength </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("description cannot exceed %d characters", s.config.MaxDescriptionLength)
        }</span>

        <span class="cov8" title="1">task, err := s.repo.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">task.Description = description
        task.UpdatedBy = actor

        if err := s.repo.UpdateTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task description: %w", err)
        }</span>

        <span class="cov8" title="1">return s.repo.GetTask(ctx, taskID)</span>
}

func (s *service) UpdateTaskTitle(ctx context.Context, taskID uuid.UUID, title string, actor string) (*types.Task, error) <span class="cov8" title="1">{
        // Validate title
        if title == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("title cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(title) &gt; 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("title cannot exceed 200 characters")
        }</span>

        <span class="cov8" title="1">task, err := s.repo.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">task.Title = title
        task.UpdatedBy = actor

        if err := s.repo.UpdateTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task title: %w", err)
        }</span>

        <span class="cov8" title="1">return s.repo.GetTask(ctx, taskID)</span>
}

func (s *service) UpdateTaskPriority(ctx context.Context, taskID uuid.UUID, priority types.TaskPriority, actor string) (*types.Task, error) <span class="cov0" title="0">{
        task, err := s.repo.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">task.Priority = priority
        task.UpdatedBy = actor
        task.UpdatedAt = time.Now()

        if err := s.repo.UpdateTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task priority: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.GetTask(ctx, taskID)</span>
}

func (s *service) DeleteTask(ctx context.Context, taskID uuid.UUID, actor string) error <span class="cov8" title="1">{
        return s.repo.DeleteTask(ctx, taskID)
}</span>

func (s *service) DeleteTaskSubtree(ctx context.Context, taskID uuid.UUID, actor string) error <span class="cov0" title="0">{
        return s.repo.DeleteTaskSubtree(ctx, taskID)
}</span>

// Task queries and analysis

func (s *service) GetParentTask(ctx context.Context, taskID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        task, err := s.repo.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if task.ParentID == nil </span><span class="cov0" title="0">{
                return nil, nil // No parent
        }</span>
        <span class="cov0" title="0">return s.repo.GetTask(ctx, *task.ParentID)</span>
}

func (s *service) GetChildTasks(ctx context.Context, taskID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        // Validate task exists
        if _, err := s.repo.GetTask(ctx, taskID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task not found: %w", err)
        }</span>
        <span class="cov0" title="0">return s.repo.GetTasksByParent(ctx, taskID)</span>
}

func (s *service) GetRootTasks(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        return s.repo.GetRootTasks(ctx, projectID)
}</span>

// ListTasksForProject returns all tasks in a project regardless of hierarchy level
func (s *service) ListTasksForProject(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error) <span class="cov8" title="1">{
        // Validate project exists
        if _, err := s.repo.GetProject(ctx, projectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project not found: %w", err)
        }</span>

        <span class="cov8" title="1">return s.repo.GetTasksByProject(ctx, projectID)</span>
}

// BulkUpdateTasks updates multiple tasks with the same updates
func (s *service) BulkUpdateTasks(ctx context.Context, taskIDs []uuid.UUID, updates types.TaskUpdates) error <span class="cov0" title="0">{
        if len(taskIDs) == 0 </span><span class="cov0" title="0">{
                return nil // Nothing to update
        }</span>

        // Validate updates
        <span class="cov0" title="0">if updates.State == nil &amp;&amp; updates.Complexity == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one field must be specified for update")
        }</span>

        // Validate complexity if provided
        <span class="cov0" title="0">if updates.Complexity != nil &amp;&amp; (*updates.Complexity &lt; 1 || *updates.Complexity &gt; 10) </span><span class="cov0" title="0">{
                return fmt.Errorf("complexity is %d but must be between 1 and 10", *updates.Complexity)
        }</span>

        // Update each task
        <span class="cov0" title="0">for _, taskID := range taskIDs </span><span class="cov0" title="0">{
                task, err := s.repo.GetTask(ctx, taskID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get task %s: %w", taskID, err)
                }</span>

                // Apply updates
                <span class="cov0" title="0">if updates.State != nil </span><span class="cov0" title="0">{
                        task.State = *updates.State
                        if task.State == types.TaskStateCompleted &amp;&amp; task.CompletedAt == nil </span><span class="cov0" title="0">{
                                now := time.Now()
                                task.CompletedAt = &amp;now
                        }</span> else<span class="cov0" title="0"> if task.State != types.TaskStateCompleted &amp;&amp; task.CompletedAt != nil </span><span class="cov0" title="0">{
                                task.CompletedAt = nil
                        }</span>
                }
                <span class="cov0" title="0">if updates.Complexity != nil </span><span class="cov0" title="0">{
                        task.Complexity = *updates.Complexity
                }</span>

                <span class="cov0" title="0">task.UpdatedAt = time.Now()

                if err := s.repo.UpdateTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update task %s: %w", taskID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// DuplicateTask creates a copy of a task in a new project
func (s *service) DuplicateTask(ctx context.Context, taskID uuid.UUID, newProjectID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        // Validate source task exists
        originalTask, err := s.repo.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get source task: %w", err)
        }</span>

        // Validate target project exists
        <span class="cov0" title="0">if _, err := s.repo.GetProject(ctx, newProjectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("target project not found: %w", err)
        }</span>

        // Create a copy of the task
        <span class="cov0" title="0">newTask := &amp;types.Task{
                ID:          uuid.New(),
                ProjectID:   newProjectID,
                ParentID:    originalTask.ParentID, // This will be nil for the duplicated task
                Title:       originalTask.Title,
                Description: originalTask.Description,
                State:       types.TaskStatePending, // Reset state to pending
                Complexity:  originalTask.Complexity,
                Depth:       0, // Reset depth to 0 as it's now a root task
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
                CompletedAt: nil, // Reset completion status
        }

        // Save the new task
        if err := s.repo.CreateTask(ctx, newTask); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create duplicated task: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.GetTask(ctx, newTask.ID)</span>
}

// SetTaskEstimate sets the time estimate for a task
func (s *service) SetTaskEstimate(ctx context.Context, taskID uuid.UUID, estimate int64) (*types.Task, error) <span class="cov0" title="0">{
        // Validate estimate
        if estimate &lt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("estimate must be non-negative")
        }</span>

        <span class="cov0" title="0">task, err := s.repo.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">task.Estimate = &amp;estimate
        task.UpdatedAt = time.Now()

        if err := s.repo.UpdateTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update task estimate: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.GetTask(ctx, taskID)</span>
}

// Agent assignment methods

// AssignTaskToAgent assigns a task to a specific agent
func (s *service) AssignTaskToAgent(ctx context.Context, taskID uuid.UUID, agentID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        task, err := s.repo.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task not found: %w", err)
        }</span>

        <span class="cov0" title="0">task.AssignedAgent = &amp;agentID
        task.UpdatedAt = time.Now()

        if err := s.repo.UpdateTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to assign task to agent: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.GetTask(ctx, taskID)</span>
}

// UnassignTaskFromAgent removes agent assignment from a task
func (s *service) UnassignTaskFromAgent(ctx context.Context, taskID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        task, err := s.repo.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task not found: %w", err)
        }</span>

        <span class="cov0" title="0">task.AssignedAgent = nil
        task.UpdatedAt = time.Now()

        if err := s.repo.UpdateTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unassign task from agent: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.GetTask(ctx, taskID)</span>
}

// ListTasksByAgent returns all tasks assigned to a specific agent in a project
func (s *service) ListTasksByAgent(ctx context.Context, projectID uuid.UUID, agentID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        // Validate project exists
        if _, err := s.repo.GetProject(ctx, projectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project not found: %w", err)
        }</span>

        // Get all tasks in the project
        <span class="cov0" title="0">allTasks, err := s.repo.GetTasksByProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get project tasks: %w", err)
        }</span>

        // Filter tasks assigned to the specific agent
        <span class="cov0" title="0">var assignedTasks []*types.Task
        for _, task := range allTasks </span><span class="cov0" title="0">{
                if task.AssignedAgent != nil &amp;&amp; *task.AssignedAgent == agentID </span><span class="cov0" title="0">{
                        assignedTasks = append(assignedTasks, task)
                }</span>
        }

        <span class="cov0" title="0">return assignedTasks, nil</span>
}

// ListUnassignedTasks returns all tasks that have no agent assigned in a project
func (s *service) ListUnassignedTasks(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        // Validate project exists
        if _, err := s.repo.GetProject(ctx, projectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project not found: %w", err)
        }</span>

        // Get all tasks in the project
        <span class="cov0" title="0">allTasks, err := s.repo.GetTasksByProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get project tasks: %w", err)
        }</span>

        // Filter tasks with no agent assignment
        <span class="cov0" title="0">var unassignedTasks []*types.Task
        for _, task := range allTasks </span><span class="cov0" title="0">{
                if task.AssignedAgent == nil </span><span class="cov0" title="0">{
                        unassignedTasks = append(unassignedTasks, task)
                }</span>
        }

        <span class="cov0" title="0">return unassignedTasks, nil</span>
}

func (s *service) FindNextActionableTask(ctx context.Context, projectID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        // Validate project exists
        if _, err := s.repo.GetProject(ctx, projectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project not found: %w", err)
        }</span>

        // Get all tasks in the project
        <span class="cov0" title="0">allTasks, err := s.repo.GetTasksByProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get project tasks: %w", err)
        }</span>

        // Create a map of task IDs to tasks for quick lookup
        <span class="cov0" title="0">taskMap := make(map[uuid.UUID]*types.Task)
        for _, task := range allTasks </span><span class="cov0" title="0">{
                taskMap[task.ID] = task
        }</span>

        // Separate tasks by state
        <span class="cov0" title="0">var pendingTasks, inProgressTasks []*types.Task
        for _, task := range allTasks </span><span class="cov0" title="0">{
                switch task.State </span>{
                case types.TaskStatePending:<span class="cov0" title="0">
                        pendingTasks = append(pendingTasks, task)</span>
                case types.TaskStateInProgress:<span class="cov0" title="0">
                        inProgressTasks = append(inProgressTasks, task)</span>
                }
        }

        // Prioritize in-progress tasks first
        <span class="cov0" title="0">if len(inProgressTasks) &gt; 0 </span><span class="cov0" title="0">{
                // For in-progress tasks, find one that has all its dependencies met
                for _, task := range inProgressTasks </span><span class="cov0" title="0">{
                        if s.areDependenciesMet(task, taskMap) </span><span class="cov0" title="0">{
                                return task, nil
                        }</span>
                }
                // If no in-progress task has its dependencies met, this indicates an inconsistency
                // Since we prevent circular dependencies and should maintain data integrity,
                // this should not happen. We'll return an error to highlight the issue.
                <span class="cov0" title="0">return nil, fmt.Errorf("in-progress tasks exist but none have all dependencies met - possible data inconsistency")</span>
        }

        // For pending tasks, find one that has all its dependencies met
        <span class="cov0" title="0">for _, task := range pendingTasks </span><span class="cov0" title="0">{
                if s.areDependenciesMet(task, taskMap) </span><span class="cov0" title="0">{
                        return task, nil
                }</span>
        }

        // If we reach here, it means either:
        // 1. There are no pending or in-progress tasks
        // 2. All pending tasks have unmet dependencies (potential deadlock scenario)
        // Since we prevent circular dependencies, case 2 suggests a logical error in task setup
        <span class="cov0" title="0">if len(pendingTasks) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pending tasks exist but none have all dependencies met - possible deadlock scenario")
        }</span>

        // No actionable tasks found
        <span class="cov0" title="0">return nil, fmt.Errorf("no actionable tasks found")</span>
}

// areDependenciesMet checks if all dependencies of a task are completed
func (s *service) areDependenciesMet(task *types.Task, taskMap map[uuid.UUID]*types.Task) bool <span class="cov0" title="0">{
        for _, depID := range task.Dependencies </span><span class="cov0" title="0">{
                depTask, exists := taskMap[depID]
                if !exists || depTask.State != types.TaskStateCompleted </span><span class="cov0" title="0">{
                        // If a dependency doesn't exist or isn't completed, the dependencies aren't met
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (s *service) FindTasksNeedingBreakdown(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        // Validate project exists
        if _, err := s.repo.GetProject(ctx, projectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project not found: %w", err)
        }</span>

        // Find tasks with complexity above threshold that have no children
        <span class="cov0" title="0">tasks, err := s.repo.GetTasksByProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get project tasks: %w", err)
        }</span>

        <span class="cov0" title="0">var needsBreakdown []*types.Task
        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.Complexity &gt;= s.config.ComplexityThreshold </span><span class="cov0" title="0">{
                        // Check if task has children
                        children, err := s.repo.GetTasksByParent(ctx, task.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to check task children: %w", err)
                        }</span>
                        <span class="cov0" title="0">if len(children) == 0 </span><span class="cov0" title="0">{
                                needsBreakdown = append(needsBreakdown, task)
                        }</span>
                }
        }

        <span class="cov0" title="0">return needsBreakdown, nil</span>
}

func (s *service) GetProjectProgress(ctx context.Context, projectID uuid.UUID) (*types.ProjectProgress, error) <span class="cov0" title="0">{
        // Validate project exists
        if _, err := s.repo.GetProject(ctx, projectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project not found: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.GetProjectProgress(ctx, projectID)</span>
}

func (s *service) ListTasksByState(ctx context.Context, projectID uuid.UUID, state types.TaskState) ([]*types.Task, error) <span class="cov0" title="0">{
        // Validate project exists
        if _, err := s.repo.GetProject(ctx, projectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project not found: %w", err)
        }</span>

        <span class="cov0" title="0">return s.repo.ListTasks(ctx, types.TaskFilter{
                ProjectID: &amp;projectID,
                State:     &amp;state,
        })</span>
}

// Validation helpers

func (s *service) validateProjectInput(title, description string) error <span class="cov8" title="1">{
        if title == "" </span><span class="cov0" title="0">{
                return errors.New("title cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(title) &gt; 200 </span><span class="cov0" title="0">{
                return errors.New("title cannot exceed 200 characters")
        }</span>
        <span class="cov8" title="1">if len(description) &gt; s.config.MaxDescriptionLength </span><span class="cov0" title="0">{
                return fmt.Errorf("description cannot exceed %d characters", s.config.MaxDescriptionLength)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *service) validateTaskInput(title, description string, complexity int) error <span class="cov8" title="1">{
        if title == "" </span><span class="cov8" title="1">{
                return errors.New("title cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(title) &gt; 200 </span><span class="cov8" title="1">{
                return errors.New("title cannot exceed 200 characters")
        }</span>
        <span class="cov8" title="1">if len(description) &gt; s.config.MaxDescriptionLength </span><span class="cov8" title="1">{
                return fmt.Errorf("description cannot exceed %d characters", s.config.MaxDescriptionLength)
        }</span>
        <span class="cov8" title="1">if complexity &lt; 1 || complexity &gt; 10 </span><span class="cov8" title="1">{
                return errors.New("complexity must be between 1 and 10")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Config management

func (s *service) GetConfig() *Config <span class="cov0" title="0">{
        return s.config
}</span>

func (s *service) UpdateConfig(config *Config) <span class="cov0" title="0">{
        if config != nil </span><span class="cov0" title="0">{
                s.config = config
        }</span>
}

// LoadConfigFromFile loads configuration from .knot/config.json
func (s *service) LoadConfigFromFile() error <span class="cov0" title="0">{
        // Import here to avoid circular dependency
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If config file doesn't exist, keep current config
        <span class="cov0" title="0">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // No error, just use current config
        }</span>

        // Read and parse config file
        <span class="cov0" title="0">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Validate and update config
        <span class="cov0" title="0">if err := validateConfig(&amp;config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov0" title="0">s.config = &amp;config
        return nil</span>
}

// SaveConfigToFile saves current configuration to .knot/config.json
func (s *service) SaveConfigToFile() error <span class="cov0" title="0">{
        if err := validateConfig(s.config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov0" title="0">configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Ensure .knot directory exists
        <span class="cov0" title="0">knotDir := filepath.Dir(configPath)
        if err := os.MkdirAll(knotDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Marshal config to JSON
        <span class="cov0" title="0">data, err := json.MarshalIndent(s.config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Write config file
        <span class="cov0" title="0">if err := os.WriteFile(configPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddTaskDependency adds a dependency between tasks
func (s *service) AddTaskDependency(ctx context.Context, taskID uuid.UUID, dependsOnTaskID uuid.UUID, actor string) (*types.Task, error) <span class="cov8" title="1">{
        return s.repo.AddTaskDependency(ctx, taskID, dependsOnTaskID)
}</span>

// RemoveTaskDependency removes a dependency between tasks
func (s *service) RemoveTaskDependency(ctx context.Context, taskID uuid.UUID, dependsOnTaskID uuid.UUID, actor string) (*types.Task, error) <span class="cov8" title="1">{
        return s.repo.RemoveTaskDependency(ctx, taskID, dependsOnTaskID)
}</span>

// GetTaskDependencies gets all tasks that the given task depends on
func (s *service) GetTaskDependencies(ctx context.Context, taskID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        return s.repo.GetTaskDependencies(ctx, taskID)
}</span>

// GetDependentTasks gets all tasks that depend on the given task
func (s *service) GetDependentTasks(ctx context.Context, taskID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        return s.repo.GetDependentTasks(ctx, taskID)
}</span>

// Helper functions for config file management

// getConfigPath returns the path to the knot configuration file
func getConfigPath() (string, error) <span class="cov0" title="0">{
        // Use .knot directory for configuration (same as database)
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current working directory: %w", err)
        }</span>

        <span class="cov0" title="0">knotDir := filepath.Join(cwd, ".knot")
        configPath := filepath.Join(knotDir, "config.json")
        return configPath, nil</span>
}

// validateConfig checks if the configuration values are valid
func validateConfig(c *Config) error <span class="cov0" title="0">{
        if c.MaxTasksPerDepth &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("max_tasks_per_depth must be at least 1, got %d", c.MaxTasksPerDepth)
        }</span>
        <span class="cov0" title="0">if c.ComplexityThreshold &lt; 1 || c.ComplexityThreshold &gt; 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("complexity_threshold must be between 1 and 10, got %d", c.ComplexityThreshold)
        }</span>
        <span class="cov0" title="0">if c.MaxDepth &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("max_depth must be at least 1, got %d", c.MaxDepth)
        }</span>
        <span class="cov0" title="0">if c.MaxDescriptionLength &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("max_description_length must be at least 1, got %d", c.MaxDescriptionLength)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// autoReduceParentComplexity reduces parent task complexity when subtasks are added
func (s *service) autoReduceParentComplexity(ctx context.Context, parentID uuid.UUID) error <span class="cov8" title="1">{
        // Get parent task
        parentTask, err := s.repo.GetTask(ctx, parentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get parent task: %w", err)
        }</span>

        // Only reduce if parent complexity is above threshold
        <span class="cov8" title="1">if parentTask.Complexity &lt; s.config.ComplexityThreshold </span><span class="cov8" title="1">{
                return nil // No need to reduce
        }</span>

        // Get all children to determine new complexity
        <span class="cov0" title="0">children, err := s.repo.GetTasksByParent(ctx, parentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get child tasks: %w", err)
        }</span>

        // Calculate new complexity based on number of children
        // Logic: High complexity tasks become coordination tasks when broken down
        <span class="cov0" title="0">var newComplexity int
        childCount := len(children)

        switch </span>{
        case childCount == 1:<span class="cov0" title="0">
                // First subtask: reduce by 2 (e.g., 9 -&gt; 7)
                newComplexity = parentTask.Complexity - 2</span>
        case childCount &lt;= 3:<span class="cov0" title="0">
                // 2-3 subtasks: reduce to coordination level (complexity 4-5)
                newComplexity = 4</span>
        case childCount &lt;= 5:<span class="cov0" title="0">
                // 4-5 subtasks: well-broken down, reduce to oversight level (complexity 3)
                newComplexity = 3</span>
        default:<span class="cov0" title="0">
                // Many subtasks: very well broken down, minimal coordination (complexity 2)
                newComplexity = 2</span>
        }

        // Ensure complexity doesn't go below 1
        <span class="cov0" title="0">if newComplexity &lt; 1 </span><span class="cov0" title="0">{
                newComplexity = 1
        }</span>

        // Only update if complexity actually changed
        <span class="cov0" title="0">if newComplexity != parentTask.Complexity </span><span class="cov0" title="0">{
                parentTask.Complexity = newComplexity
                if err := s.repo.UpdateTask(ctx, parentTask); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update parent task complexity: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Auto-reduced parent task complexity: %s (ID: %s) %d -&gt; %d (based on %d subtasks)\n",
                        parentTask.Title, parentTask.ID, parentTask.Complexity+2, newComplexity, childCount)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// State validation functions

// isValidTaskStateTransition checks if a task state transition is valid
func isValidTaskStateTransition(from, to types.TaskState) bool <span class="cov8" title="1">{
        // Define valid transitions
        validTransitions := map[types.TaskState][]types.TaskState{
                types.TaskStatePending: {
                        types.TaskStateInProgress,
                        types.TaskStateBlocked,
                        types.TaskStateCancelled,
                        types.TaskStateDeletionPending,
                },
                types.TaskStateInProgress: {
                        types.TaskStateCompleted,
                        types.TaskStateBlocked,
                        types.TaskStateCancelled,
                        types.TaskStateDeletionPending,
                },
                types.TaskStateBlocked: {
                        types.TaskStatePending,
                        types.TaskStateInProgress,
                        types.TaskStateCancelled,
                        types.TaskStateDeletionPending,
                },
                types.TaskStateCompleted: {
                        types.TaskStateDeletionPending,
                        // Generally, completed tasks shouldn't transition back, but allow for corrections
                },
                types.TaskStateCancelled: {
                        types.TaskStatePending,
                        types.TaskStateDeletionPending,
                },
                types.TaskStateDeletionPending: {
                        // No transitions allowed from deletion pending
                },
        }

        // Allow staying in the same state
        if from == to </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if transition is in the valid list
        <span class="cov8" title="1">allowedStates, exists := validTransitions[from]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, allowedState := range allowedStates </span><span class="cov8" title="1">{
                if to == allowedState </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// isValidProjectStateTransition checks if a project state transition is valid
func isValidProjectStateTransition(from, to types.ProjectState) bool <span class="cov0" title="0">{
        // Define valid transitions
        validTransitions := map[types.ProjectState][]types.ProjectState{
                types.ProjectStateActive: {
                        types.ProjectStateCompleted,
                        types.ProjectStateArchived,
                        types.ProjectStateDeletionPending,
                },
                types.ProjectStateCompleted: {
                        types.ProjectStateArchived,
                        types.ProjectStateDeletionPending,
                        types.ProjectStateActive, // Allow reopening completed projects
                },
                types.ProjectStateArchived: {
                        types.ProjectStateActive, // Allow unarchiving
                        types.ProjectStateDeletionPending,
                },
                types.ProjectStateDeletionPending: {
                        // No transitions allowed from deletion pending
                },
        }

        // Allow staying in the same state
        if from == to </span><span class="cov0" title="0">{
                return true
        }</span>

        // Handle empty/initial state - allow transition to active or completed
        <span class="cov0" title="0">if from == "" &amp;&amp; (to == types.ProjectStateActive || to == types.ProjectStateCompleted) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if transition is in the valid list
        <span class="cov0" title="0">allowedStates, exists := validTransitions[from]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, allowedState := range allowedStates </span><span class="cov0" title="0">{
                if to == allowedState </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// Project context management methods

// GetSelectedProject retrieves the currently selected project ID
func (s *service) GetSelectedProject(ctx context.Context) (*uuid.UUID, error) <span class="cov8" title="1">{
        return s.repo.GetSelectedProject(ctx)
}</span>

// SetSelectedProject sets the currently selected project ID
func (s *service) SetSelectedProject(ctx context.Context, projectID uuid.UUID, actor string) error <span class="cov8" title="1">{
        return s.repo.SetSelectedProject(ctx, projectID, actor)
}</span>

// ClearSelectedProject removes the currently selected project
func (s *service) ClearSelectedProject(ctx context.Context) error <span class="cov8" title="1">{
        return s.repo.ClearSelectedProject(ctx)
}</span>

// HasSelectedProject checks if there is a currently selected project
func (s *service) HasSelectedProject(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        return s.repo.HasSelectedProject(ctx)
}</span>

// GetCurrentTime returns the current time
func (s *service) GetCurrentTime() time.Time <span class="cov0" title="0">{
        return time.Now()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package inmemory

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
)

// simpleMemoryRepository implements Repository interface with simple in-memory storage
type simpleMemoryRepository struct {
        mu                sync.RWMutex
        projects          map[uuid.UUID]*types.Project
        tasks             map[uuid.UUID]*types.Task
        tasksByProject    map[uuid.UUID][]uuid.UUID
        tasksByParent     map[uuid.UUID][]uuid.UUID
        taskDependencies  map[uuid.UUID][]uuid.UUID // taskID -&gt; list of dependency taskIDs
        selectedProjectID *uuid.UUID                 // Currently selected project
}

// NewMemoryRepository creates a new in-memory repository
func NewMemoryRepository() types.Repository <span class="cov0" title="0">{
        return &amp;simpleMemoryRepository{
                projects:          make(map[uuid.UUID]*types.Project),
                tasks:             make(map[uuid.UUID]*types.Task),
                tasksByProject:    make(map[uuid.UUID][]uuid.UUID),
                tasksByParent:     make(map[uuid.UUID][]uuid.UUID),
                taskDependencies:  make(map[uuid.UUID][]uuid.UUID),
                selectedProjectID: nil,
        }
}</span>

// Project operations
func (r *simpleMemoryRepository) CreateProject(ctx context.Context, project *types.Project) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if project.ID == uuid.Nil </span><span class="cov0" title="0">{
                project.ID = uuid.New()
        }</span>
        <span class="cov0" title="0">project.CreatedAt = time.Now()
        project.UpdatedAt = time.Now()

        r.projects[project.ID] = project
        return nil</span>
}

func (r *simpleMemoryRepository) GetProject(ctx context.Context, id uuid.UUID) (*types.Project, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        project, exists := r.projects[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project not found")
        }</span>
        <span class="cov0" title="0">return project, nil</span>
}

func (r *simpleMemoryRepository) UpdateProject(ctx context.Context, project *types.Project) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.projects[project.ID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("project not found")
        }</span>

        <span class="cov0" title="0">project.UpdatedAt = time.Now()
        r.projects[project.ID] = project
        return nil</span>
}

func (r *simpleMemoryRepository) DeleteProject(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.projects[id]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("project not found")
        }</span>

        // Clear project selection if this project is currently selected
        <span class="cov0" title="0">if r.selectedProjectID != nil &amp;&amp; *r.selectedProjectID == id </span><span class="cov0" title="0">{
                r.selectedProjectID = nil
        }</span>

        <span class="cov0" title="0">delete(r.projects, id)
        delete(r.tasksByProject, id)
        return nil</span>
}

func (r *simpleMemoryRepository) ListProjects(ctx context.Context) ([]*types.Project, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        projects := make([]*types.Project, 0, len(r.projects))
        for _, project := range r.projects </span><span class="cov0" title="0">{
                projects = append(projects, project)
        }</span>
        <span class="cov0" title="0">return projects, nil</span>
}

// Task operations
func (r *simpleMemoryRepository) CreateTask(ctx context.Context, task *types.Task) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if task.ID == uuid.Nil </span><span class="cov0" title="0">{
                task.ID = uuid.New()
        }</span>
        <span class="cov0" title="0">task.CreatedAt = time.Now()
        task.UpdatedAt = time.Now()

        r.tasks[task.ID] = task
        
        // Add to project tasks
        r.tasksByProject[task.ProjectID] = append(r.tasksByProject[task.ProjectID], task.ID)
        
        // Add to parent tasks if applicable
        if task.ParentID != nil </span><span class="cov0" title="0">{
                r.tasksByParent[*task.ParentID] = append(r.tasksByParent[*task.ParentID], task.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *simpleMemoryRepository) GetTask(ctx context.Context, id uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        task, exists := r.tasks[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task not found")
        }</span>
        <span class="cov0" title="0">return task, nil</span>
}

func (r *simpleMemoryRepository) UpdateTask(ctx context.Context, task *types.Task) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.tasks[task.ID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task not found")
        }</span>

        <span class="cov0" title="0">task.UpdatedAt = time.Now()
        r.tasks[task.ID] = task
        return nil</span>
}

func (r *simpleMemoryRepository) DeleteTask(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        task, exists := r.tasks[id]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task not found")
        }</span>

        <span class="cov0" title="0">delete(r.tasks, id)
        
        // Remove from project tasks
        if projectTasks, exists := r.tasksByProject[task.ProjectID]; exists </span><span class="cov0" title="0">{
                for i, taskID := range projectTasks </span><span class="cov0" title="0">{
                        if taskID == id </span><span class="cov0" title="0">{
                                r.tasksByProject[task.ProjectID] = append(projectTasks[:i], projectTasks[i+1:]...)
                                break</span>
                        }
                }
        }

        // Remove from parent tasks if applicable
        <span class="cov0" title="0">if task.ParentID != nil </span><span class="cov0" title="0">{
                if parentTasks, exists := r.tasksByParent[*task.ParentID]; exists </span><span class="cov0" title="0">{
                        for i, taskID := range parentTasks </span><span class="cov0" title="0">{
                                if taskID == id </span><span class="cov0" title="0">{
                                        r.tasksByParent[*task.ParentID] = append(parentTasks[:i], parentTasks[i+1:]...)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Task queries
func (r *simpleMemoryRepository) ListTasks(ctx context.Context, filter types.TaskFilter) ([]*types.Task, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        var tasks []*types.Task
        for _, task := range r.tasks </span><span class="cov0" title="0">{
                if r.matchesFilter(task, filter) </span><span class="cov0" title="0">{
                        tasks = append(tasks, task)
                }</span>
        }
        <span class="cov0" title="0">return tasks, nil</span>
}

func (r *simpleMemoryRepository) GetTasksByProject(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        taskIDs, exists := r.tasksByProject[projectID]
        if !exists </span><span class="cov0" title="0">{
                return []*types.Task{}, nil
        }</span>

        <span class="cov0" title="0">tasks := make([]*types.Task, 0, len(taskIDs))
        for _, taskID := range taskIDs </span><span class="cov0" title="0">{
                if task, exists := r.tasks[taskID]; exists </span><span class="cov0" title="0">{
                        tasks = append(tasks, task)
                }</span>
        }
        <span class="cov0" title="0">return tasks, nil</span>
}

func (r *simpleMemoryRepository) GetTasksByParent(ctx context.Context, parentID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        taskIDs, exists := r.tasksByParent[parentID]
        if !exists </span><span class="cov0" title="0">{
                return []*types.Task{}, nil
        }</span>

        <span class="cov0" title="0">tasks := make([]*types.Task, 0, len(taskIDs))
        for _, taskID := range taskIDs </span><span class="cov0" title="0">{
                if task, exists := r.tasks[taskID]; exists </span><span class="cov0" title="0">{
                        tasks = append(tasks, task)
                }</span>
        }
        <span class="cov0" title="0">return tasks, nil</span>
}

func (r *simpleMemoryRepository) GetRootTasks(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        tasks, err := r.GetTasksByProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var rootTasks []*types.Task
        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.ParentID == nil </span><span class="cov0" title="0">{
                        rootTasks = append(rootTasks, task)
                }</span>
        }
        <span class="cov0" title="0">return rootTasks, nil</span>
}

func (r *simpleMemoryRepository) GetParentTask(ctx context.Context, taskID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        task, err := r.GetTask(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if task.ParentID == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task has no parent")
        }</span>

        <span class="cov0" title="0">return r.GetTask(ctx, *task.ParentID)</span>
}

// Hierarchy operations
func (r *simpleMemoryRepository) DeleteTaskSubtree(ctx context.Context, taskID uuid.UUID) error <span class="cov0" title="0">{
        // Get all child tasks recursively
        childTasks, err := r.GetTasksByParent(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete all children first
        <span class="cov0" title="0">for _, child := range childTasks </span><span class="cov0" title="0">{
                if err := r.DeleteTaskSubtree(ctx, child.ID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Delete the task itself
        <span class="cov0" title="0">return r.DeleteTask(ctx, taskID)</span>
}

// Dependency management
func (r *simpleMemoryRepository) AddTaskDependency(ctx context.Context, taskID uuid.UUID, dependsOnTaskID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Verify both tasks exist
        task, exists := r.tasks[taskID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task not found")
        }</span>
        
        <span class="cov0" title="0">if _, exists := r.tasks[dependsOnTaskID]; !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependency task not found")
        }</span>

        // Add dependency
        <span class="cov0" title="0">deps := r.taskDependencies[taskID]
        for _, dep := range deps </span><span class="cov0" title="0">{
                if dep == dependsOnTaskID </span><span class="cov0" title="0">{
                        return task, nil // Already exists
                }</span>
        }
        
        <span class="cov0" title="0">r.taskDependencies[taskID] = append(deps, dependsOnTaskID)
        
        // Update task dependencies slice
        task.Dependencies = r.taskDependencies[taskID]
        r.tasks[taskID] = task
        
        return task, nil</span>
}

func (r *simpleMemoryRepository) RemoveTaskDependency(ctx context.Context, taskID uuid.UUID, dependsOnTaskID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        task, exists := r.tasks[taskID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("task not found")
        }</span>

        <span class="cov0" title="0">deps := r.taskDependencies[taskID]
        for i, dep := range deps </span><span class="cov0" title="0">{
                if dep == dependsOnTaskID </span><span class="cov0" title="0">{
                        r.taskDependencies[taskID] = append(deps[:i], deps[i+1:]...)
                        break</span>
                }
        }
        
        // Update task dependencies slice
        <span class="cov0" title="0">task.Dependencies = r.taskDependencies[taskID]
        r.tasks[taskID] = task
        
        return task, nil</span>
}

func (r *simpleMemoryRepository) GetTaskDependencies(ctx context.Context, taskID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        deps := r.taskDependencies[taskID]
        tasks := make([]*types.Task, 0, len(deps))
        
        for _, depID := range deps </span><span class="cov0" title="0">{
                if task, exists := r.tasks[depID]; exists </span><span class="cov0" title="0">{
                        tasks = append(tasks, task)
                }</span>
        }
        
        <span class="cov0" title="0">return tasks, nil</span>
}

func (r *simpleMemoryRepository) GetDependentTasks(ctx context.Context, taskID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        var dependents []*types.Task
        
        for otherTaskID, deps := range r.taskDependencies </span><span class="cov0" title="0">{
                for _, depID := range deps </span><span class="cov0" title="0">{
                        if depID == taskID </span><span class="cov0" title="0">{
                                if task, exists := r.tasks[otherTaskID]; exists </span><span class="cov0" title="0">{
                                        dependents = append(dependents, task)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return dependents, nil</span>
}

// Metrics and analysis
func (r *simpleMemoryRepository) GetProjectProgress(ctx context.Context, projectID uuid.UUID) (*types.ProjectProgress, error) <span class="cov0" title="0">{
        tasks, err := r.GetTasksByProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">progress := &amp;types.ProjectProgress{
                ProjectID:    projectID,
                TotalTasks:   len(tasks),
                TasksByDepth: make(map[int]int),
        }

        for _, task := range tasks </span><span class="cov0" title="0">{
                progress.TasksByDepth[task.Depth]++
                
                switch task.State </span>{
                case types.TaskStateCompleted:<span class="cov0" title="0">
                        progress.CompletedTasks++</span>
                case types.TaskStateInProgress:<span class="cov0" title="0">
                        progress.InProgressTasks++</span>
                case types.TaskStatePending:<span class="cov0" title="0">
                        progress.PendingTasks++</span>
                case types.TaskStateBlocked:<span class="cov0" title="0">
                        progress.BlockedTasks++</span>
                case types.TaskStateCancelled:<span class="cov0" title="0">
                        progress.CancelledTasks++</span>
                }
        }

        <span class="cov0" title="0">if progress.TotalTasks &gt; 0 </span><span class="cov0" title="0">{
                progress.OverallProgress = float64(progress.CompletedTasks) / float64(progress.TotalTasks) * 100
        }</span>

        <span class="cov0" title="0">return progress, nil</span>
}

func (r *simpleMemoryRepository) GetTaskCountByDepth(ctx context.Context, projectID uuid.UUID, maxDepth int) (map[int]int, error) <span class="cov0" title="0">{
        tasks, err := r.GetTasksByProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">counts := make(map[int]int)
        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.Depth &lt;= maxDepth </span><span class="cov0" title="0">{
                        counts[task.Depth]++
                }</span>
        }

        <span class="cov0" title="0">return counts, nil</span>
}

// Project context management methods

// GetSelectedProject retrieves the currently selected project ID
func (r *simpleMemoryRepository) GetSelectedProject(ctx context.Context) (*uuid.UUID, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        
        if r.selectedProjectID == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        
        // Return a copy to avoid mutation
        <span class="cov0" title="0">projectID := *r.selectedProjectID
        return &amp;projectID, nil</span>
}

// SetSelectedProject sets the currently selected project ID
func (r *simpleMemoryRepository) SetSelectedProject(ctx context.Context, projectID uuid.UUID, actor string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        
        // Verify project exists
        if _, exists := r.projects[projectID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("project with ID %s does not exist", projectID)
        }</span>
        
        <span class="cov0" title="0">r.selectedProjectID = &amp;projectID
        return nil</span>
}

// ClearSelectedProject removes the currently selected project
func (r *simpleMemoryRepository) ClearSelectedProject(ctx context.Context) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        
        r.selectedProjectID = nil
        return nil
}</span>

// HasSelectedProject checks if there is a currently selected project
func (r *simpleMemoryRepository) HasSelectedProject(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        
        return r.selectedProjectID != nil, nil
}</span>

// Helper function to match tasks against filter
func (r *simpleMemoryRepository) matchesFilter(task *types.Task, filter types.TaskFilter) bool <span class="cov0" title="0">{
        if filter.ProjectID != nil &amp;&amp; task.ProjectID != *filter.ProjectID </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if filter.ParentID != nil </span><span class="cov0" title="0">{
                if task.ParentID == nil || *task.ParentID != *filter.ParentID </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">if filter.State != nil &amp;&amp; task.State != *filter.State </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if filter.MinDepth != nil &amp;&amp; task.Depth &lt; *filter.MinDepth </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if filter.MaxDepth != nil &amp;&amp; task.Depth &gt; *filter.MaxDepth </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if filter.MinComplexity != nil &amp;&amp; task.Complexity &lt; *filter.MinComplexity </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if filter.MaxComplexity != nil &amp;&amp; task.Complexity &gt; *filter.MaxComplexity </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}</pre>
		
		<pre class="file" id="file28" style="display: none">package sqlite

import (
        "fmt"
        "os"
        "path/filepath"
)

const (
        ProjectDirName    = ".knot"
        DatabaseName      = "knot.db"
        LegacyDatabaseName = "projects.db"
)

// GetProjectDir returns the .knot directory path in the current working directory
func GetProjectDir() (string, error) <span class="cov8" title="1">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current working directory: %w", err)
        }</span>
        
        <span class="cov8" title="1">projectDir := filepath.Join(cwd, ProjectDirName)
        return projectDir, nil</span>
}

// EnsureProjectDir creates the .knot directory if it doesn't exist
func EnsureProjectDir() (string, error) <span class="cov8" title="1">{
        projectDir, err := GetProjectDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        // Create directory if it doesn't exist
        <span class="cov8" title="1">if err := os.MkdirAll(projectDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create project directory: %w", err)
        }</span>
        
        <span class="cov8" title="1">return projectDir, nil</span>
}

// GetDatabasePath returns the full path to the SQLite database file
// Automatically migrates legacy projects.db to knot.db if found
func GetDatabasePath() (string, error) <span class="cov8" title="1">{
        projectDir, err := EnsureProjectDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov8" title="1">dbPath := filepath.Join(projectDir, DatabaseName)
        legacyDbPath := filepath.Join(projectDir, LegacyDatabaseName)
        
        // Check if legacy database exists and current doesn't
        if _, err := os.Stat(legacyDbPath); err == nil </span><span class="cov0" title="0">{
                if _, err := os.Stat(dbPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // Migrate legacy database to new name
                        if err := os.Rename(legacyDbPath, dbPath); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to migrate legacy database from %s to %s: %w", 
                                        LegacyDatabaseName, DatabaseName, err)
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return dbPath, nil</span>
}

// GetSQLiteConnectionString returns the SQLite connection string
func GetSQLiteConnectionString() (string, error) <span class="cov8" title="1">{
        dbPath, err := GetDatabasePath()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        // SQLite connection string - simple path format
        <span class="cov8" title="1">return dbPath, nil</span>
}</pre>
		
		<pre class="file" id="file29" style="display: none">package sqlite

import (
        "context"
        "fmt"

        "github.com/denkhaus/knot/internal/repository/sqlite/ent"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
        "github.com/google/uuid"
        "go.uber.org/zap"
)

// GetSelectedProject retrieves the currently selected project ID from the database
func (r *sqliteRepository) GetSelectedProject(ctx context.Context) (*uuid.UUID, error) <span class="cov0" title="0">{
        r.logger.Debug("Getting selected project from database")

        // Query the singleton project context record
        pc, err := r.client.ProjectContext.Query().
                Where(projectcontext.IDEQ(1)).
                Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                        r.logger.Debug("No project context found")
                        return nil, nil
                }</span>
                <span class="cov0" title="0">r.logger.Error("Failed to query project context", zap.Error(err))
                return nil, fmt.Errorf("failed to get selected project: %w", err)</span>
        }

        <span class="cov0" title="0">r.logger.Debug("Retrieved selected project", zap.String("projectID", pc.SelectedProjectID.String()))
        return &amp;pc.SelectedProjectID, nil</span>
}

// SetSelectedProject sets the currently selected project ID in the database
func (r *sqliteRepository) SetSelectedProject(ctx context.Context, projectID uuid.UUID, actor string) error <span class="cov0" title="0">{
        r.logger.Debug("Setting selected project in database", 
                zap.String("projectID", projectID.String()),
                zap.String("actor", actor))

        // First verify the project exists
        exists, err := r.client.Project.Query().
                Where(project.IDEQ(projectID)).
                Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to check if project exists", zap.Error(err))
                return fmt.Errorf("failed to verify project exists: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("project with ID %s does not exist", projectID)
        }</span>

        // Use upsert pattern - try to update existing record, create if not exists
        // Try to update existing record first
        <span class="cov0" title="0">updated, err := r.client.ProjectContext.Update().
                Where(projectcontext.IDEQ(1)).
                SetSelectedProjectID(projectID).
                SetUpdatedBy(actor).
                Save(ctx)
        
        r.logger.Debug("Update attempt result", zap.Int("updated", updated), zap.Error(err))
        
        if err != nil || updated == 0 </span><span class="cov0" title="0">{
                // Create new record if update failed or no record exists
                r.logger.Debug("Creating new project context record")
                err = r.client.ProjectContext.Create().
                        SetID(1).
                        SetSelectedProjectID(projectID).
                        SetUpdatedBy(actor).
                        Exec(ctx)
                r.logger.Debug("Create attempt result", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to set selected project", zap.Error(err))
                return fmt.Errorf("failed to set selected project: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.Info("Selected project updated", 
                zap.String("projectID", projectID.String()),
                zap.String("actor", actor))
        return nil</span>
}

// ClearSelectedProject removes the currently selected project from the database
func (r *sqliteRepository) ClearSelectedProject(ctx context.Context) error <span class="cov0" title="0">{
        r.logger.Debug("Clearing selected project from database")

        // Delete the singleton record
        _, err := r.client.ProjectContext.Delete().
                Where(projectcontext.IDEQ(1)).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to clear selected project", zap.Error(err))
                return fmt.Errorf("failed to clear selected project: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.Info("Selected project cleared")
        return nil</span>
}

// HasSelectedProject checks if there is a currently selected project
func (r *sqliteRepository) HasSelectedProject(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        r.logger.Debug("Checking if project is selected")

        exists, err := r.client.ProjectContext.Query().
                Where(projectcontext.IDEQ(1)).
                Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to check if project is selected", zap.Error(err))
                return false, fmt.Errorf("failed to check selected project: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.Debug("Project selection status", zap.Bool("hasSelected", exists))
        return exists, nil</span>
}</pre>
		
		<pre class="file" id="file30" style="display: none">package sqlite

import (
        "context"
        "fmt"

        "github.com/denkhaus/knot/internal/repository/sqlite/ent"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
)

// Task Dependency Management Operations

// AddTaskDependency adds a dependency relationship between tasks using ent
func (r *sqliteRepository) AddTaskDependency(ctx context.Context, taskID uuid.UUID, dependsOnTaskID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        var result *types.Task
        err := r.withTx(ctx, func(ctx context.Context, tx *ent.Tx) error </span><span class="cov0" title="0">{
                // Validate both tasks exist and are in the same project
                task, err := tx.Task.Get(ctx, taskID)
                if err != nil </span><span class="cov0" title="0">{
                        if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                                return NewNotFoundError("task", taskID.String())
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get task: %w", err)</span>
                }

                <span class="cov0" title="0">dependsOnTask, err := tx.Task.Get(ctx, dependsOnTaskID)
                if err != nil </span><span class="cov0" title="0">{
                        if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                                return NewNotFoundError("depends on task", dependsOnTaskID.String())
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get depends on task: %w", err)</span>
                }

                <span class="cov0" title="0">if task.ProjectID != dependsOnTask.ProjectID </span><span class="cov0" title="0">{
                        return NewConstraintViolationError("tasks must be in the same project", nil)
                }</span>

                // Check if dependency already exists
                <span class="cov0" title="0">exists, err := tx.TaskDependency.Query().
                        Where(
                                taskdependency.TaskID(taskID),
                                taskdependency.DependsOnTaskID(dependsOnTaskID),
                        ).
                        Exist(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check existing dependency: %w", err)
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        return NewConstraintViolationError("dependency already exists", nil)
                }</span>

                // Check for circular dependencies
                <span class="cov0" title="0">if err := r.hasCircularDependencyInTx(ctx, tx, taskID, dependsOnTaskID, make(map[uuid.UUID]bool)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Create the dependency
                <span class="cov0" title="0">_, err = tx.TaskDependency.Create().
                        SetTaskID(taskID).
                        SetDependsOnTaskID(dependsOnTaskID).
                        Save(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create task dependency: %w", err)
                }</span>

                // Return updated task
                <span class="cov0" title="0">result, err = r.getTaskInTx(ctx, tx, taskID)
                return err</span>
        })
        <span class="cov0" title="0">return result, err</span>
}

// RemoveTaskDependency removes a dependency relationship between tasks using ent
func (r *sqliteRepository) RemoveTaskDependency(ctx context.Context, taskID uuid.UUID, dependsOnTaskID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        var result *types.Task
        err := r.withTx(ctx, func(ctx context.Context, tx *ent.Tx) error </span><span class="cov0" title="0">{
                // Validate task exists
                _, err := tx.Task.Get(ctx, taskID)
                if err != nil </span><span class="cov0" title="0">{
                        if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                                return NewNotFoundError("task", taskID.String())
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get task: %w", err)</span>
                }

                // Delete the dependency
                <span class="cov0" title="0">deletedCount, err := tx.TaskDependency.Delete().
                        Where(
                                taskdependency.TaskID(taskID),
                                taskdependency.DependsOnTaskID(dependsOnTaskID),
                        ).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete task dependency: %w", err)
                }</span>

                <span class="cov0" title="0">if deletedCount == 0 </span><span class="cov0" title="0">{
                        return NewNotFoundError("task dependency", fmt.Sprintf("%s -&gt; %s", taskID, dependsOnTaskID))
                }</span>

                // Return updated task
                <span class="cov0" title="0">result, err = r.getTaskInTx(ctx, tx, taskID)
                return err</span>
        })
        <span class="cov0" title="0">return result, err</span>
}

// GetTaskDependencies retrieves all tasks that the given task depends on using ent
func (r *sqliteRepository) GetTaskDependencies(ctx context.Context, taskID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        // Get dependency task IDs
        dependencyTaskIDs, err := r.client.TaskDependency.Query().
                Where(taskdependency.TaskID(taskID)).
                Select(taskdependency.FieldDependsOnTaskID).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.mapError("get task dependencies", err)
        }</span>

        <span class="cov0" title="0">if len(dependencyTaskIDs) == 0 </span><span class="cov0" title="0">{
                return []*types.Task{}, nil
        }</span>

        // Extract IDs
        <span class="cov0" title="0">ids := make([]uuid.UUID, len(dependencyTaskIDs))
        for i, dep := range dependencyTaskIDs </span><span class="cov0" title="0">{
                ids[i] = dep.DependsOnTaskID
        }</span>

        // Get the actual tasks
        <span class="cov0" title="0">entTasks, err := r.client.Task.Query().
                Where(task.IDIn(ids...)).
                Order(ent.Asc(task.FieldCreatedAt)).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.mapError("get dependency tasks", err)
        }</span>

        <span class="cov0" title="0">tasks := make([]*types.Task, len(entTasks))
        for i, entTask := range entTasks </span><span class="cov0" title="0">{
                tasks[i] = entTaskToTask(entTask)
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

// GetDependentTasks retrieves all tasks that depend on the given task using ent
func (r *sqliteRepository) GetDependentTasks(ctx context.Context, taskID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        // Get dependent task IDs
        dependentTaskIDs, err := r.client.TaskDependency.Query().
                Where(taskdependency.DependsOnTaskID(taskID)).
                Select(taskdependency.FieldTaskID).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.mapError("get dependent task IDs", err)
        }</span>

        <span class="cov0" title="0">if len(dependentTaskIDs) == 0 </span><span class="cov0" title="0">{
                return []*types.Task{}, nil
        }</span>

        // Extract IDs
        <span class="cov0" title="0">ids := make([]uuid.UUID, len(dependentTaskIDs))
        for i, dep := range dependentTaskIDs </span><span class="cov0" title="0">{
                ids[i] = dep.TaskID
        }</span>

        // Get the actual tasks
        <span class="cov0" title="0">entTasks, err := r.client.Task.Query().
                Where(task.IDIn(ids...)).
                Order(ent.Asc(task.FieldCreatedAt)).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.mapError("get dependent tasks", err)
        }</span>

        <span class="cov0" title="0">tasks := make([]*types.Task, len(entTasks))
        for i, entTask := range entTasks </span><span class="cov0" title="0">{
                tasks[i] = entTaskToTask(entTask)
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

// hasCircularDependencyInTx checks if adding a dependency would create a circular dependency
func (r *sqliteRepository) hasCircularDependencyInTx(ctx context.Context, tx *ent.Tx, fromTaskID, toTaskID uuid.UUID, visited map[uuid.UUID]bool) error <span class="cov0" title="0">{
        // If we've reached the original task, we have a cycle
        if toTaskID == fromTaskID </span><span class="cov0" title="0">{
                return NewCircularDependencyError(fmt.Sprintf("circular dependency detected: task %s", fromTaskID))
        }</span>

        // If we've already visited this task, skip it to avoid infinite loops
        <span class="cov0" title="0">if visited[toTaskID] </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">visited[toTaskID] = true

        // Get all tasks that toTaskID depends on
        dependencies, err := tx.TaskDependency.Query().
                Where(taskdependency.TaskID(toTaskID)).
                Select(taskdependency.FieldDependsOnTaskID).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get dependencies for circular check: %w", err)
        }</span>

        // Recursively check each dependency
        <span class="cov0" title="0">for _, dep := range dependencies </span><span class="cov0" title="0">{
                if err := r.hasCircularDependencyInTx(ctx, tx, fromTaskID, dep.DependsOnTaskID, visited); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getTaskInTx retrieves a task within a transaction with all its dependencies
func (r *sqliteRepository) getTaskInTx(ctx context.Context, tx *ent.Tx, taskID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        entTask, err := tx.Task.Query().
                Where(task.ID(taskID)).
                Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, NewNotFoundError("task", taskID.String())
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get task in transaction: %w", err)</span>
        }

        <span class="cov0" title="0">task := entTaskToTask(entTask)

        // Load dependencies
        dependencies, err := tx.TaskDependency.Query().
                Where(taskdependency.TaskID(taskID)).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load dependencies in transaction: %w", err)
        }</span>
        <span class="cov0" title="0">task.Dependencies = entTaskDependenciesToTaskIDs(dependencies)

        // Load dependents
        dependents, err := tx.TaskDependency.Query().
                Where(taskdependency.DependsOnTaskID(taskID)).
                Select(taskdependency.FieldTaskID).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load dependents in transaction: %w", err)
        }</span>
        <span class="cov0" title="0">task.Dependents = entTaskDependentsToTaskIDs(dependents)

        return task, nil</span>
}

// NewCircularDependencyError creates a new circular dependency error
// This function is already defined in errors.go, so this is removed to avoid duplication
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "log"
        "reflect"

        "github.com/denkhaus/knot/internal/repository/sqlite/ent/migrate"
        "github.com/google/uuid"

        "entgo.io/ent"
        "entgo.io/ent/dialect"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
)

// Client is the client that holds all ent builders.
type Client struct {
        config
        // Schema is the client for creating, migrating and dropping schema.
        Schema *migrate.Schema
        // Project is the client for interacting with the Project builders.
        Project *ProjectClient
        // ProjectContext is the client for interacting with the ProjectContext builders.
        ProjectContext *ProjectContextClient
        // Task is the client for interacting with the Task builders.
        Task *TaskClient
        // TaskDependency is the client for interacting with the TaskDependency builders.
        TaskDependency *TaskDependencyClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client <span class="cov0" title="0">{
        client := &amp;Client{config: newConfig(opts...)}
        client.init()
        return client
}</span>

func (c *Client) init() <span class="cov0" title="0">{
        c.Schema = migrate.NewSchema(c.driver)
        c.Project = NewProjectClient(c.config)
        c.ProjectContext = NewProjectContextClient(c.config)
        c.Task = NewTaskClient(c.config)
        c.TaskDependency = NewTaskDependencyClient(c.config)
}</span>

type (
        // config is the configuration for the client and its builder.
        config struct {
                // driver used for executing database requests.
                driver dialect.Driver
                // debug enable a debug logging.
                debug bool
                // log used for logging on debug mode.
                log func(...any)
                // hooks to execute on mutations.
                hooks *hooks
                // interceptors to execute on queries.
                inters *inters
        }
        // Option function to configure the client.
        Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config <span class="cov0" title="0">{
        cfg := config{log: log.Println, hooks: &amp;hooks{}, inters: &amp;inters{}}
        cfg.options(opts...)
        return cfg
}</span>

// options applies the options on the config object.
func (c *config) options(opts ...Option) <span class="cov0" title="0">{
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(c)
        }</span>
        <span class="cov0" title="0">if c.debug </span><span class="cov0" title="0">{
                c.driver = dialect.Debug(c.driver, c.log)
        }</span>
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option <span class="cov0" title="0">{
        return func(c *config) </span><span class="cov0" title="0">{
                c.debug = true
        }</span>
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option <span class="cov0" title="0">{
        return func(c *config) </span><span class="cov0" title="0">{
                c.log = fn
        }</span>
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option <span class="cov0" title="0">{
        return func(c *config) </span><span class="cov0" title="0">{
                c.driver = driver
        }</span>
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) <span class="cov0" title="0">{
        switch driverName </span>{
        case dialect.MySQL, dialect.Postgres, dialect.SQLite:<span class="cov0" title="0">
                drv, err := sql.Open(driverName, dataSourceName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return NewClient(append(options, Driver(drv))...), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported driver: %q", driverName)</span>
        }
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) <span class="cov0" title="0">{
        if _, ok := c.driver.(*txDriver); ok </span><span class="cov0" title="0">{
                return nil, ErrTxStarted
        }</span>
        <span class="cov0" title="0">tx, err := newTx(ctx, c.driver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ent: starting a transaction: %w", err)
        }</span>
        <span class="cov0" title="0">cfg := c.config
        cfg.driver = tx
        return &amp;Tx{
                ctx:            ctx,
                config:         cfg,
                Project:        NewProjectClient(cfg),
                ProjectContext: NewProjectContextClient(cfg),
                Task:           NewTaskClient(cfg),
                TaskDependency: NewTaskDependencyClient(cfg),
        }, nil</span>
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) <span class="cov0" title="0">{
        if _, ok := c.driver.(*txDriver); ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: cannot start a transaction within a transaction")
        }</span>
        <span class="cov0" title="0">tx, err := c.driver.(interface {
                BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
        }).BeginTx(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ent: starting a transaction: %w", err)
        }</span>
        <span class="cov0" title="0">cfg := c.config
        cfg.driver = &amp;txDriver{tx: tx, drv: c.driver}
        return &amp;Tx{
                ctx:            ctx,
                config:         cfg,
                Project:        NewProjectClient(cfg),
                ProjectContext: NewProjectContextClient(cfg),
                Task:           NewTaskClient(cfg),
                TaskDependency: NewTaskDependencyClient(cfg),
        }, nil</span>
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//        client.Debug().
//                Project.
//                Query().
//                Count(ctx)
func (c *Client) Debug() *Client <span class="cov0" title="0">{
        if c.debug </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">cfg := c.config
        cfg.driver = dialect.Debug(c.driver, c.log)
        client := &amp;Client{config: cfg}
        client.init()
        return client</span>
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error <span class="cov0" title="0">{
        return c.driver.Close()
}</span>

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.Project.Use(hooks...)
        c.ProjectContext.Use(hooks...)
        c.Task.Use(hooks...)
        c.TaskDependency.Use(hooks...)
}</span>

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.Project.Intercept(interceptors...)
        c.ProjectContext.Intercept(interceptors...)
        c.Task.Intercept(interceptors...)
        c.TaskDependency.Intercept(interceptors...)
}</span>

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) <span class="cov0" title="0">{
        switch m := m.(type) </span>{
        case *ProjectMutation:<span class="cov0" title="0">
                return c.Project.mutate(ctx, m)</span>
        case *ProjectContextMutation:<span class="cov0" title="0">
                return c.ProjectContext.mutate(ctx, m)</span>
        case *TaskMutation:<span class="cov0" title="0">
                return c.Task.mutate(ctx, m)</span>
        case *TaskDependencyMutation:<span class="cov0" title="0">
                return c.TaskDependency.mutate(ctx, m)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown mutation type %T", m)</span>
        }
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
        config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient <span class="cov0" title="0">{
        return &amp;ProjectClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.Project = append(c.hooks.Project, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.Project = append(c.inters.Project, interceptors...)
}</span>

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate <span class="cov0" title="0">{
        mutation := newProjectMutation(c.config, OpCreate)
        return &amp;ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk <span class="cov0" title="0">{
        return &amp;ProjectCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*ProjectCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;ProjectCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate <span class="cov0" title="0">{
        mutation := newProjectMutation(c.config, OpUpdate)
        return &amp;ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(_m *Project) *ProjectUpdateOne <span class="cov0" title="0">{
        mutation := newProjectMutation(c.config, OpUpdateOne, withProject(_m))
        return &amp;ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id uuid.UUID) *ProjectUpdateOne <span class="cov0" title="0">{
        mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
        return &amp;ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete <span class="cov0" title="0">{
        mutation := newProjectMutation(c.config, OpDelete)
        return &amp;ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(_m *Project) *ProjectDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(_m.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id uuid.UUID) *ProjectDeleteOne <span class="cov0" title="0">{
        builder := c.Delete().Where(project.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;ProjectDeleteOne{builder}
}</span>

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery <span class="cov0" title="0">{
        return &amp;ProjectQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypeProject},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id uuid.UUID) (*Project, error) <span class="cov0" title="0">{
        return c.Query().Where(project.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id uuid.UUID) *Project <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QueryTasks queries the tasks edge of a Project.
func (c *ProjectClient) QueryTasks(_m *Project) *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(project.Table, project.FieldID, id),
                        sqlgraph.To(task.Table, task.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, project.TasksTable, project.TasksColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook <span class="cov0" title="0">{
        return c.hooks.Project
}</span>

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor <span class="cov0" title="0">{
        return c.inters.Project
}</span>

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())</span>
        }
}

// ProjectContextClient is a client for the ProjectContext schema.
type ProjectContextClient struct {
        config
}

// NewProjectContextClient returns a client for the ProjectContext from the given config.
func NewProjectContextClient(c config) *ProjectContextClient <span class="cov0" title="0">{
        return &amp;ProjectContextClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `projectcontext.Hooks(f(g(h())))`.
func (c *ProjectContextClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.ProjectContext = append(c.hooks.ProjectContext, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `projectcontext.Intercept(f(g(h())))`.
func (c *ProjectContextClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.ProjectContext = append(c.inters.ProjectContext, interceptors...)
}</span>

// Create returns a builder for creating a ProjectContext entity.
func (c *ProjectContextClient) Create() *ProjectContextCreate <span class="cov0" title="0">{
        mutation := newProjectContextMutation(c.config, OpCreate)
        return &amp;ProjectContextCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of ProjectContext entities.
func (c *ProjectContextClient) CreateBulk(builders ...*ProjectContextCreate) *ProjectContextCreateBulk <span class="cov0" title="0">{
        return &amp;ProjectContextCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectContextClient) MapCreateBulk(slice any, setFunc func(*ProjectContextCreate, int)) *ProjectContextCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;ProjectContextCreateBulk{err: fmt.Errorf("calling to ProjectContextClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*ProjectContextCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;ProjectContextCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for ProjectContext.
func (c *ProjectContextClient) Update() *ProjectContextUpdate <span class="cov0" title="0">{
        mutation := newProjectContextMutation(c.config, OpUpdate)
        return &amp;ProjectContextUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *ProjectContextClient) UpdateOne(_m *ProjectContext) *ProjectContextUpdateOne <span class="cov0" title="0">{
        mutation := newProjectContextMutation(c.config, OpUpdateOne, withProjectContext(_m))
        return &amp;ProjectContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *ProjectContextClient) UpdateOneID(id int) *ProjectContextUpdateOne <span class="cov0" title="0">{
        mutation := newProjectContextMutation(c.config, OpUpdateOne, withProjectContextID(id))
        return &amp;ProjectContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for ProjectContext.
func (c *ProjectContextClient) Delete() *ProjectContextDelete <span class="cov0" title="0">{
        mutation := newProjectContextMutation(c.config, OpDelete)
        return &amp;ProjectContextDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectContextClient) DeleteOne(_m *ProjectContext) *ProjectContextDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(_m.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectContextClient) DeleteOneID(id int) *ProjectContextDeleteOne <span class="cov0" title="0">{
        builder := c.Delete().Where(projectcontext.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;ProjectContextDeleteOne{builder}
}</span>

// Query returns a query builder for ProjectContext.
func (c *ProjectContextClient) Query() *ProjectContextQuery <span class="cov0" title="0">{
        return &amp;ProjectContextQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypeProjectContext},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a ProjectContext entity by its id.
func (c *ProjectContextClient) Get(ctx context.Context, id int) (*ProjectContext, error) <span class="cov0" title="0">{
        return c.Query().Where(projectcontext.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *ProjectContextClient) GetX(ctx context.Context, id int) *ProjectContext <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QuerySelectedProject queries the selected_project edge of a ProjectContext.
func (c *ProjectContextClient) QuerySelectedProject(_m *ProjectContext) *ProjectQuery <span class="cov0" title="0">{
        query := (&amp;ProjectClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(projectcontext.Table, projectcontext.FieldID, id),
                        sqlgraph.To(project.Table, project.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, false, projectcontext.SelectedProjectTable, projectcontext.SelectedProjectColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// Hooks returns the client hooks.
func (c *ProjectContextClient) Hooks() []Hook <span class="cov0" title="0">{
        return c.hooks.ProjectContext
}</span>

// Interceptors returns the client interceptors.
func (c *ProjectContextClient) Interceptors() []Interceptor <span class="cov0" title="0">{
        return c.inters.ProjectContext
}</span>

func (c *ProjectContextClient) mutate(ctx context.Context, m *ProjectContextMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;ProjectContextCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;ProjectContextUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;ProjectContextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;ProjectContextDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown ProjectContext mutation op: %q", m.Op())</span>
        }
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
        config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient <span class="cov0" title="0">{
        return &amp;TaskClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.Task = append(c.hooks.Task, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.Task = append(c.inters.Task, interceptors...)
}</span>

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate <span class="cov0" title="0">{
        mutation := newTaskMutation(c.config, OpCreate)
        return &amp;TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk <span class="cov0" title="0">{
        return &amp;TaskCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*TaskCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;TaskCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate <span class="cov0" title="0">{
        mutation := newTaskMutation(c.config, OpUpdate)
        return &amp;TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(_m *Task) *TaskUpdateOne <span class="cov0" title="0">{
        mutation := newTaskMutation(c.config, OpUpdateOne, withTask(_m))
        return &amp;TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id uuid.UUID) *TaskUpdateOne <span class="cov0" title="0">{
        mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
        return &amp;TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete <span class="cov0" title="0">{
        mutation := newTaskMutation(c.config, OpDelete)
        return &amp;TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(_m *Task) *TaskDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(_m.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id uuid.UUID) *TaskDeleteOne <span class="cov0" title="0">{
        builder := c.Delete().Where(task.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;TaskDeleteOne{builder}
}</span>

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery <span class="cov0" title="0">{
        return &amp;TaskQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypeTask},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id uuid.UUID) (*Task, error) <span class="cov0" title="0">{
        return c.Query().Where(task.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id uuid.UUID) *Task <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QueryProject queries the project edge of a Task.
func (c *TaskClient) QueryProject(_m *Task) *ProjectQuery <span class="cov0" title="0">{
        query := (&amp;ProjectClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(task.Table, task.FieldID, id),
                        sqlgraph.To(project.Table, project.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, task.ProjectTable, task.ProjectColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// QueryParent queries the parent edge of a Task.
func (c *TaskClient) QueryParent(_m *Task) *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(task.Table, task.FieldID, id),
                        sqlgraph.To(task.Table, task.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, task.ParentTable, task.ParentColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// QueryChildren queries the children edge of a Task.
func (c *TaskClient) QueryChildren(_m *Task) *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(task.Table, task.FieldID, id),
                        sqlgraph.To(task.Table, task.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, task.ChildrenTable, task.ChildrenColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook <span class="cov0" title="0">{
        return c.hooks.Task
}</span>

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor <span class="cov0" title="0">{
        return c.inters.Task
}</span>

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())</span>
        }
}

// TaskDependencyClient is a client for the TaskDependency schema.
type TaskDependencyClient struct {
        config
}

// NewTaskDependencyClient returns a client for the TaskDependency from the given config.
func NewTaskDependencyClient(c config) *TaskDependencyClient <span class="cov0" title="0">{
        return &amp;TaskDependencyClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `taskdependency.Hooks(f(g(h())))`.
func (c *TaskDependencyClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.TaskDependency = append(c.hooks.TaskDependency, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `taskdependency.Intercept(f(g(h())))`.
func (c *TaskDependencyClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.TaskDependency = append(c.inters.TaskDependency, interceptors...)
}</span>

// Create returns a builder for creating a TaskDependency entity.
func (c *TaskDependencyClient) Create() *TaskDependencyCreate <span class="cov0" title="0">{
        mutation := newTaskDependencyMutation(c.config, OpCreate)
        return &amp;TaskDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of TaskDependency entities.
func (c *TaskDependencyClient) CreateBulk(builders ...*TaskDependencyCreate) *TaskDependencyCreateBulk <span class="cov0" title="0">{
        return &amp;TaskDependencyCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskDependencyClient) MapCreateBulk(slice any, setFunc func(*TaskDependencyCreate, int)) *TaskDependencyCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;TaskDependencyCreateBulk{err: fmt.Errorf("calling to TaskDependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*TaskDependencyCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;TaskDependencyCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for TaskDependency.
func (c *TaskDependencyClient) Update() *TaskDependencyUpdate <span class="cov0" title="0">{
        mutation := newTaskDependencyMutation(c.config, OpUpdate)
        return &amp;TaskDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *TaskDependencyClient) UpdateOne(_m *TaskDependency) *TaskDependencyUpdateOne <span class="cov0" title="0">{
        mutation := newTaskDependencyMutation(c.config, OpUpdateOne, withTaskDependency(_m))
        return &amp;TaskDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *TaskDependencyClient) UpdateOneID(id uuid.UUID) *TaskDependencyUpdateOne <span class="cov0" title="0">{
        mutation := newTaskDependencyMutation(c.config, OpUpdateOne, withTaskDependencyID(id))
        return &amp;TaskDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for TaskDependency.
func (c *TaskDependencyClient) Delete() *TaskDependencyDelete <span class="cov0" title="0">{
        mutation := newTaskDependencyMutation(c.config, OpDelete)
        return &amp;TaskDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskDependencyClient) DeleteOne(_m *TaskDependency) *TaskDependencyDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(_m.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskDependencyClient) DeleteOneID(id uuid.UUID) *TaskDependencyDeleteOne <span class="cov0" title="0">{
        builder := c.Delete().Where(taskdependency.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;TaskDependencyDeleteOne{builder}
}</span>

// Query returns a query builder for TaskDependency.
func (c *TaskDependencyClient) Query() *TaskDependencyQuery <span class="cov0" title="0">{
        return &amp;TaskDependencyQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypeTaskDependency},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a TaskDependency entity by its id.
func (c *TaskDependencyClient) Get(ctx context.Context, id uuid.UUID) (*TaskDependency, error) <span class="cov0" title="0">{
        return c.Query().Where(taskdependency.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *TaskDependencyClient) GetX(ctx context.Context, id uuid.UUID) *TaskDependency <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QueryTask queries the task edge of a TaskDependency.
func (c *TaskDependencyClient) QueryTask(_m *TaskDependency) *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(taskdependency.Table, taskdependency.FieldID, id),
                        sqlgraph.To(task.Table, task.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, false, taskdependency.TaskTable, taskdependency.TaskColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// QueryDependsOnTask queries the depends_on_task edge of a TaskDependency.
func (c *TaskDependencyClient) QueryDependsOnTask(_m *TaskDependency) *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov0" title="0">{
                id := _m.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(taskdependency.Table, taskdependency.FieldID, id),
                        sqlgraph.To(task.Table, task.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, false, taskdependency.DependsOnTaskTable, taskdependency.DependsOnTaskColumn),
                )
                fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov0" title="0">return query</span>
}

// Hooks returns the client hooks.
func (c *TaskDependencyClient) Hooks() []Hook <span class="cov0" title="0">{
        return c.hooks.TaskDependency
}</span>

// Interceptors returns the client interceptors.
func (c *TaskDependencyClient) Interceptors() []Interceptor <span class="cov0" title="0">{
        return c.inters.TaskDependency
}</span>

func (c *TaskDependencyClient) mutate(ctx context.Context, m *TaskDependencyMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;TaskDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;TaskDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;TaskDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;TaskDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown TaskDependency mutation op: %q", m.Op())</span>
        }
}

// hooks and interceptors per client, for fast access.
type (
        hooks struct {
                Project, ProjectContext, Task, TaskDependency []ent.Hook
        }
        inters struct {
                Project, ProjectContext, Task, TaskDependency []ent.Interceptor
        }
)
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "reflect"
        "sync"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
)

// ent aliases to avoid import conflicts in user's code.
type (
        Op            = ent.Op
        Hook          = ent.Hook
        Value         = ent.Value
        Query         = ent.Query
        QueryContext  = ent.QueryContext
        Querier       = ent.Querier
        QuerierFunc   = ent.QuerierFunc
        Interceptor   = ent.Interceptor
        InterceptFunc = ent.InterceptFunc
        Traverser     = ent.Traverser
        TraverseFunc  = ent.TraverseFunc
        Policy        = ent.Policy
        Mutator       = ent.Mutator
        Mutation      = ent.Mutation
        MutateFunc    = ent.MutateFunc
)

type clientCtxKey struct{}

// FromContext returns a Client stored inside a context, or nil if there isn't one.
func FromContext(ctx context.Context) *Client <span class="cov0" title="0">{
        c, _ := ctx.Value(clientCtxKey{}).(*Client)
        return c
}</span>

// NewContext returns a new context with the given Client attached.
func NewContext(parent context.Context, c *Client) context.Context <span class="cov0" title="0">{
        return context.WithValue(parent, clientCtxKey{}, c)
}</span>

type txCtxKey struct{}

// TxFromContext returns a Tx stored inside a context, or nil if there isn't one.
func TxFromContext(ctx context.Context) *Tx <span class="cov0" title="0">{
        tx, _ := ctx.Value(txCtxKey{}).(*Tx)
        return tx
}</span>

// NewTxContext returns a new context with the given Tx attached.
func NewTxContext(parent context.Context, tx *Tx) context.Context <span class="cov0" title="0">{
        return context.WithValue(parent, txCtxKey{}, tx)
}</span>

// OrderFunc applies an ordering on the sql selector.
// Deprecated: Use Asc/Desc functions or the package builders instead.
type OrderFunc func(*sql.Selector)

var (
        initCheck   sync.Once
        columnCheck sql.ColumnCheck
)

// checkColumn checks if the column exists in the given table.
func checkColumn(t, c string) error <span class="cov0" title="0">{
        initCheck.Do(func() </span><span class="cov0" title="0">{
                columnCheck = sql.NewColumnCheck(map[string]func(string) bool{
                        project.Table:        project.ValidColumn,
                        projectcontext.Table: projectcontext.ValidColumn,
                        task.Table:           task.ValidColumn,
                        taskdependency.Table: taskdependency.ValidColumn,
                })
        }</span>)
        <span class="cov0" title="0">return columnCheck(t, c)</span>
}

// Asc applies the given fields in ASC order.
func Asc(fields ...string) func(*sql.Selector) <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                for _, f := range fields </span><span class="cov0" title="0">{
                        if err := checkColumn(s.TableName(), f); err != nil </span><span class="cov0" title="0">{
                                s.AddError(&amp;ValidationError{Name: f, err: fmt.Errorf("ent: %w", err)})
                        }</span>
                        <span class="cov0" title="0">s.OrderBy(sql.Asc(s.C(f)))</span>
                }
        }
}

// Desc applies the given fields in DESC order.
func Desc(fields ...string) func(*sql.Selector) <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                for _, f := range fields </span><span class="cov0" title="0">{
                        if err := checkColumn(s.TableName(), f); err != nil </span><span class="cov0" title="0">{
                                s.AddError(&amp;ValidationError{Name: f, err: fmt.Errorf("ent: %w", err)})
                        }</span>
                        <span class="cov0" title="0">s.OrderBy(sql.Desc(s.C(f)))</span>
                }
        }
}

// AggregateFunc applies an aggregation step on the group-by traversal/selector.
type AggregateFunc func(*sql.Selector) string

// As is a pseudo aggregation function for renaming another other functions with custom names. For example:
//
//        GroupBy(field1, field2).
//        Aggregate(ent.As(ent.Sum(field1), "sum_field1"), (ent.As(ent.Sum(field2), "sum_field2")).
//        Scan(ctx, &amp;v)
func As(fn AggregateFunc, end string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                return sql.As(fn(s), end)
        }</span>
}

// Count applies the "count" aggregation function on each group.
func Count() AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                return sql.Count("*")
        }</span>
}

// Max applies the "max" aggregation function on the given field of each group.
func Max(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Max(s.C(field))</span>
        }
}

// Mean applies the "mean" aggregation function on the given field of each group.
func Mean(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Avg(s.C(field))</span>
        }
}

// Min applies the "min" aggregation function on the given field of each group.
func Min(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Min(s.C(field))</span>
        }
}

// Sum applies the "sum" aggregation function on the given field of each group.
func Sum(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Sum(s.C(field))</span>
        }
}

// ValidationError returns when validating a field or edge fails.
type ValidationError struct {
        Name string // Field or edge name.
        err  error
}

// Error implements the error interface.
func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return e.err.Error()
}</span>

// Unwrap implements the errors.Wrapper interface.
func (e *ValidationError) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

// IsValidationError returns a boolean indicating whether the error is a validation error.
func IsValidationError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *ValidationError
        return errors.As(err, &amp;e)</span>
}

// NotFoundError returns when trying to fetch a specific entity and it was not found in the database.
type NotFoundError struct {
        label string
}

// Error implements the error interface.
func (e *NotFoundError) Error() string <span class="cov0" title="0">{
        return "ent: " + e.label + " not found"
}</span>

// IsNotFound returns a boolean indicating whether the error is a not found error.
func IsNotFound(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *NotFoundError
        return errors.As(err, &amp;e)</span>
}

// MaskNotFound masks not found error.
func MaskNotFound(err error) error <span class="cov0" title="0">{
        if IsNotFound(err) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}

// NotSingularError returns when trying to fetch a singular entity and more then one was found in the database.
type NotSingularError struct {
        label string
}

// Error implements the error interface.
func (e *NotSingularError) Error() string <span class="cov0" title="0">{
        return "ent: " + e.label + " not singular"
}</span>

// IsNotSingular returns a boolean indicating whether the error is a not singular error.
func IsNotSingular(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *NotSingularError
        return errors.As(err, &amp;e)</span>
}

// NotLoadedError returns when trying to get a node that was not loaded by the query.
type NotLoadedError struct {
        edge string
}

// Error implements the error interface.
func (e *NotLoadedError) Error() string <span class="cov0" title="0">{
        return "ent: " + e.edge + " edge was not loaded"
}</span>

// IsNotLoaded returns a boolean indicating whether the error is a not loaded error.
func IsNotLoaded(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *NotLoadedError
        return errors.As(err, &amp;e)</span>
}

// ConstraintError returns when trying to create/update one or more entities and
// one or more of their constraints failed. For example, violation of edge or
// field uniqueness.
type ConstraintError struct {
        msg  string
        wrap error
}

// Error implements the error interface.
func (e ConstraintError) Error() string <span class="cov0" title="0">{
        return "ent: constraint failed: " + e.msg
}</span>

// Unwrap implements the errors.Wrapper interface.
func (e *ConstraintError) Unwrap() error <span class="cov0" title="0">{
        return e.wrap
}</span>

// IsConstraintError returns a boolean indicating whether the error is a constraint failure.
func IsConstraintError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *ConstraintError
        return errors.As(err, &amp;e)</span>
}

// selector embedded by the different Select/GroupBy builders.
type selector struct {
        label string
        flds  *[]string
        fns   []AggregateFunc
        scan  func(context.Context, any) error
}

// ScanX is like Scan, but panics if an error occurs.
func (s *selector) ScanX(ctx context.Context, v any) <span class="cov0" title="0">{
        if err := s.scan(ctx, v); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// Strings returns list of strings from a selector. It is only allowed when selecting one field.
func (s *selector) Strings(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Strings is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []string
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// StringsX is like Strings, but panics if an error occurs.
func (s *selector) StringsX(ctx context.Context) []string <span class="cov0" title="0">{
        v, err := s.Strings(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// String returns a single string from a selector. It is only allowed when selecting one field.
func (s *selector) String(ctx context.Context) (_ string, err error) <span class="cov0" title="0">{
        var v []string
        if v, err = s.Strings(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Strings returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// StringX is like String, but panics if an error occurs.
func (s *selector) StringX(ctx context.Context) string <span class="cov0" title="0">{
        v, err := s.String(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Ints returns list of ints from a selector. It is only allowed when selecting one field.
func (s *selector) Ints(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Ints is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []int
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// IntsX is like Ints, but panics if an error occurs.
func (s *selector) IntsX(ctx context.Context) []int <span class="cov0" title="0">{
        v, err := s.Ints(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Int returns a single int from a selector. It is only allowed when selecting one field.
func (s *selector) Int(ctx context.Context) (_ int, err error) <span class="cov0" title="0">{
        var v []int
        if v, err = s.Ints(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Ints returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// IntX is like Int, but panics if an error occurs.
func (s *selector) IntX(ctx context.Context) int <span class="cov0" title="0">{
        v, err := s.Int(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Float64s returns list of float64s from a selector. It is only allowed when selecting one field.
func (s *selector) Float64s(ctx context.Context) ([]float64, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Float64s is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []float64
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// Float64sX is like Float64s, but panics if an error occurs.
func (s *selector) Float64sX(ctx context.Context) []float64 <span class="cov0" title="0">{
        v, err := s.Float64s(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Float64 returns a single float64 from a selector. It is only allowed when selecting one field.
func (s *selector) Float64(ctx context.Context) (_ float64, err error) <span class="cov0" title="0">{
        var v []float64
        if v, err = s.Float64s(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Float64s returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// Float64X is like Float64, but panics if an error occurs.
func (s *selector) Float64X(ctx context.Context) float64 <span class="cov0" title="0">{
        v, err := s.Float64(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Bools returns list of bools from a selector. It is only allowed when selecting one field.
func (s *selector) Bools(ctx context.Context) ([]bool, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Bools is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []bool
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// BoolsX is like Bools, but panics if an error occurs.
func (s *selector) BoolsX(ctx context.Context) []bool <span class="cov0" title="0">{
        v, err := s.Bools(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Bool returns a single bool from a selector. It is only allowed when selecting one field.
func (s *selector) Bool(ctx context.Context) (_ bool, err error) <span class="cov0" title="0">{
        var v []bool
        if v, err = s.Bools(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Bools returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// BoolX is like Bool, but panics if an error occurs.
func (s *selector) BoolX(ctx context.Context) bool <span class="cov0" title="0">{
        v, err := s.Bool(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// withHooks invokes the builder operation with the given hooks, if any.
func withHooks[V Value, M any, PM interface {
        *M
        Mutation
}](ctx context.Context, exec func(context.Context) (V, error), mutation PM, hooks []Hook) (value V, err error) <span class="cov0" title="0">{
        if len(hooks) == 0 </span><span class="cov0" title="0">{
                return exec(ctx)
        }</span>
        <span class="cov0" title="0">var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                mutationT, ok := any(m).(PM)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                }</span>
                // Set the mutation to the builder.
                <span class="cov0" title="0">*mutation = *mutationT
                return exec(ctx)</span>
        })
        <span class="cov0" title="0">for i := len(hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if hooks[i] == nil </span><span class="cov0" title="0">{
                        return value, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">mut = hooks[i](mut)</span>
        }
        <span class="cov0" title="0">v, err := mut.Mutate(ctx, mutation)
        if err != nil </span><span class="cov0" title="0">{
                return value, err
        }</span>
        <span class="cov0" title="0">nv, ok := v.(V)
        if !ok </span><span class="cov0" title="0">{
                return value, fmt.Errorf("unexpected node type %T returned from %T", v, mutation)
        }</span>
        <span class="cov0" title="0">return nv, nil</span>
}

// setContextOp returns a new context with the given QueryContext attached (including its op) in case it does not exist.
func setContextOp(ctx context.Context, qc *QueryContext, op string) context.Context <span class="cov0" title="0">{
        if ent.QueryFromContext(ctx) == nil </span><span class="cov0" title="0">{
                qc.Op = op
                ctx = ent.NewQueryContext(ctx, qc)
        }</span>
        <span class="cov0" title="0">return ctx</span>
}

func querierAll[V Value, Q interface {
        sqlAll(context.Context, ...queryHook) (V, error)
}]() Querier <span class="cov0" title="0">{
        return QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov0" title="0">{
                query, ok := q.(Q)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected query type %T", q)
                }</span>
                <span class="cov0" title="0">return query.sqlAll(ctx)</span>
        })
}

func querierCount[Q interface {
        sqlCount(context.Context) (int, error)
}]() Querier <span class="cov0" title="0">{
        return QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov0" title="0">{
                query, ok := q.(Q)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected query type %T", q)
                }</span>
                <span class="cov0" title="0">return query.sqlCount(ctx)</span>
        })
}

func withInterceptors[V Value](ctx context.Context, q Query, qr Querier, inters []Interceptor) (v V, err error) <span class="cov0" title="0">{
        for i := len(inters) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                qr = inters[i].Intercept(qr)
        }</span>
        <span class="cov0" title="0">rv, err := qr.Query(ctx, q)
        if err != nil </span><span class="cov0" title="0">{
                return v, err
        }</span>
        <span class="cov0" title="0">vt, ok := rv.(V)
        if !ok </span><span class="cov0" title="0">{
                return v, fmt.Errorf("unexpected type %T returned from %T. expected type: %T", vt, q, v)
        }</span>
        <span class="cov0" title="0">return vt, nil</span>
}

func scanWithInterceptors[Q1 ent.Query, Q2 interface {
        sqlScan(context.Context, Q1, any) error
}](ctx context.Context, rootQuery Q1, selectOrGroup Q2, inters []Interceptor, v any) error <span class="cov0" title="0">{
        rv := reflect.ValueOf(v)
        var qr Querier = QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov0" title="0">{
                query, ok := q.(Q1)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected query type %T", q)
                }</span>
                <span class="cov0" title="0">if err := selectOrGroup.sqlScan(ctx, query, v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if k := rv.Kind(); k == reflect.Pointer &amp;&amp; rv.Elem().CanInterface() </span><span class="cov0" title="0">{
                        return rv.Elem().Interface(), nil
                }</span>
                <span class="cov0" title="0">return v, nil</span>
        })
        <span class="cov0" title="0">for i := len(inters) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                qr = inters[i].Intercept(qr)
        }</span>
        <span class="cov0" title="0">vv, err := qr.Query(ctx, rootQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">switch rv2 := reflect.ValueOf(vv); </span>{
        case rv.IsNil(), rv2.IsNil(), rv.Kind() != reflect.Pointer:<span class="cov0" title="0"></span>
        case rv.Type() == rv2.Type():<span class="cov0" title="0">
                rv.Elem().Set(rv2.Elem())</span>
        case rv.Elem().Type() == rv2.Type():<span class="cov0" title="0">
                rv.Elem().Set(rv2)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// queryHook describes an internal hook for the different sqlAll methods.
type queryHook func(context.Context, *sqlgraph.QuerySpec)
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by ent, DO NOT EDIT.

package enttest

import (
        "context"

        "github.com/denkhaus/knot/internal/repository/sqlite/ent"
        // required by schema hooks.
        _ "github.com/denkhaus/knot/internal/repository/sqlite/ent/runtime"

        "entgo.io/ent/dialect/sql/schema"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/migrate"
)

type (
        // TestingT is the interface that is shared between
        // testing.T and testing.B and used by enttest.
        TestingT interface {
                FailNow()
                Error(...any)
        }

        // Option configures client creation.
        Option func(*options)

        options struct {
                opts        []ent.Option
                migrateOpts []schema.MigrateOption
        }
)

// WithOptions forwards options to client creation.
func WithOptions(opts ...ent.Option) Option <span class="cov0" title="0">{
        return func(o *options) </span><span class="cov0" title="0">{
                o.opts = append(o.opts, opts...)
        }</span>
}

// WithMigrateOptions forwards options to auto migration.
func WithMigrateOptions(opts ...schema.MigrateOption) Option <span class="cov0" title="0">{
        return func(o *options) </span><span class="cov0" title="0">{
                o.migrateOpts = append(o.migrateOpts, opts...)
        }</span>
}

func newOptions(opts []Option) *options <span class="cov0" title="0">{
        o := &amp;options{}
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(o)
        }</span>
        <span class="cov0" title="0">return o</span>
}

// Open calls ent.Open and auto-run migration.
func Open(t TestingT, driverName, dataSourceName string, opts ...Option) *ent.Client <span class="cov0" title="0">{
        o := newOptions(opts)
        c, err := ent.Open(driverName, dataSourceName, o.opts...)
        if err != nil </span><span class="cov0" title="0">{
                t.Error(err)
                t.FailNow()
        }</span>
        <span class="cov0" title="0">migrateSchema(t, c, o)
        return c</span>
}

// NewClient calls ent.NewClient and auto-run migration.
func NewClient(t TestingT, opts ...Option) *ent.Client <span class="cov0" title="0">{
        o := newOptions(opts)
        c := ent.NewClient(o.opts...)
        migrateSchema(t, c, o)
        return c
}</span>
func migrateSchema(t TestingT, c *ent.Client, o *options) <span class="cov0" title="0">{
        tables, err := schema.CopyTables(migrate.Tables)
        if err != nil </span><span class="cov0" title="0">{
                t.Error(err)
                t.FailNow()
        }</span>
        <span class="cov0" title="0">if err := migrate.Create(context.Background(), c.Schema, tables, o.migrateOpts...); err != nil </span><span class="cov0" title="0">{
                t.Error(err)
                t.FailNow()
        }</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Code generated by ent, DO NOT EDIT.

package hook

import (
        "context"
        "fmt"

        "github.com/denkhaus/knot/internal/repository/sqlite/ent"
)

// The ProjectFunc type is an adapter to allow the use of ordinary
// function as Project mutator.
type ProjectFunc func(context.Context, *ent.ProjectMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f ProjectFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.ProjectMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.ProjectMutation", m)</span>
}

// The ProjectContextFunc type is an adapter to allow the use of ordinary
// function as ProjectContext mutator.
type ProjectContextFunc func(context.Context, *ent.ProjectContextMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f ProjectContextFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.ProjectContextMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.ProjectContextMutation", m)</span>
}

// The TaskFunc type is an adapter to allow the use of ordinary
// function as Task mutator.
type TaskFunc func(context.Context, *ent.TaskMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f TaskFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.TaskMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.TaskMutation", m)</span>
}

// The TaskDependencyFunc type is an adapter to allow the use of ordinary
// function as TaskDependency mutator.
type TaskDependencyFunc func(context.Context, *ent.TaskDependencyMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f TaskDependencyFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.TaskDependencyMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.TaskDependencyMutation", m)</span>
}

// Condition is a hook condition function.
type Condition func(context.Context, ent.Mutation) bool

// And groups conditions with the AND operator.
func And(first, second Condition, rest ...Condition) Condition <span class="cov0" title="0">{
        return func(ctx context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if !first(ctx, m) || !second(ctx, m) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, cond := range rest </span><span class="cov0" title="0">{
                        if !cond(ctx, m) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// Or groups conditions with the OR operator.
func Or(first, second Condition, rest ...Condition) Condition <span class="cov0" title="0">{
        return func(ctx context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if first(ctx, m) || second(ctx, m) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">for _, cond := range rest </span><span class="cov0" title="0">{
                        if cond(ctx, m) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
}

// Not negates a given condition.
func Not(cond Condition) Condition <span class="cov0" title="0">{
        return func(ctx context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                return !cond(ctx, m)
        }</span>
}

// HasOp is a condition testing mutation operation.
func HasOp(op ent.Op) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                return m.Op().Is(op)
        }</span>
}

// HasAddedFields is a condition validating `.AddedField` on fields.
func HasAddedFields(field string, fields ...string) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if _, exists := m.AddedField(field); !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                        if _, exists := m.AddedField(field); !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// HasClearedFields is a condition validating `.FieldCleared` on fields.
func HasClearedFields(field string, fields ...string) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if exists := m.FieldCleared(field); !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                        if exists := m.FieldCleared(field); !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// HasFields is a condition validating `.Field` on fields.
func HasFields(field string, fields ...string) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if _, exists := m.Field(field); !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                        if _, exists := m.Field(field); !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// If executes the given hook under condition.
//
//        hook.If(ComputeAverage, And(HasFields(...), HasAddedFields(...)))
func If(hk ent.Hook, cond Condition) ent.Hook <span class="cov0" title="0">{
        return func(next ent.Mutator) ent.Mutator </span><span class="cov0" title="0">{
                return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) </span><span class="cov0" title="0">{
                        if cond(ctx, m) </span><span class="cov0" title="0">{
                                return hk(next).Mutate(ctx, m)
                        }</span>
                        <span class="cov0" title="0">return next.Mutate(ctx, m)</span>
                })
        }
}

// On executes the given hook only for the given operation.
//
//        hook.On(Log, ent.Delete|ent.Create)
func On(hk ent.Hook, op ent.Op) ent.Hook <span class="cov0" title="0">{
        return If(hk, HasOp(op))
}</span>

// Unless skips the given hook only for the given operation.
//
//        hook.Unless(Log, ent.Update|ent.UpdateOne)
func Unless(hk ent.Hook, op ent.Op) ent.Hook <span class="cov0" title="0">{
        return If(hk, Not(HasOp(op)))
}</span>

// FixedError is a hook returning a fixed error.
func FixedError(err error) ent.Hook <span class="cov0" title="0">{
        return func(ent.Mutator) ent.Mutator </span><span class="cov0" title="0">{
                return ent.MutateFunc(func(context.Context, ent.Mutation) (ent.Value, error) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>)
        }
}

// Reject returns a hook that rejects all operations that match op.
//
//        func (T) Hooks() []ent.Hook {
//                return []ent.Hook{
//                        Reject(ent.Delete|ent.Update),
//                }
//        }
func Reject(op ent.Op) ent.Hook <span class="cov0" title="0">{
        hk := FixedError(fmt.Errorf("%s operation is not allowed", op))
        return On(hk, op)
}</span>

// Chain acts as a list of hooks and is effectively immutable.
// Once created, it will always hold the same set of hooks in the same order.
type Chain struct {
        hooks []ent.Hook
}

// NewChain creates a new chain of hooks.
func NewChain(hooks ...ent.Hook) Chain <span class="cov0" title="0">{
        return Chain{append([]ent.Hook(nil), hooks...)}
}</span>

// Hook chains the list of hooks and returns the final hook.
func (c Chain) Hook() ent.Hook <span class="cov0" title="0">{
        return func(mutator ent.Mutator) ent.Mutator </span><span class="cov0" title="0">{
                for i := len(c.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        mutator = c.hooks[i](mutator)
                }</span>
                <span class="cov0" title="0">return mutator</span>
        }
}

// Append extends a chain, adding the specified hook
// as the last ones in the mutation flow.
func (c Chain) Append(hooks ...ent.Hook) Chain <span class="cov0" title="0">{
        newHooks := make([]ent.Hook, 0, len(c.hooks)+len(hooks))
        newHooks = append(newHooks, c.hooks...)
        newHooks = append(newHooks, hooks...)
        return Chain{newHooks}
}</span>

// Extend extends a chain, adding the specified chain
// as the last ones in the mutation flow.
func (c Chain) Extend(chain Chain) Chain <span class="cov0" title="0">{
        return c.Append(chain.hooks...)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by ent, DO NOT EDIT.

package migrate

import (
        "context"
        "fmt"
        "io"

        "entgo.io/ent/dialect"
        "entgo.io/ent/dialect/sql/schema"
)

var (
        // WithGlobalUniqueID sets the universal ids options to the migration.
        // If this option is enabled, ent migration will allocate a 1&lt;&lt;32 range
        // for the ids of each entity (table).
        // Note that this option cannot be applied on tables that already exist.
        WithGlobalUniqueID = schema.WithGlobalUniqueID
        // WithDropColumn sets the drop column option to the migration.
        // If this option is enabled, ent migration will drop old columns
        // that were used for both fields and edges. This defaults to false.
        WithDropColumn = schema.WithDropColumn
        // WithDropIndex sets the drop index option to the migration.
        // If this option is enabled, ent migration will drop old indexes
        // that were defined in the schema. This defaults to false.
        // Note that unique constraints are defined using `UNIQUE INDEX`,
        // and therefore, it's recommended to enable this option to get more
        // flexibility in the schema changes.
        WithDropIndex = schema.WithDropIndex
        // WithForeignKeys enables creating foreign-key in schema DDL. This defaults to true.
        WithForeignKeys = schema.WithForeignKeys
)

// Schema is the API for creating, migrating and dropping a schema.
type Schema struct {
        drv dialect.Driver
}

// NewSchema creates a new schema client.
func NewSchema(drv dialect.Driver) *Schema <span class="cov0" title="0">{ return &amp;Schema{drv: drv} }</span>

// Create creates all schema resources.
func (s *Schema) Create(ctx context.Context, opts ...schema.MigrateOption) error <span class="cov0" title="0">{
        return Create(ctx, s, Tables, opts...)
}</span>

// Create creates all table resources using the given schema driver.
func Create(ctx context.Context, s *Schema, tables []*schema.Table, opts ...schema.MigrateOption) error <span class="cov0" title="0">{
        migrate, err := schema.NewMigrate(s.drv, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ent/migrate: %w", err)
        }</span>
        <span class="cov0" title="0">return migrate.Create(ctx, tables...)</span>
}

// WriteTo writes the schema changes to w instead of running them against the database.
//
//        if err := client.Schema.WriteTo(context.Background(), os.Stdout); err != nil {
//                log.Fatal(err)
//        }
func (s *Schema) WriteTo(ctx context.Context, w io.Writer, opts ...schema.MigrateOption) error <span class="cov0" title="0">{
        return Create(ctx, &amp;Schema{drv: &amp;schema.WriteDriver{Writer: w, Driver: s.drv}}, Tables, opts...)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by ent, DO NOT EDIT.

package migrate

import (
        "entgo.io/ent/dialect/sql/schema"
        "entgo.io/ent/schema/field"
)

var (
        // ProjectsColumns holds the columns for the "projects" table.
        ProjectsColumns = []*schema.Column{
                {Name: "id", Type: field.TypeUUID, Unique: true},
                {Name: "title", Type: field.TypeString, Size: 200},
                {Name: "description", Type: field.TypeString, Nullable: true, Size: 2147483647},
                {Name: "state", Type: field.TypeEnum, Enums: []string{"active", "completed", "archived", "deletion-pending"}, Default: "active"},
                {Name: "created_at", Type: field.TypeTime},
                {Name: "updated_at", Type: field.TypeTime},
                {Name: "total_tasks", Type: field.TypeInt, Default: 0},
                {Name: "completed_tasks", Type: field.TypeInt, Default: 0},
                {Name: "progress", Type: field.TypeFloat64, Default: 0},
        }
        // ProjectsTable holds the schema information for the "projects" table.
        ProjectsTable = &amp;schema.Table{
                Name:       "projects",
                Columns:    ProjectsColumns,
                PrimaryKey: []*schema.Column{ProjectsColumns[0]},
                Indexes: []*schema.Index{
                        {
                                Name:    "project_created_at",
                                Unique:  false,
                                Columns: []*schema.Column{ProjectsColumns[4]},
                        },
                        {
                                Name:    "project_title",
                                Unique:  false,
                                Columns: []*schema.Column{ProjectsColumns[1]},
                        },
                        {
                                Name:    "project_progress",
                                Unique:  false,
                                Columns: []*schema.Column{ProjectsColumns[8]},
                        },
                        {
                                Name:    "project_state",
                                Unique:  false,
                                Columns: []*schema.Column{ProjectsColumns[3]},
                        },
                },
        }
        // ProjectContextsColumns holds the columns for the "project_contexts" table.
        ProjectContextsColumns = []*schema.Column{
                {Name: "id", Type: field.TypeInt, Increment: true},
                {Name: "updated_at", Type: field.TypeTime},
                {Name: "updated_by", Type: field.TypeString},
                {Name: "selected_project_id", Type: field.TypeUUID, Nullable: true},
        }
        // ProjectContextsTable holds the schema information for the "project_contexts" table.
        ProjectContextsTable = &amp;schema.Table{
                Name:       "project_contexts",
                Columns:    ProjectContextsColumns,
                PrimaryKey: []*schema.Column{ProjectContextsColumns[0]},
                ForeignKeys: []*schema.ForeignKey{
                        {
                                Symbol:     "project_contexts_projects_selected_project",
                                Columns:    []*schema.Column{ProjectContextsColumns[3]},
                                RefColumns: []*schema.Column{ProjectsColumns[0]},
                                OnDelete:   schema.SetNull,
                        },
                },
        }
        // TasksColumns holds the columns for the "tasks" table.
        TasksColumns = []*schema.Column{
                {Name: "id", Type: field.TypeUUID, Unique: true},
                {Name: "title", Type: field.TypeString, Size: 200},
                {Name: "description", Type: field.TypeString, Nullable: true, Size: 2147483647},
                {Name: "state", Type: field.TypeEnum, Enums: []string{"pending", "in-progress", "completed", "blocked", "cancelled", "deletion-pending"}, Default: "pending"},
                {Name: "priority", Type: field.TypeEnum, Enums: []string{"low", "medium", "high"}, Default: "medium"},
                {Name: "complexity", Type: field.TypeInt},
                {Name: "depth", Type: field.TypeInt, Default: 0},
                {Name: "estimate", Type: field.TypeInt64, Nullable: true},
                {Name: "assigned_agent", Type: field.TypeUUID, Nullable: true},
                {Name: "created_at", Type: field.TypeTime},
                {Name: "updated_at", Type: field.TypeTime},
                {Name: "completed_at", Type: field.TypeTime, Nullable: true},
                {Name: "project_id", Type: field.TypeUUID},
                {Name: "parent_id", Type: field.TypeUUID, Nullable: true},
        }
        // TasksTable holds the schema information for the "tasks" table.
        TasksTable = &amp;schema.Table{
                Name:       "tasks",
                Columns:    TasksColumns,
                PrimaryKey: []*schema.Column{TasksColumns[0]},
                ForeignKeys: []*schema.ForeignKey{
                        {
                                Symbol:     "tasks_projects_tasks",
                                Columns:    []*schema.Column{TasksColumns[12]},
                                RefColumns: []*schema.Column{ProjectsColumns[0]},
                                OnDelete:   schema.NoAction,
                        },
                        {
                                Symbol:     "tasks_tasks_children",
                                Columns:    []*schema.Column{TasksColumns[13]},
                                RefColumns: []*schema.Column{TasksColumns[0]},
                                OnDelete:   schema.SetNull,
                        },
                },
                Indexes: []*schema.Index{
                        {
                                Name:    "task_project_id",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[12]},
                        },
                        {
                                Name:    "task_parent_id",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[13]},
                        },
                        {
                                Name:    "task_state",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[3]},
                        },
                        {
                                Name:    "task_priority",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[4]},
                        },
                        {
                                Name:    "task_assigned_agent",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[8]},
                        },
                        {
                                Name:    "task_complexity",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[5]},
                        },
                        {
                                Name:    "task_depth",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[6]},
                        },
                        {
                                Name:    "task_created_at",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[9]},
                        },
                        {
                                Name:    "task_project_id_state",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[12], TasksColumns[3]},
                        },
                        {
                                Name:    "task_project_id_priority",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[12], TasksColumns[4]},
                        },
                        {
                                Name:    "task_project_id_assigned_agent",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[12], TasksColumns[8]},
                        },
                        {
                                Name:    "task_project_id_parent_id",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[12], TasksColumns[13]},
                        },
                        {
                                Name:    "task_project_id_depth",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[12], TasksColumns[6]},
                        },
                        {
                                Name:    "task_state_complexity",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[3], TasksColumns[5]},
                        },
                        {
                                Name:    "task_priority_state",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[4], TasksColumns[3]},
                        },
                        {
                                Name:    "task_priority_complexity",
                                Unique:  false,
                                Columns: []*schema.Column{TasksColumns[4], TasksColumns[5]},
                        },
                },
        }
        // TaskDependenciesColumns holds the columns for the "task_dependencies" table.
        TaskDependenciesColumns = []*schema.Column{
                {Name: "id", Type: field.TypeUUID, Unique: true},
                {Name: "created_at", Type: field.TypeTime},
                {Name: "task_id", Type: field.TypeUUID},
                {Name: "depends_on_task_id", Type: field.TypeUUID},
        }
        // TaskDependenciesTable holds the schema information for the "task_dependencies" table.
        TaskDependenciesTable = &amp;schema.Table{
                Name:       "task_dependencies",
                Columns:    TaskDependenciesColumns,
                PrimaryKey: []*schema.Column{TaskDependenciesColumns[0]},
                ForeignKeys: []*schema.ForeignKey{
                        {
                                Symbol:     "task_dependencies_tasks_task",
                                Columns:    []*schema.Column{TaskDependenciesColumns[2]},
                                RefColumns: []*schema.Column{TasksColumns[0]},
                                OnDelete:   schema.NoAction,
                        },
                        {
                                Symbol:     "task_dependencies_tasks_depends_on_task",
                                Columns:    []*schema.Column{TaskDependenciesColumns[3]},
                                RefColumns: []*schema.Column{TasksColumns[0]},
                                OnDelete:   schema.NoAction,
                        },
                },
                Indexes: []*schema.Index{
                        {
                                Name:    "taskdependency_task_id",
                                Unique:  false,
                                Columns: []*schema.Column{TaskDependenciesColumns[2]},
                        },
                        {
                                Name:    "taskdependency_depends_on_task_id",
                                Unique:  false,
                                Columns: []*schema.Column{TaskDependenciesColumns[3]},
                        },
                        {
                                Name:    "taskdependency_task_id_depends_on_task_id",
                                Unique:  true,
                                Columns: []*schema.Column{TaskDependenciesColumns[2], TaskDependenciesColumns[3]},
                        },
                        {
                                Name:    "taskdependency_depends_on_task_id_task_id",
                                Unique:  false,
                                Columns: []*schema.Column{TaskDependenciesColumns[3], TaskDependenciesColumns[2]},
                        },
                        {
                                Name:    "taskdependency_created_at",
                                Unique:  false,
                                Columns: []*schema.Column{TaskDependenciesColumns[1]},
                        },
                },
        }
        // Tables holds all the tables in the schema.
        Tables = []*schema.Table{
                ProjectsTable,
                ProjectContextsTable,
                TasksTable,
                TaskDependenciesTable,
        }
)

func init() <span class="cov0" title="0">{
        ProjectContextsTable.ForeignKeys[0].RefTable = ProjectsTable
        TasksTable.ForeignKeys[0].RefTable = ProjectsTable
        TasksTable.ForeignKeys[1].RefTable = TasksTable
        TaskDependenciesTable.ForeignKeys[0].RefTable = TasksTable
        TaskDependenciesTable.ForeignKeys[1].RefTable = TasksTable
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "sync"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
        "github.com/google/uuid"
)

const (
        // Operation types.
        OpCreate    = ent.OpCreate
        OpDelete    = ent.OpDelete
        OpDeleteOne = ent.OpDeleteOne
        OpUpdate    = ent.OpUpdate
        OpUpdateOne = ent.OpUpdateOne

        // Node types.
        TypeProject        = "Project"
        TypeProjectContext = "ProjectContext"
        TypeTask           = "Task"
        TypeTaskDependency = "TaskDependency"
)

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
        config
        op                 Op
        typ                string
        id                 *uuid.UUID
        title              *string
        description        *string
        state              *project.State
        created_at         *time.Time
        updated_at         *time.Time
        total_tasks        *int
        addtotal_tasks     *int
        completed_tasks    *int
        addcompleted_tasks *int
        progress           *float64
        addprogress        *float64
        clearedFields      map[string]struct{}
        tasks              map[uuid.UUID]struct{}
        removedtasks       map[uuid.UUID]struct{}
        clearedtasks       bool
        done               bool
        oldValue           func(context.Context) (*Project, error)
        predicates         []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation <span class="cov0" title="0">{
        m := &amp;ProjectMutation{
                config:        c,
                op:            op,
                typ:           TypeProject,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(m)
        }</span>
        <span class="cov0" title="0">return m</span>
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id uuid.UUID) projectOption <span class="cov0" title="0">{
        return func(m *ProjectMutation) </span><span class="cov0" title="0">{
                var (
                        err   error
                        once  sync.Once
                        value *Project
                )
                m.oldValue = func(ctx context.Context) (*Project, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().Project.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov0" title="0">m.id = &amp;id</span>
        }
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption <span class="cov0" title="0">{
        return func(m *ProjectMutation) </span><span class="cov0" title="0">{
                m.oldValue = func(context.Context) (*Project, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov0" title="0">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id uuid.UUID) <span class="cov0" title="0">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id uuid.UUID, exists bool) <span class="cov0" title="0">{
        if m.id == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []uuid.UUID{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetTitle sets the "title" field.
func (m *ProjectMutation) SetTitle(s string) <span class="cov0" title="0">{
        m.title = &amp;s
}</span>

// Title returns the value of the "title" field in the mutation.
func (m *ProjectMutation) Title() (r string, exists bool) <span class="cov0" title="0">{
        v := m.title
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldTitle returns the old "title" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldTitle(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldTitle is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldTitle requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldTitle: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Title, nil</span>
}

// ResetTitle resets all changes to the "title" field.
func (m *ProjectMutation) ResetTitle() <span class="cov0" title="0">{
        m.title = nil
}</span>

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) <span class="cov0" title="0">{
        m.description = &amp;s
}</span>

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) <span class="cov0" title="0">{
        v := m.description
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldDescription is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldDescription requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldDescription: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Description, nil</span>
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() <span class="cov0" title="0">{
        m.description = nil
        m.clearedFields[project.FieldDescription] = struct{}{}
}</span>

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[project.FieldDescription]
        return ok
}</span>

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() <span class="cov0" title="0">{
        m.description = nil
        delete(m.clearedFields, project.FieldDescription)
}</span>

// SetState sets the "state" field.
func (m *ProjectMutation) SetState(pr project.State) <span class="cov0" title="0">{
        m.state = &amp;pr
}</span>

// State returns the value of the "state" field in the mutation.
func (m *ProjectMutation) State() (r project.State, exists bool) <span class="cov0" title="0">{
        v := m.state
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldState returns the old "state" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldState(ctx context.Context) (v project.State, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldState is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldState requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldState: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.State, nil</span>
}

// ResetState resets all changes to the "state" field.
func (m *ProjectMutation) ResetState() <span class="cov0" title="0">{
        m.state = nil
}</span>

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) <span class="cov0" title="0">{
        m.created_at = &amp;t
}</span>

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.created_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CreatedAt, nil</span>
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() <span class="cov0" title="0">{
        m.created_at = nil
}</span>

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) <span class="cov0" title="0">{
        m.updated_at = &amp;t
}</span>

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.updated_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.UpdatedAt, nil</span>
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() <span class="cov0" title="0">{
        m.updated_at = nil
}</span>

// SetTotalTasks sets the "total_tasks" field.
func (m *ProjectMutation) SetTotalTasks(i int) <span class="cov0" title="0">{
        m.total_tasks = &amp;i
        m.addtotal_tasks = nil
}</span>

// TotalTasks returns the value of the "total_tasks" field in the mutation.
func (m *ProjectMutation) TotalTasks() (r int, exists bool) <span class="cov0" title="0">{
        v := m.total_tasks
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldTotalTasks returns the old "total_tasks" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldTotalTasks(ctx context.Context) (v int, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldTotalTasks is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldTotalTasks requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldTotalTasks: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.TotalTasks, nil</span>
}

// AddTotalTasks adds i to the "total_tasks" field.
func (m *ProjectMutation) AddTotalTasks(i int) <span class="cov0" title="0">{
        if m.addtotal_tasks != nil </span><span class="cov0" title="0">{
                *m.addtotal_tasks += i
        }</span> else<span class="cov0" title="0"> {
                m.addtotal_tasks = &amp;i
        }</span>
}

// AddedTotalTasks returns the value that was added to the "total_tasks" field in this mutation.
func (m *ProjectMutation) AddedTotalTasks() (r int, exists bool) <span class="cov0" title="0">{
        v := m.addtotal_tasks
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// ResetTotalTasks resets all changes to the "total_tasks" field.
func (m *ProjectMutation) ResetTotalTasks() <span class="cov0" title="0">{
        m.total_tasks = nil
        m.addtotal_tasks = nil
}</span>

// SetCompletedTasks sets the "completed_tasks" field.
func (m *ProjectMutation) SetCompletedTasks(i int) <span class="cov0" title="0">{
        m.completed_tasks = &amp;i
        m.addcompleted_tasks = nil
}</span>

// CompletedTasks returns the value of the "completed_tasks" field in the mutation.
func (m *ProjectMutation) CompletedTasks() (r int, exists bool) <span class="cov0" title="0">{
        v := m.completed_tasks
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldCompletedTasks returns the old "completed_tasks" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCompletedTasks(ctx context.Context) (v int, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCompletedTasks is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCompletedTasks requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCompletedTasks: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CompletedTasks, nil</span>
}

// AddCompletedTasks adds i to the "completed_tasks" field.
func (m *ProjectMutation) AddCompletedTasks(i int) <span class="cov0" title="0">{
        if m.addcompleted_tasks != nil </span><span class="cov0" title="0">{
                *m.addcompleted_tasks += i
        }</span> else<span class="cov0" title="0"> {
                m.addcompleted_tasks = &amp;i
        }</span>
}

// AddedCompletedTasks returns the value that was added to the "completed_tasks" field in this mutation.
func (m *ProjectMutation) AddedCompletedTasks() (r int, exists bool) <span class="cov0" title="0">{
        v := m.addcompleted_tasks
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// ResetCompletedTasks resets all changes to the "completed_tasks" field.
func (m *ProjectMutation) ResetCompletedTasks() <span class="cov0" title="0">{
        m.completed_tasks = nil
        m.addcompleted_tasks = nil
}</span>

// SetProgress sets the "progress" field.
func (m *ProjectMutation) SetProgress(f float64) <span class="cov0" title="0">{
        m.progress = &amp;f
        m.addprogress = nil
}</span>

// Progress returns the value of the "progress" field in the mutation.
func (m *ProjectMutation) Progress() (r float64, exists bool) <span class="cov0" title="0">{
        v := m.progress
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldProgress returns the old "progress" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldProgress(ctx context.Context) (v float64, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldProgress is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldProgress requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldProgress: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Progress, nil</span>
}

// AddProgress adds f to the "progress" field.
func (m *ProjectMutation) AddProgress(f float64) <span class="cov0" title="0">{
        if m.addprogress != nil </span><span class="cov0" title="0">{
                *m.addprogress += f
        }</span> else<span class="cov0" title="0"> {
                m.addprogress = &amp;f
        }</span>
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *ProjectMutation) AddedProgress() (r float64, exists bool) <span class="cov0" title="0">{
        v := m.addprogress
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// ResetProgress resets all changes to the "progress" field.
func (m *ProjectMutation) ResetProgress() <span class="cov0" title="0">{
        m.progress = nil
        m.addprogress = nil
}</span>

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ProjectMutation) AddTaskIDs(ids ...uuid.UUID) <span class="cov0" title="0">{
        if m.tasks == nil </span><span class="cov0" title="0">{
                m.tasks = make(map[uuid.UUID]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                m.tasks[ids[i]] = struct{}{}
        }</span>
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ProjectMutation) ClearTasks() <span class="cov0" title="0">{
        m.clearedtasks = true
}</span>

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ProjectMutation) TasksCleared() bool <span class="cov0" title="0">{
        return m.clearedtasks
}</span>

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ProjectMutation) RemoveTaskIDs(ids ...uuid.UUID) <span class="cov0" title="0">{
        if m.removedtasks == nil </span><span class="cov0" title="0">{
                m.removedtasks = make(map[uuid.UUID]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                delete(m.tasks, ids[i])
                m.removedtasks[ids[i]] = struct{}{}
        }</span>
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ProjectMutation) RemovedTasksIDs() (ids []uuid.UUID) <span class="cov0" title="0">{
        for id := range m.removedtasks </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ProjectMutation) TasksIDs() (ids []uuid.UUID) <span class="cov0" title="0">{
        for id := range m.tasks </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ProjectMutation) ResetTasks() <span class="cov0" title="0">{
        m.tasks = nil
        m.clearedtasks = false
        m.removedtasks = nil
}</span>

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) <span class="cov0" title="0">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.Project, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 8)
        if m.title != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldTitle)
        }</span>
        <span class="cov0" title="0">if m.description != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldDescription)
        }</span>
        <span class="cov0" title="0">if m.state != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldState)
        }</span>
        <span class="cov0" title="0">if m.created_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldCreatedAt)
        }</span>
        <span class="cov0" title="0">if m.updated_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldUpdatedAt)
        }</span>
        <span class="cov0" title="0">if m.total_tasks != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldTotalTasks)
        }</span>
        <span class="cov0" title="0">if m.completed_tasks != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldCompletedTasks)
        }</span>
        <span class="cov0" title="0">if m.progress != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldProgress)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case project.FieldTitle:<span class="cov0" title="0">
                return m.Title()</span>
        case project.FieldDescription:<span class="cov0" title="0">
                return m.Description()</span>
        case project.FieldState:<span class="cov0" title="0">
                return m.State()</span>
        case project.FieldCreatedAt:<span class="cov0" title="0">
                return m.CreatedAt()</span>
        case project.FieldUpdatedAt:<span class="cov0" title="0">
                return m.UpdatedAt()</span>
        case project.FieldTotalTasks:<span class="cov0" title="0">
                return m.TotalTasks()</span>
        case project.FieldCompletedTasks:<span class="cov0" title="0">
                return m.CompletedTasks()</span>
        case project.FieldProgress:<span class="cov0" title="0">
                return m.Progress()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case project.FieldTitle:<span class="cov0" title="0">
                return m.OldTitle(ctx)</span>
        case project.FieldDescription:<span class="cov0" title="0">
                return m.OldDescription(ctx)</span>
        case project.FieldState:<span class="cov0" title="0">
                return m.OldState(ctx)</span>
        case project.FieldCreatedAt:<span class="cov0" title="0">
                return m.OldCreatedAt(ctx)</span>
        case project.FieldUpdatedAt:<span class="cov0" title="0">
                return m.OldUpdatedAt(ctx)</span>
        case project.FieldTotalTasks:<span class="cov0" title="0">
                return m.OldTotalTasks(ctx)</span>
        case project.FieldCompletedTasks:<span class="cov0" title="0">
                return m.OldCompletedTasks(ctx)</span>
        case project.FieldProgress:<span class="cov0" title="0">
                return m.OldProgress(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown Project field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case project.FieldTitle:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetTitle(v)
                return nil</span>
        case project.FieldDescription:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetDescription(v)
                return nil</span>
        case project.FieldState:<span class="cov0" title="0">
                v, ok := value.(project.State)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetState(v)
                return nil</span>
        case project.FieldCreatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCreatedAt(v)
                return nil</span>
        case project.FieldUpdatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetUpdatedAt(v)
                return nil</span>
        case project.FieldTotalTasks:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetTotalTasks(v)
                return nil</span>
        case project.FieldCompletedTasks:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCompletedTasks(v)
                return nil</span>
        case project.FieldProgress:<span class="cov0" title="0">
                v, ok := value.(float64)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetProgress(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Project field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string <span class="cov0" title="0">{
        var fields []string
        if m.addtotal_tasks != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldTotalTasks)
        }</span>
        <span class="cov0" title="0">if m.addcompleted_tasks != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldCompletedTasks)
        }</span>
        <span class="cov0" title="0">if m.addprogress != nil </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldProgress)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case project.FieldTotalTasks:<span class="cov0" title="0">
                return m.AddedTotalTasks()</span>
        case project.FieldCompletedTasks:<span class="cov0" title="0">
                return m.AddedCompletedTasks()</span>
        case project.FieldProgress:<span class="cov0" title="0">
                return m.AddedProgress()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case project.FieldTotalTasks:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.AddTotalTasks(v)
                return nil</span>
        case project.FieldCompletedTasks:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.AddCompletedTasks(v)
                return nil</span>
        case project.FieldProgress:<span class="cov0" title="0">
                v, ok := value.(float64)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.AddProgress(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Project numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string <span class="cov0" title="0">{
        var fields []string
        if m.FieldCleared(project.FieldDescription) </span><span class="cov0" title="0">{
                fields = append(fields, project.FieldDescription)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case project.FieldDescription:<span class="cov0" title="0">
                m.ClearDescription()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Project nullable field %s", name)</span>
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case project.FieldTitle:<span class="cov0" title="0">
                m.ResetTitle()
                return nil</span>
        case project.FieldDescription:<span class="cov0" title="0">
                m.ResetDescription()
                return nil</span>
        case project.FieldState:<span class="cov0" title="0">
                m.ResetState()
                return nil</span>
        case project.FieldCreatedAt:<span class="cov0" title="0">
                m.ResetCreatedAt()
                return nil</span>
        case project.FieldUpdatedAt:<span class="cov0" title="0">
                m.ResetUpdatedAt()
                return nil</span>
        case project.FieldTotalTasks:<span class="cov0" title="0">
                m.ResetTotalTasks()
                return nil</span>
        case project.FieldCompletedTasks:<span class="cov0" title="0">
                m.ResetCompletedTasks()
                return nil</span>
        case project.FieldProgress:<span class="cov0" title="0">
                m.ResetProgress()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Project field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        if m.tasks != nil </span><span class="cov0" title="0">{
                edges = append(edges, project.EdgeTasks)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case project.EdgeTasks:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.tasks))
                for id := range m.tasks </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        if m.removedtasks != nil </span><span class="cov0" title="0">{
                edges = append(edges, project.EdgeTasks)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case project.EdgeTasks:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.removedtasks))
                for id := range m.removedtasks </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        if m.clearedtasks </span><span class="cov0" title="0">{
                edges = append(edges, project.EdgeTasks)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case project.EdgeTasks:<span class="cov0" title="0">
                return m.clearedtasks</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Project unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case project.EdgeTasks:<span class="cov0" title="0">
                m.ResetTasks()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Project edge %s", name)</span>
}

// ProjectContextMutation represents an operation that mutates the ProjectContext nodes in the graph.
type ProjectContextMutation struct {
        config
        op                      Op
        typ                     string
        id                      *int
        updated_at              *time.Time
        updated_by              *string
        clearedFields           map[string]struct{}
        selected_project        *uuid.UUID
        clearedselected_project bool
        done                    bool
        oldValue                func(context.Context) (*ProjectContext, error)
        predicates              []predicate.ProjectContext
}

var _ ent.Mutation = (*ProjectContextMutation)(nil)

// projectcontextOption allows management of the mutation configuration using functional options.
type projectcontextOption func(*ProjectContextMutation)

// newProjectContextMutation creates new mutation for the ProjectContext entity.
func newProjectContextMutation(c config, op Op, opts ...projectcontextOption) *ProjectContextMutation <span class="cov0" title="0">{
        m := &amp;ProjectContextMutation{
                config:        c,
                op:            op,
                typ:           TypeProjectContext,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(m)
        }</span>
        <span class="cov0" title="0">return m</span>
}

// withProjectContextID sets the ID field of the mutation.
func withProjectContextID(id int) projectcontextOption <span class="cov0" title="0">{
        return func(m *ProjectContextMutation) </span><span class="cov0" title="0">{
                var (
                        err   error
                        once  sync.Once
                        value *ProjectContext
                )
                m.oldValue = func(ctx context.Context) (*ProjectContext, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().ProjectContext.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov0" title="0">m.id = &amp;id</span>
        }
}

// withProjectContext sets the old ProjectContext of the mutation.
func withProjectContext(node *ProjectContext) projectcontextOption <span class="cov0" title="0">{
        return func(m *ProjectContextMutation) </span><span class="cov0" title="0">{
                m.oldValue = func(context.Context) (*ProjectContext, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov0" title="0">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectContextMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectContextMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectContext entities.
func (m *ProjectContextMutation) SetID(id int) <span class="cov0" title="0">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectContextMutation) ID() (id int, exists bool) <span class="cov0" title="0">{
        if m.id == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectContextMutation) IDs(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []int{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().ProjectContext.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetSelectedProjectID sets the "selected_project_id" field.
func (m *ProjectContextMutation) SetSelectedProjectID(u uuid.UUID) <span class="cov0" title="0">{
        m.selected_project = &amp;u
}</span>

// SelectedProjectID returns the value of the "selected_project_id" field in the mutation.
func (m *ProjectContextMutation) SelectedProjectID() (r uuid.UUID, exists bool) <span class="cov0" title="0">{
        v := m.selected_project
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldSelectedProjectID returns the old "selected_project_id" field's value of the ProjectContext entity.
// If the ProjectContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectContextMutation) OldSelectedProjectID(ctx context.Context) (v uuid.UUID, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldSelectedProjectID is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldSelectedProjectID requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldSelectedProjectID: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.SelectedProjectID, nil</span>
}

// ClearSelectedProjectID clears the value of the "selected_project_id" field.
func (m *ProjectContextMutation) ClearSelectedProjectID() <span class="cov0" title="0">{
        m.selected_project = nil
        m.clearedFields[projectcontext.FieldSelectedProjectID] = struct{}{}
}</span>

// SelectedProjectIDCleared returns if the "selected_project_id" field was cleared in this mutation.
func (m *ProjectContextMutation) SelectedProjectIDCleared() bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[projectcontext.FieldSelectedProjectID]
        return ok
}</span>

// ResetSelectedProjectID resets all changes to the "selected_project_id" field.
func (m *ProjectContextMutation) ResetSelectedProjectID() <span class="cov0" title="0">{
        m.selected_project = nil
        delete(m.clearedFields, projectcontext.FieldSelectedProjectID)
}</span>

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectContextMutation) SetUpdatedAt(t time.Time) <span class="cov0" title="0">{
        m.updated_at = &amp;t
}</span>

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectContextMutation) UpdatedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.updated_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectContext entity.
// If the ProjectContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectContextMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.UpdatedAt, nil</span>
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectContextMutation) ResetUpdatedAt() <span class="cov0" title="0">{
        m.updated_at = nil
}</span>

// SetUpdatedBy sets the "updated_by" field.
func (m *ProjectContextMutation) SetUpdatedBy(s string) <span class="cov0" title="0">{
        m.updated_by = &amp;s
}</span>

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProjectContextMutation) UpdatedBy() (r string, exists bool) <span class="cov0" title="0">{
        v := m.updated_by
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProjectContext entity.
// If the ProjectContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectContextMutation) OldUpdatedBy(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.UpdatedBy, nil</span>
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProjectContextMutation) ResetUpdatedBy() <span class="cov0" title="0">{
        m.updated_by = nil
}</span>

// ClearSelectedProject clears the "selected_project" edge to the Project entity.
func (m *ProjectContextMutation) ClearSelectedProject() <span class="cov0" title="0">{
        m.clearedselected_project = true
        m.clearedFields[projectcontext.FieldSelectedProjectID] = struct{}{}
}</span>

// SelectedProjectCleared reports if the "selected_project" edge to the Project entity was cleared.
func (m *ProjectContextMutation) SelectedProjectCleared() bool <span class="cov0" title="0">{
        return m.SelectedProjectIDCleared() || m.clearedselected_project
}</span>

// SelectedProjectIDs returns the "selected_project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// SelectedProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectContextMutation) SelectedProjectIDs() (ids []uuid.UUID) <span class="cov0" title="0">{
        if id := m.selected_project; id != nil </span><span class="cov0" title="0">{
                ids = append(ids, *id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetSelectedProject resets all changes to the "selected_project" edge.
func (m *ProjectContextMutation) ResetSelectedProject() <span class="cov0" title="0">{
        m.selected_project = nil
        m.clearedselected_project = false
}</span>

// Where appends a list predicates to the ProjectContextMutation builder.
func (m *ProjectContextMutation) Where(ps ...predicate.ProjectContext) <span class="cov0" title="0">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the ProjectContextMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectContextMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.ProjectContext, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *ProjectContextMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *ProjectContextMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (ProjectContext).
func (m *ProjectContextMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectContextMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 3)
        if m.selected_project != nil </span><span class="cov0" title="0">{
                fields = append(fields, projectcontext.FieldSelectedProjectID)
        }</span>
        <span class="cov0" title="0">if m.updated_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, projectcontext.FieldUpdatedAt)
        }</span>
        <span class="cov0" title="0">if m.updated_by != nil </span><span class="cov0" title="0">{
                fields = append(fields, projectcontext.FieldUpdatedBy)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectContextMutation) Field(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case projectcontext.FieldSelectedProjectID:<span class="cov0" title="0">
                return m.SelectedProjectID()</span>
        case projectcontext.FieldUpdatedAt:<span class="cov0" title="0">
                return m.UpdatedAt()</span>
        case projectcontext.FieldUpdatedBy:<span class="cov0" title="0">
                return m.UpdatedBy()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectContextMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case projectcontext.FieldSelectedProjectID:<span class="cov0" title="0">
                return m.OldSelectedProjectID(ctx)</span>
        case projectcontext.FieldUpdatedAt:<span class="cov0" title="0">
                return m.OldUpdatedAt(ctx)</span>
        case projectcontext.FieldUpdatedBy:<span class="cov0" title="0">
                return m.OldUpdatedBy(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown ProjectContext field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectContextMutation) SetField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case projectcontext.FieldSelectedProjectID:<span class="cov0" title="0">
                v, ok := value.(uuid.UUID)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetSelectedProjectID(v)
                return nil</span>
        case projectcontext.FieldUpdatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetUpdatedAt(v)
                return nil</span>
        case projectcontext.FieldUpdatedBy:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetUpdatedBy(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown ProjectContext field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectContextMutation) AddedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectContextMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        return nil, false
}</span>

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectContextMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown ProjectContext numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectContextMutation) ClearedFields() []string <span class="cov0" title="0">{
        var fields []string
        if m.FieldCleared(projectcontext.FieldSelectedProjectID) </span><span class="cov0" title="0">{
                fields = append(fields, projectcontext.FieldSelectedProjectID)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectContextMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectContextMutation) ClearField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case projectcontext.FieldSelectedProjectID:<span class="cov0" title="0">
                m.ClearSelectedProjectID()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown ProjectContext nullable field %s", name)</span>
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectContextMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case projectcontext.FieldSelectedProjectID:<span class="cov0" title="0">
                m.ResetSelectedProjectID()
                return nil</span>
        case projectcontext.FieldUpdatedAt:<span class="cov0" title="0">
                m.ResetUpdatedAt()
                return nil</span>
        case projectcontext.FieldUpdatedBy:<span class="cov0" title="0">
                m.ResetUpdatedBy()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown ProjectContext field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectContextMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        if m.selected_project != nil </span><span class="cov0" title="0">{
                edges = append(edges, projectcontext.EdgeSelectedProject)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectContextMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case projectcontext.EdgeSelectedProject:<span class="cov0" title="0">
                if id := m.selected_project; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectContextMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        return edges
}</span>

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectContextMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        return nil
}</span>

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectContextMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        if m.clearedselected_project </span><span class="cov0" title="0">{
                edges = append(edges, projectcontext.EdgeSelectedProject)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectContextMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case projectcontext.EdgeSelectedProject:<span class="cov0" title="0">
                return m.clearedselected_project</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectContextMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case projectcontext.EdgeSelectedProject:<span class="cov0" title="0">
                m.ClearSelectedProject()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown ProjectContext unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectContextMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case projectcontext.EdgeSelectedProject:<span class="cov0" title="0">
                m.ResetSelectedProject()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown ProjectContext edge %s", name)</span>
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
        config
        op              Op
        typ             string
        id              *uuid.UUID
        title           *string
        description     *string
        state           *task.State
        priority        *task.Priority
        complexity      *int
        addcomplexity   *int
        depth           *int
        adddepth        *int
        estimate        *int64
        addestimate     *int64
        assigned_agent  *uuid.UUID
        created_at      *time.Time
        updated_at      *time.Time
        completed_at    *time.Time
        clearedFields   map[string]struct{}
        project         *uuid.UUID
        clearedproject  bool
        parent          *uuid.UUID
        clearedparent   bool
        children        map[uuid.UUID]struct{}
        removedchildren map[uuid.UUID]struct{}
        clearedchildren bool
        done            bool
        oldValue        func(context.Context) (*Task, error)
        predicates      []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation <span class="cov0" title="0">{
        m := &amp;TaskMutation{
                config:        c,
                op:            op,
                typ:           TypeTask,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(m)
        }</span>
        <span class="cov0" title="0">return m</span>
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uuid.UUID) taskOption <span class="cov0" title="0">{
        return func(m *TaskMutation) </span><span class="cov0" title="0">{
                var (
                        err   error
                        once  sync.Once
                        value *Task
                )
                m.oldValue = func(ctx context.Context) (*Task, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().Task.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov0" title="0">m.id = &amp;id</span>
        }
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption <span class="cov0" title="0">{
        return func(m *TaskMutation) </span><span class="cov0" title="0">{
                m.oldValue = func(context.Context) (*Task, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov0" title="0">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uuid.UUID) <span class="cov0" title="0">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uuid.UUID, exists bool) <span class="cov0" title="0">{
        if m.id == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []uuid.UUID{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetProjectID sets the "project_id" field.
func (m *TaskMutation) SetProjectID(u uuid.UUID) <span class="cov0" title="0">{
        m.project = &amp;u
}</span>

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TaskMutation) ProjectID() (r uuid.UUID, exists bool) <span class="cov0" title="0">{
        v := m.project
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldProjectID returns the old "project_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldProjectID requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.ProjectID, nil</span>
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TaskMutation) ResetProjectID() <span class="cov0" title="0">{
        m.project = nil
}</span>

// SetParentID sets the "parent_id" field.
func (m *TaskMutation) SetParentID(u uuid.UUID) <span class="cov0" title="0">{
        m.parent = &amp;u
}</span>

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *TaskMutation) ParentID() (r uuid.UUID, exists bool) <span class="cov0" title="0">{
        v := m.parent
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldParentID returns the old "parent_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldParentID(ctx context.Context) (v *uuid.UUID, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldParentID is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldParentID requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldParentID: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.ParentID, nil</span>
}

// ClearParentID clears the value of the "parent_id" field.
func (m *TaskMutation) ClearParentID() <span class="cov0" title="0">{
        m.parent = nil
        m.clearedFields[task.FieldParentID] = struct{}{}
}</span>

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *TaskMutation) ParentIDCleared() bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[task.FieldParentID]
        return ok
}</span>

// ResetParentID resets all changes to the "parent_id" field.
func (m *TaskMutation) ResetParentID() <span class="cov0" title="0">{
        m.parent = nil
        delete(m.clearedFields, task.FieldParentID)
}</span>

// SetTitle sets the "title" field.
func (m *TaskMutation) SetTitle(s string) <span class="cov0" title="0">{
        m.title = &amp;s
}</span>

// Title returns the value of the "title" field in the mutation.
func (m *TaskMutation) Title() (r string, exists bool) <span class="cov0" title="0">{
        v := m.title
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldTitle returns the old "title" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTitle(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldTitle is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldTitle requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldTitle: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Title, nil</span>
}

// ResetTitle resets all changes to the "title" field.
func (m *TaskMutation) ResetTitle() <span class="cov0" title="0">{
        m.title = nil
}</span>

// SetDescription sets the "description" field.
func (m *TaskMutation) SetDescription(s string) <span class="cov0" title="0">{
        m.description = &amp;s
}</span>

// Description returns the value of the "description" field in the mutation.
func (m *TaskMutation) Description() (r string, exists bool) <span class="cov0" title="0">{
        v := m.description
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldDescription returns the old "description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDescription(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldDescription is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldDescription requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldDescription: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Description, nil</span>
}

// ClearDescription clears the value of the "description" field.
func (m *TaskMutation) ClearDescription() <span class="cov0" title="0">{
        m.description = nil
        m.clearedFields[task.FieldDescription] = struct{}{}
}</span>

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TaskMutation) DescriptionCleared() bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[task.FieldDescription]
        return ok
}</span>

// ResetDescription resets all changes to the "description" field.
func (m *TaskMutation) ResetDescription() <span class="cov0" title="0">{
        m.description = nil
        delete(m.clearedFields, task.FieldDescription)
}</span>

// SetState sets the "state" field.
func (m *TaskMutation) SetState(t task.State) <span class="cov0" title="0">{
        m.state = &amp;t
}</span>

// State returns the value of the "state" field in the mutation.
func (m *TaskMutation) State() (r task.State, exists bool) <span class="cov0" title="0">{
        v := m.state
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldState returns the old "state" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldState(ctx context.Context) (v task.State, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldState is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldState requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldState: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.State, nil</span>
}

// ResetState resets all changes to the "state" field.
func (m *TaskMutation) ResetState() <span class="cov0" title="0">{
        m.state = nil
}</span>

// SetPriority sets the "priority" field.
func (m *TaskMutation) SetPriority(t task.Priority) <span class="cov0" title="0">{
        m.priority = &amp;t
}</span>

// Priority returns the value of the "priority" field in the mutation.
func (m *TaskMutation) Priority() (r task.Priority, exists bool) <span class="cov0" title="0">{
        v := m.priority
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldPriority returns the old "priority" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPriority(ctx context.Context) (v task.Priority, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldPriority is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldPriority requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldPriority: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Priority, nil</span>
}

// ResetPriority resets all changes to the "priority" field.
func (m *TaskMutation) ResetPriority() <span class="cov0" title="0">{
        m.priority = nil
}</span>

// SetComplexity sets the "complexity" field.
func (m *TaskMutation) SetComplexity(i int) <span class="cov0" title="0">{
        m.complexity = &amp;i
        m.addcomplexity = nil
}</span>

// Complexity returns the value of the "complexity" field in the mutation.
func (m *TaskMutation) Complexity() (r int, exists bool) <span class="cov0" title="0">{
        v := m.complexity
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldComplexity returns the old "complexity" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldComplexity(ctx context.Context) (v int, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldComplexity is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldComplexity requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldComplexity: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Complexity, nil</span>
}

// AddComplexity adds i to the "complexity" field.
func (m *TaskMutation) AddComplexity(i int) <span class="cov0" title="0">{
        if m.addcomplexity != nil </span><span class="cov0" title="0">{
                *m.addcomplexity += i
        }</span> else<span class="cov0" title="0"> {
                m.addcomplexity = &amp;i
        }</span>
}

// AddedComplexity returns the value that was added to the "complexity" field in this mutation.
func (m *TaskMutation) AddedComplexity() (r int, exists bool) <span class="cov0" title="0">{
        v := m.addcomplexity
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// ResetComplexity resets all changes to the "complexity" field.
func (m *TaskMutation) ResetComplexity() <span class="cov0" title="0">{
        m.complexity = nil
        m.addcomplexity = nil
}</span>

// SetDepth sets the "depth" field.
func (m *TaskMutation) SetDepth(i int) <span class="cov0" title="0">{
        m.depth = &amp;i
        m.adddepth = nil
}</span>

// Depth returns the value of the "depth" field in the mutation.
func (m *TaskMutation) Depth() (r int, exists bool) <span class="cov0" title="0">{
        v := m.depth
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldDepth returns the old "depth" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDepth(ctx context.Context) (v int, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldDepth is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldDepth requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldDepth: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Depth, nil</span>
}

// AddDepth adds i to the "depth" field.
func (m *TaskMutation) AddDepth(i int) <span class="cov0" title="0">{
        if m.adddepth != nil </span><span class="cov0" title="0">{
                *m.adddepth += i
        }</span> else<span class="cov0" title="0"> {
                m.adddepth = &amp;i
        }</span>
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *TaskMutation) AddedDepth() (r int, exists bool) <span class="cov0" title="0">{
        v := m.adddepth
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// ResetDepth resets all changes to the "depth" field.
func (m *TaskMutation) ResetDepth() <span class="cov0" title="0">{
        m.depth = nil
        m.adddepth = nil
}</span>

// SetEstimate sets the "estimate" field.
func (m *TaskMutation) SetEstimate(i int64) <span class="cov0" title="0">{
        m.estimate = &amp;i
        m.addestimate = nil
}</span>

// Estimate returns the value of the "estimate" field in the mutation.
func (m *TaskMutation) Estimate() (r int64, exists bool) <span class="cov0" title="0">{
        v := m.estimate
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldEstimate returns the old "estimate" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldEstimate(ctx context.Context) (v *int64, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldEstimate is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldEstimate requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldEstimate: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Estimate, nil</span>
}

// AddEstimate adds i to the "estimate" field.
func (m *TaskMutation) AddEstimate(i int64) <span class="cov0" title="0">{
        if m.addestimate != nil </span><span class="cov0" title="0">{
                *m.addestimate += i
        }</span> else<span class="cov0" title="0"> {
                m.addestimate = &amp;i
        }</span>
}

// AddedEstimate returns the value that was added to the "estimate" field in this mutation.
func (m *TaskMutation) AddedEstimate() (r int64, exists bool) <span class="cov0" title="0">{
        v := m.addestimate
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// ClearEstimate clears the value of the "estimate" field.
func (m *TaskMutation) ClearEstimate() <span class="cov0" title="0">{
        m.estimate = nil
        m.addestimate = nil
        m.clearedFields[task.FieldEstimate] = struct{}{}
}</span>

// EstimateCleared returns if the "estimate" field was cleared in this mutation.
func (m *TaskMutation) EstimateCleared() bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[task.FieldEstimate]
        return ok
}</span>

// ResetEstimate resets all changes to the "estimate" field.
func (m *TaskMutation) ResetEstimate() <span class="cov0" title="0">{
        m.estimate = nil
        m.addestimate = nil
        delete(m.clearedFields, task.FieldEstimate)
}</span>

// SetAssignedAgent sets the "assigned_agent" field.
func (m *TaskMutation) SetAssignedAgent(u uuid.UUID) <span class="cov0" title="0">{
        m.assigned_agent = &amp;u
}</span>

// AssignedAgent returns the value of the "assigned_agent" field in the mutation.
func (m *TaskMutation) AssignedAgent() (r uuid.UUID, exists bool) <span class="cov0" title="0">{
        v := m.assigned_agent
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldAssignedAgent returns the old "assigned_agent" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAssignedAgent(ctx context.Context) (v *uuid.UUID, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldAssignedAgent is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldAssignedAgent requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldAssignedAgent: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.AssignedAgent, nil</span>
}

// ClearAssignedAgent clears the value of the "assigned_agent" field.
func (m *TaskMutation) ClearAssignedAgent() <span class="cov0" title="0">{
        m.assigned_agent = nil
        m.clearedFields[task.FieldAssignedAgent] = struct{}{}
}</span>

// AssignedAgentCleared returns if the "assigned_agent" field was cleared in this mutation.
func (m *TaskMutation) AssignedAgentCleared() bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[task.FieldAssignedAgent]
        return ok
}</span>

// ResetAssignedAgent resets all changes to the "assigned_agent" field.
func (m *TaskMutation) ResetAssignedAgent() <span class="cov0" title="0">{
        m.assigned_agent = nil
        delete(m.clearedFields, task.FieldAssignedAgent)
}</span>

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) <span class="cov0" title="0">{
        m.created_at = &amp;t
}</span>

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.created_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CreatedAt, nil</span>
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() <span class="cov0" title="0">{
        m.created_at = nil
}</span>

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) <span class="cov0" title="0">{
        m.updated_at = &amp;t
}</span>

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.updated_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.UpdatedAt, nil</span>
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() <span class="cov0" title="0">{
        m.updated_at = nil
}</span>

// SetCompletedAt sets the "completed_at" field.
func (m *TaskMutation) SetCompletedAt(t time.Time) <span class="cov0" title="0">{
        m.completed_at = &amp;t
}</span>

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *TaskMutation) CompletedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.completed_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldCompletedAt returns the old "completed_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCompletedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CompletedAt, nil</span>
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *TaskMutation) ClearCompletedAt() <span class="cov0" title="0">{
        m.completed_at = nil
        m.clearedFields[task.FieldCompletedAt] = struct{}{}
}</span>

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *TaskMutation) CompletedAtCleared() bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[task.FieldCompletedAt]
        return ok
}</span>

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *TaskMutation) ResetCompletedAt() <span class="cov0" title="0">{
        m.completed_at = nil
        delete(m.clearedFields, task.FieldCompletedAt)
}</span>

// ClearProject clears the "project" edge to the Project entity.
func (m *TaskMutation) ClearProject() <span class="cov0" title="0">{
        m.clearedproject = true
        m.clearedFields[task.FieldProjectID] = struct{}{}
}</span>

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TaskMutation) ProjectCleared() bool <span class="cov0" title="0">{
        return m.clearedproject
}</span>

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ProjectIDs() (ids []uuid.UUID) <span class="cov0" title="0">{
        if id := m.project; id != nil </span><span class="cov0" title="0">{
                ids = append(ids, *id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetProject resets all changes to the "project" edge.
func (m *TaskMutation) ResetProject() <span class="cov0" title="0">{
        m.project = nil
        m.clearedproject = false
}</span>

// ClearParent clears the "parent" edge to the Task entity.
func (m *TaskMutation) ClearParent() <span class="cov0" title="0">{
        m.clearedparent = true
        m.clearedFields[task.FieldParentID] = struct{}{}
}</span>

// ParentCleared reports if the "parent" edge to the Task entity was cleared.
func (m *TaskMutation) ParentCleared() bool <span class="cov0" title="0">{
        return m.ParentIDCleared() || m.clearedparent
}</span>

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ParentIDs() (ids []uuid.UUID) <span class="cov0" title="0">{
        if id := m.parent; id != nil </span><span class="cov0" title="0">{
                ids = append(ids, *id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetParent resets all changes to the "parent" edge.
func (m *TaskMutation) ResetParent() <span class="cov0" title="0">{
        m.parent = nil
        m.clearedparent = false
}</span>

// AddChildIDs adds the "children" edge to the Task entity by ids.
func (m *TaskMutation) AddChildIDs(ids ...uuid.UUID) <span class="cov0" title="0">{
        if m.children == nil </span><span class="cov0" title="0">{
                m.children = make(map[uuid.UUID]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                m.children[ids[i]] = struct{}{}
        }</span>
}

// ClearChildren clears the "children" edge to the Task entity.
func (m *TaskMutation) ClearChildren() <span class="cov0" title="0">{
        m.clearedchildren = true
}</span>

// ChildrenCleared reports if the "children" edge to the Task entity was cleared.
func (m *TaskMutation) ChildrenCleared() bool <span class="cov0" title="0">{
        return m.clearedchildren
}</span>

// RemoveChildIDs removes the "children" edge to the Task entity by IDs.
func (m *TaskMutation) RemoveChildIDs(ids ...uuid.UUID) <span class="cov0" title="0">{
        if m.removedchildren == nil </span><span class="cov0" title="0">{
                m.removedchildren = make(map[uuid.UUID]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                delete(m.children, ids[i])
                m.removedchildren[ids[i]] = struct{}{}
        }</span>
}

// RemovedChildren returns the removed IDs of the "children" edge to the Task entity.
func (m *TaskMutation) RemovedChildrenIDs() (ids []uuid.UUID) <span class="cov0" title="0">{
        for id := range m.removedchildren </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TaskMutation) ChildrenIDs() (ids []uuid.UUID) <span class="cov0" title="0">{
        for id := range m.children </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetChildren resets all changes to the "children" edge.
func (m *TaskMutation) ResetChildren() <span class="cov0" title="0">{
        m.children = nil
        m.clearedchildren = false
        m.removedchildren = nil
}</span>

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) <span class="cov0" title="0">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.Task, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 13)
        if m.project != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldProjectID)
        }</span>
        <span class="cov0" title="0">if m.parent != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldParentID)
        }</span>
        <span class="cov0" title="0">if m.title != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldTitle)
        }</span>
        <span class="cov0" title="0">if m.description != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldDescription)
        }</span>
        <span class="cov0" title="0">if m.state != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldState)
        }</span>
        <span class="cov0" title="0">if m.priority != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldPriority)
        }</span>
        <span class="cov0" title="0">if m.complexity != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldComplexity)
        }</span>
        <span class="cov0" title="0">if m.depth != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldDepth)
        }</span>
        <span class="cov0" title="0">if m.estimate != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldEstimate)
        }</span>
        <span class="cov0" title="0">if m.assigned_agent != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldAssignedAgent)
        }</span>
        <span class="cov0" title="0">if m.created_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldCreatedAt)
        }</span>
        <span class="cov0" title="0">if m.updated_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldUpdatedAt)
        }</span>
        <span class="cov0" title="0">if m.completed_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldCompletedAt)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case task.FieldProjectID:<span class="cov0" title="0">
                return m.ProjectID()</span>
        case task.FieldParentID:<span class="cov0" title="0">
                return m.ParentID()</span>
        case task.FieldTitle:<span class="cov0" title="0">
                return m.Title()</span>
        case task.FieldDescription:<span class="cov0" title="0">
                return m.Description()</span>
        case task.FieldState:<span class="cov0" title="0">
                return m.State()</span>
        case task.FieldPriority:<span class="cov0" title="0">
                return m.Priority()</span>
        case task.FieldComplexity:<span class="cov0" title="0">
                return m.Complexity()</span>
        case task.FieldDepth:<span class="cov0" title="0">
                return m.Depth()</span>
        case task.FieldEstimate:<span class="cov0" title="0">
                return m.Estimate()</span>
        case task.FieldAssignedAgent:<span class="cov0" title="0">
                return m.AssignedAgent()</span>
        case task.FieldCreatedAt:<span class="cov0" title="0">
                return m.CreatedAt()</span>
        case task.FieldUpdatedAt:<span class="cov0" title="0">
                return m.UpdatedAt()</span>
        case task.FieldCompletedAt:<span class="cov0" title="0">
                return m.CompletedAt()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case task.FieldProjectID:<span class="cov0" title="0">
                return m.OldProjectID(ctx)</span>
        case task.FieldParentID:<span class="cov0" title="0">
                return m.OldParentID(ctx)</span>
        case task.FieldTitle:<span class="cov0" title="0">
                return m.OldTitle(ctx)</span>
        case task.FieldDescription:<span class="cov0" title="0">
                return m.OldDescription(ctx)</span>
        case task.FieldState:<span class="cov0" title="0">
                return m.OldState(ctx)</span>
        case task.FieldPriority:<span class="cov0" title="0">
                return m.OldPriority(ctx)</span>
        case task.FieldComplexity:<span class="cov0" title="0">
                return m.OldComplexity(ctx)</span>
        case task.FieldDepth:<span class="cov0" title="0">
                return m.OldDepth(ctx)</span>
        case task.FieldEstimate:<span class="cov0" title="0">
                return m.OldEstimate(ctx)</span>
        case task.FieldAssignedAgent:<span class="cov0" title="0">
                return m.OldAssignedAgent(ctx)</span>
        case task.FieldCreatedAt:<span class="cov0" title="0">
                return m.OldCreatedAt(ctx)</span>
        case task.FieldUpdatedAt:<span class="cov0" title="0">
                return m.OldUpdatedAt(ctx)</span>
        case task.FieldCompletedAt:<span class="cov0" title="0">
                return m.OldCompletedAt(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown Task field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case task.FieldProjectID:<span class="cov0" title="0">
                v, ok := value.(uuid.UUID)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetProjectID(v)
                return nil</span>
        case task.FieldParentID:<span class="cov0" title="0">
                v, ok := value.(uuid.UUID)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetParentID(v)
                return nil</span>
        case task.FieldTitle:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetTitle(v)
                return nil</span>
        case task.FieldDescription:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetDescription(v)
                return nil</span>
        case task.FieldState:<span class="cov0" title="0">
                v, ok := value.(task.State)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetState(v)
                return nil</span>
        case task.FieldPriority:<span class="cov0" title="0">
                v, ok := value.(task.Priority)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetPriority(v)
                return nil</span>
        case task.FieldComplexity:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetComplexity(v)
                return nil</span>
        case task.FieldDepth:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetDepth(v)
                return nil</span>
        case task.FieldEstimate:<span class="cov0" title="0">
                v, ok := value.(int64)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetEstimate(v)
                return nil</span>
        case task.FieldAssignedAgent:<span class="cov0" title="0">
                v, ok := value.(uuid.UUID)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetAssignedAgent(v)
                return nil</span>
        case task.FieldCreatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCreatedAt(v)
                return nil</span>
        case task.FieldUpdatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetUpdatedAt(v)
                return nil</span>
        case task.FieldCompletedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCompletedAt(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Task field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string <span class="cov0" title="0">{
        var fields []string
        if m.addcomplexity != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldComplexity)
        }</span>
        <span class="cov0" title="0">if m.adddepth != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldDepth)
        }</span>
        <span class="cov0" title="0">if m.addestimate != nil </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldEstimate)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case task.FieldComplexity:<span class="cov0" title="0">
                return m.AddedComplexity()</span>
        case task.FieldDepth:<span class="cov0" title="0">
                return m.AddedDepth()</span>
        case task.FieldEstimate:<span class="cov0" title="0">
                return m.AddedEstimate()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case task.FieldComplexity:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.AddComplexity(v)
                return nil</span>
        case task.FieldDepth:<span class="cov0" title="0">
                v, ok := value.(int)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.AddDepth(v)
                return nil</span>
        case task.FieldEstimate:<span class="cov0" title="0">
                v, ok := value.(int64)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.AddEstimate(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Task numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string <span class="cov0" title="0">{
        var fields []string
        if m.FieldCleared(task.FieldParentID) </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldParentID)
        }</span>
        <span class="cov0" title="0">if m.FieldCleared(task.FieldDescription) </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldDescription)
        }</span>
        <span class="cov0" title="0">if m.FieldCleared(task.FieldEstimate) </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldEstimate)
        }</span>
        <span class="cov0" title="0">if m.FieldCleared(task.FieldAssignedAgent) </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldAssignedAgent)
        }</span>
        <span class="cov0" title="0">if m.FieldCleared(task.FieldCompletedAt) </span><span class="cov0" title="0">{
                fields = append(fields, task.FieldCompletedAt)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case task.FieldParentID:<span class="cov0" title="0">
                m.ClearParentID()
                return nil</span>
        case task.FieldDescription:<span class="cov0" title="0">
                m.ClearDescription()
                return nil</span>
        case task.FieldEstimate:<span class="cov0" title="0">
                m.ClearEstimate()
                return nil</span>
        case task.FieldAssignedAgent:<span class="cov0" title="0">
                m.ClearAssignedAgent()
                return nil</span>
        case task.FieldCompletedAt:<span class="cov0" title="0">
                m.ClearCompletedAt()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Task nullable field %s", name)</span>
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case task.FieldProjectID:<span class="cov0" title="0">
                m.ResetProjectID()
                return nil</span>
        case task.FieldParentID:<span class="cov0" title="0">
                m.ResetParentID()
                return nil</span>
        case task.FieldTitle:<span class="cov0" title="0">
                m.ResetTitle()
                return nil</span>
        case task.FieldDescription:<span class="cov0" title="0">
                m.ResetDescription()
                return nil</span>
        case task.FieldState:<span class="cov0" title="0">
                m.ResetState()
                return nil</span>
        case task.FieldPriority:<span class="cov0" title="0">
                m.ResetPriority()
                return nil</span>
        case task.FieldComplexity:<span class="cov0" title="0">
                m.ResetComplexity()
                return nil</span>
        case task.FieldDepth:<span class="cov0" title="0">
                m.ResetDepth()
                return nil</span>
        case task.FieldEstimate:<span class="cov0" title="0">
                m.ResetEstimate()
                return nil</span>
        case task.FieldAssignedAgent:<span class="cov0" title="0">
                m.ResetAssignedAgent()
                return nil</span>
        case task.FieldCreatedAt:<span class="cov0" title="0">
                m.ResetCreatedAt()
                return nil</span>
        case task.FieldUpdatedAt:<span class="cov0" title="0">
                m.ResetUpdatedAt()
                return nil</span>
        case task.FieldCompletedAt:<span class="cov0" title="0">
                m.ResetCompletedAt()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Task field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 3)
        if m.project != nil </span><span class="cov0" title="0">{
                edges = append(edges, task.EdgeProject)
        }</span>
        <span class="cov0" title="0">if m.parent != nil </span><span class="cov0" title="0">{
                edges = append(edges, task.EdgeParent)
        }</span>
        <span class="cov0" title="0">if m.children != nil </span><span class="cov0" title="0">{
                edges = append(edges, task.EdgeChildren)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case task.EdgeProject:<span class="cov0" title="0">
                if id := m.project; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        case task.EdgeParent:<span class="cov0" title="0">
                if id := m.parent; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        case task.EdgeChildren:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.children))
                for id := range m.children </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 3)
        if m.removedchildren != nil </span><span class="cov0" title="0">{
                edges = append(edges, task.EdgeChildren)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case task.EdgeChildren:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.removedchildren))
                for id := range m.removedchildren </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 3)
        if m.clearedproject </span><span class="cov0" title="0">{
                edges = append(edges, task.EdgeProject)
        }</span>
        <span class="cov0" title="0">if m.clearedparent </span><span class="cov0" title="0">{
                edges = append(edges, task.EdgeParent)
        }</span>
        <span class="cov0" title="0">if m.clearedchildren </span><span class="cov0" title="0">{
                edges = append(edges, task.EdgeChildren)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case task.EdgeProject:<span class="cov0" title="0">
                return m.clearedproject</span>
        case task.EdgeParent:<span class="cov0" title="0">
                return m.clearedparent</span>
        case task.EdgeChildren:<span class="cov0" title="0">
                return m.clearedchildren</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case task.EdgeProject:<span class="cov0" title="0">
                m.ClearProject()
                return nil</span>
        case task.EdgeParent:<span class="cov0" title="0">
                m.ClearParent()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Task unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case task.EdgeProject:<span class="cov0" title="0">
                m.ResetProject()
                return nil</span>
        case task.EdgeParent:<span class="cov0" title="0">
                m.ResetParent()
                return nil</span>
        case task.EdgeChildren:<span class="cov0" title="0">
                m.ResetChildren()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Task edge %s", name)</span>
}

// TaskDependencyMutation represents an operation that mutates the TaskDependency nodes in the graph.
type TaskDependencyMutation struct {
        config
        op                     Op
        typ                    string
        id                     *uuid.UUID
        created_at             *time.Time
        clearedFields          map[string]struct{}
        task                   *uuid.UUID
        clearedtask            bool
        depends_on_task        *uuid.UUID
        cleareddepends_on_task bool
        done                   bool
        oldValue               func(context.Context) (*TaskDependency, error)
        predicates             []predicate.TaskDependency
}

var _ ent.Mutation = (*TaskDependencyMutation)(nil)

// taskdependencyOption allows management of the mutation configuration using functional options.
type taskdependencyOption func(*TaskDependencyMutation)

// newTaskDependencyMutation creates new mutation for the TaskDependency entity.
func newTaskDependencyMutation(c config, op Op, opts ...taskdependencyOption) *TaskDependencyMutation <span class="cov0" title="0">{
        m := &amp;TaskDependencyMutation{
                config:        c,
                op:            op,
                typ:           TypeTaskDependency,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(m)
        }</span>
        <span class="cov0" title="0">return m</span>
}

// withTaskDependencyID sets the ID field of the mutation.
func withTaskDependencyID(id uuid.UUID) taskdependencyOption <span class="cov0" title="0">{
        return func(m *TaskDependencyMutation) </span><span class="cov0" title="0">{
                var (
                        err   error
                        once  sync.Once
                        value *TaskDependency
                )
                m.oldValue = func(ctx context.Context) (*TaskDependency, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().TaskDependency.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov0" title="0">m.id = &amp;id</span>
        }
}

// withTaskDependency sets the old TaskDependency of the mutation.
func withTaskDependency(node *TaskDependency) taskdependencyOption <span class="cov0" title="0">{
        return func(m *TaskDependencyMutation) </span><span class="cov0" title="0">{
                m.oldValue = func(context.Context) (*TaskDependency, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov0" title="0">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskDependencyMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskDependencyMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskDependency entities.
func (m *TaskDependencyMutation) SetID(id uuid.UUID) <span class="cov0" title="0">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskDependencyMutation) ID() (id uuid.UUID, exists bool) <span class="cov0" title="0">{
        if m.id == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskDependencyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []uuid.UUID{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().TaskDependency.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetTaskID sets the "task_id" field.
func (m *TaskDependencyMutation) SetTaskID(u uuid.UUID) <span class="cov0" title="0">{
        m.task = &amp;u
}</span>

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskDependencyMutation) TaskID() (r uuid.UUID, exists bool) <span class="cov0" title="0">{
        v := m.task
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldTaskID returns the old "task_id" field's value of the TaskDependency entity.
// If the TaskDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskDependencyMutation) OldTaskID(ctx context.Context) (v uuid.UUID, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldTaskID requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.TaskID, nil</span>
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskDependencyMutation) ResetTaskID() <span class="cov0" title="0">{
        m.task = nil
}</span>

// SetDependsOnTaskID sets the "depends_on_task_id" field.
func (m *TaskDependencyMutation) SetDependsOnTaskID(u uuid.UUID) <span class="cov0" title="0">{
        m.depends_on_task = &amp;u
}</span>

// DependsOnTaskID returns the value of the "depends_on_task_id" field in the mutation.
func (m *TaskDependencyMutation) DependsOnTaskID() (r uuid.UUID, exists bool) <span class="cov0" title="0">{
        v := m.depends_on_task
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldDependsOnTaskID returns the old "depends_on_task_id" field's value of the TaskDependency entity.
// If the TaskDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskDependencyMutation) OldDependsOnTaskID(ctx context.Context) (v uuid.UUID, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldDependsOnTaskID is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldDependsOnTaskID requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldDependsOnTaskID: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.DependsOnTaskID, nil</span>
}

// ResetDependsOnTaskID resets all changes to the "depends_on_task_id" field.
func (m *TaskDependencyMutation) ResetDependsOnTaskID() <span class="cov0" title="0">{
        m.depends_on_task = nil
}</span>

// SetCreatedAt sets the "created_at" field.
func (m *TaskDependencyMutation) SetCreatedAt(t time.Time) <span class="cov0" title="0">{
        m.created_at = &amp;t
}</span>

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskDependencyMutation) CreatedAt() (r time.Time, exists bool) <span class="cov0" title="0">{
        v := m.created_at
        if v == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return *v, true</span>
}

// OldCreatedAt returns the old "created_at" field's value of the TaskDependency entity.
// If the TaskDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskDependencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CreatedAt, nil</span>
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskDependencyMutation) ResetCreatedAt() <span class="cov0" title="0">{
        m.created_at = nil
}</span>

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskDependencyMutation) ClearTask() <span class="cov0" title="0">{
        m.clearedtask = true
        m.clearedFields[taskdependency.FieldTaskID] = struct{}{}
}</span>

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskDependencyMutation) TaskCleared() bool <span class="cov0" title="0">{
        return m.clearedtask
}</span>

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskDependencyMutation) TaskIDs() (ids []uuid.UUID) <span class="cov0" title="0">{
        if id := m.task; id != nil </span><span class="cov0" title="0">{
                ids = append(ids, *id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskDependencyMutation) ResetTask() <span class="cov0" title="0">{
        m.task = nil
        m.clearedtask = false
}</span>

// ClearDependsOnTask clears the "depends_on_task" edge to the Task entity.
func (m *TaskDependencyMutation) ClearDependsOnTask() <span class="cov0" title="0">{
        m.cleareddepends_on_task = true
        m.clearedFields[taskdependency.FieldDependsOnTaskID] = struct{}{}
}</span>

// DependsOnTaskCleared reports if the "depends_on_task" edge to the Task entity was cleared.
func (m *TaskDependencyMutation) DependsOnTaskCleared() bool <span class="cov0" title="0">{
        return m.cleareddepends_on_task
}</span>

// DependsOnTaskIDs returns the "depends_on_task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// DependsOnTaskID instead. It exists only for internal usage by the builders.
func (m *TaskDependencyMutation) DependsOnTaskIDs() (ids []uuid.UUID) <span class="cov0" title="0">{
        if id := m.depends_on_task; id != nil </span><span class="cov0" title="0">{
                ids = append(ids, *id)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ResetDependsOnTask resets all changes to the "depends_on_task" edge.
func (m *TaskDependencyMutation) ResetDependsOnTask() <span class="cov0" title="0">{
        m.depends_on_task = nil
        m.cleareddepends_on_task = false
}</span>

// Where appends a list predicates to the TaskDependencyMutation builder.
func (m *TaskDependencyMutation) Where(ps ...predicate.TaskDependency) <span class="cov0" title="0">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the TaskDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskDependencyMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.TaskDependency, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *TaskDependencyMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *TaskDependencyMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (TaskDependency).
func (m *TaskDependencyMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskDependencyMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 3)
        if m.task != nil </span><span class="cov0" title="0">{
                fields = append(fields, taskdependency.FieldTaskID)
        }</span>
        <span class="cov0" title="0">if m.depends_on_task != nil </span><span class="cov0" title="0">{
                fields = append(fields, taskdependency.FieldDependsOnTaskID)
        }</span>
        <span class="cov0" title="0">if m.created_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, taskdependency.FieldCreatedAt)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskDependencyMutation) Field(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case taskdependency.FieldTaskID:<span class="cov0" title="0">
                return m.TaskID()</span>
        case taskdependency.FieldDependsOnTaskID:<span class="cov0" title="0">
                return m.DependsOnTaskID()</span>
        case taskdependency.FieldCreatedAt:<span class="cov0" title="0">
                return m.CreatedAt()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case taskdependency.FieldTaskID:<span class="cov0" title="0">
                return m.OldTaskID(ctx)</span>
        case taskdependency.FieldDependsOnTaskID:<span class="cov0" title="0">
                return m.OldDependsOnTaskID(ctx)</span>
        case taskdependency.FieldCreatedAt:<span class="cov0" title="0">
                return m.OldCreatedAt(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown TaskDependency field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskDependencyMutation) SetField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case taskdependency.FieldTaskID:<span class="cov0" title="0">
                v, ok := value.(uuid.UUID)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetTaskID(v)
                return nil</span>
        case taskdependency.FieldDependsOnTaskID:<span class="cov0" title="0">
                v, ok := value.(uuid.UUID)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetDependsOnTaskID(v)
                return nil</span>
        case taskdependency.FieldCreatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCreatedAt(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown TaskDependency field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskDependencyMutation) AddedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskDependencyMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        return nil, false
}</span>

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskDependencyMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown TaskDependency numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskDependencyMutation) ClearedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskDependencyMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskDependencyMutation) ClearField(name string) error <span class="cov0" title="0">{
        return fmt.Errorf("unknown TaskDependency nullable field %s", name)
}</span>

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskDependencyMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case taskdependency.FieldTaskID:<span class="cov0" title="0">
                m.ResetTaskID()
                return nil</span>
        case taskdependency.FieldDependsOnTaskID:<span class="cov0" title="0">
                m.ResetDependsOnTaskID()
                return nil</span>
        case taskdependency.FieldCreatedAt:<span class="cov0" title="0">
                m.ResetCreatedAt()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown TaskDependency field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskDependencyMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.task != nil </span><span class="cov0" title="0">{
                edges = append(edges, taskdependency.EdgeTask)
        }</span>
        <span class="cov0" title="0">if m.depends_on_task != nil </span><span class="cov0" title="0">{
                edges = append(edges, taskdependency.EdgeDependsOnTask)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskDependencyMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case taskdependency.EdgeTask:<span class="cov0" title="0">
                if id := m.task; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        case taskdependency.EdgeDependsOnTask:<span class="cov0" title="0">
                if id := m.depends_on_task; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskDependencyMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        return edges
}</span>

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskDependencyMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        return nil
}</span>

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskDependencyMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.clearedtask </span><span class="cov0" title="0">{
                edges = append(edges, taskdependency.EdgeTask)
        }</span>
        <span class="cov0" title="0">if m.cleareddepends_on_task </span><span class="cov0" title="0">{
                edges = append(edges, taskdependency.EdgeDependsOnTask)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskDependencyMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case taskdependency.EdgeTask:<span class="cov0" title="0">
                return m.clearedtask</span>
        case taskdependency.EdgeDependsOnTask:<span class="cov0" title="0">
                return m.cleareddepends_on_task</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskDependencyMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case taskdependency.EdgeTask:<span class="cov0" title="0">
                m.ClearTask()
                return nil</span>
        case taskdependency.EdgeDependsOnTask:<span class="cov0" title="0">
                m.ClearDependsOnTask()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown TaskDependency unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskDependencyMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case taskdependency.EdgeTask:<span class="cov0" title="0">
                m.ResetTask()
                return nil</span>
        case taskdependency.EdgeDependsOnTask:<span class="cov0" title="0">
                m.ResetDependsOnTask()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown TaskDependency edge %s", name)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/google/uuid"
)

// Project is the model entity for the Project schema.
type Project struct {
        config `json:"-"`
        // ID of the ent.
        ID uuid.UUID `json:"id,omitempty"`
        // Title holds the value of the "title" field.
        Title string `json:"title,omitempty"`
        // Description holds the value of the "description" field.
        Description string `json:"description,omitempty"`
        // State holds the value of the "state" field.
        State project.State `json:"state,omitempty"`
        // CreatedAt holds the value of the "created_at" field.
        CreatedAt time.Time `json:"created_at,omitempty"`
        // UpdatedAt holds the value of the "updated_at" field.
        UpdatedAt time.Time `json:"updated_at,omitempty"`
        // TotalTasks holds the value of the "total_tasks" field.
        TotalTasks int `json:"total_tasks,omitempty"`
        // CompletedTasks holds the value of the "completed_tasks" field.
        CompletedTasks int `json:"completed_tasks,omitempty"`
        // Progress holds the value of the "progress" field.
        Progress float64 `json:"progress,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the ProjectQuery when eager-loading is set.
        Edges        ProjectEdges `json:"edges"`
        selectValues sql.SelectValues
}

// ProjectEdges holds the relations/edges for other nodes in the graph.
type ProjectEdges struct {
        // Tasks holds the value of the tasks edge.
        Tasks []*Task `json:"tasks,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [1]bool
}

// TasksOrErr returns the Tasks value or an error if the edge
// was not loaded in eager-loading.
func (e ProjectEdges) TasksOrErr() ([]*Task, error) <span class="cov0" title="0">{
        if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return e.Tasks, nil
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "tasks"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Project) scanValues(columns []string) ([]any, error) <span class="cov0" title="0">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case project.FieldProgress:<span class="cov0" title="0">
                        values[i] = new(sql.NullFloat64)</span>
                case project.FieldTotalTasks, project.FieldCompletedTasks:<span class="cov0" title="0">
                        values[i] = new(sql.NullInt64)</span>
                case project.FieldTitle, project.FieldDescription, project.FieldState:<span class="cov0" title="0">
                        values[i] = new(sql.NullString)</span>
                case project.FieldCreatedAt, project.FieldUpdatedAt:<span class="cov0" title="0">
                        values[i] = new(sql.NullTime)</span>
                case project.FieldID:<span class="cov0" title="0">
                        values[i] = new(uuid.UUID)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov0" title="0">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Project fields.
func (_m *Project) assignValues(columns []string, values []any) error <span class="cov0" title="0">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov0" title="0">for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case project.FieldID:<span class="cov0" title="0">
                        if value, ok := values[i].(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", values[i])
                        }</span> else<span class="cov0" title="0"> if value != nil </span><span class="cov0" title="0">{
                                _m.ID = *value
                        }</span>
                case project.FieldTitle:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field title", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Title = value.String
                        }</span>
                case project.FieldDescription:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field description", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Description = value.String
                        }</span>
                case project.FieldState:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field state", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.State = project.State(value.String)
                        }</span>
                case project.FieldCreatedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field created_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.CreatedAt = value.Time
                        }</span>
                case project.FieldUpdatedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field updated_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.UpdatedAt = value.Time
                        }</span>
                case project.FieldTotalTasks:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullInt64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field total_tasks", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.TotalTasks = int(value.Int64)
                        }</span>
                case project.FieldCompletedTasks:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullInt64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field completed_tasks", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.CompletedTasks = int(value.Int64)
                        }</span>
                case project.FieldProgress:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullFloat64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field progress", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Progress = value.Float64
                        }</span>
                default:<span class="cov0" title="0">
                        _m.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the Project.
// This includes values selected through modifiers, order, etc.
func (_m *Project) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return _m.selectValues.Get(name)
}</span>

// QueryTasks queries the "tasks" edge of the Project entity.
func (_m *Project) QueryTasks() *TaskQuery <span class="cov0" title="0">{
        return NewProjectClient(_m.config).QueryTasks(_m)
}</span>

// Update returns a builder for updating this Project.
// Note that you need to call Project.Unwrap() before calling this method if this Project
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Project) Update() *ProjectUpdateOne <span class="cov0" title="0">{
        return NewProjectClient(_m.config).UpdateOne(_m)
}</span>

// Unwrap unwraps the Project entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Project) Unwrap() *Project <span class="cov0" title="0">{
        _tx, ok := _m.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: Project is not a transactional entity")</span>
        }
        <span class="cov0" title="0">_m.config.driver = _tx.drv
        return _m</span>
}

// String implements the fmt.Stringer.
func (_m *Project) String() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("Project(")
        builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
        builder.WriteString("title=")
        builder.WriteString(_m.Title)
        builder.WriteString(", ")
        builder.WriteString("description=")
        builder.WriteString(_m.Description)
        builder.WriteString(", ")
        builder.WriteString("state=")
        builder.WriteString(fmt.Sprintf("%v", _m.State))
        builder.WriteString(", ")
        builder.WriteString("created_at=")
        builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
        builder.WriteString(", ")
        builder.WriteString("updated_at=")
        builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
        builder.WriteString(", ")
        builder.WriteString("total_tasks=")
        builder.WriteString(fmt.Sprintf("%v", _m.TotalTasks))
        builder.WriteString(", ")
        builder.WriteString("completed_tasks=")
        builder.WriteString(fmt.Sprintf("%v", _m.CompletedTasks))
        builder.WriteString(", ")
        builder.WriteString("progress=")
        builder.WriteString(fmt.Sprintf("%v", _m.Progress))
        builder.WriteByte(')')
        return builder.String()
}</span>

// Projects is a parsable slice of Project.
type Projects []*Project
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by ent, DO NOT EDIT.

package project

import (
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/google/uuid"
)

const (
        // Label holds the string label denoting the project type in the database.
        Label = "project"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldTitle holds the string denoting the title field in the database.
        FieldTitle = "title"
        // FieldDescription holds the string denoting the description field in the database.
        FieldDescription = "description"
        // FieldState holds the string denoting the state field in the database.
        FieldState = "state"
        // FieldCreatedAt holds the string denoting the created_at field in the database.
        FieldCreatedAt = "created_at"
        // FieldUpdatedAt holds the string denoting the updated_at field in the database.
        FieldUpdatedAt = "updated_at"
        // FieldTotalTasks holds the string denoting the total_tasks field in the database.
        FieldTotalTasks = "total_tasks"
        // FieldCompletedTasks holds the string denoting the completed_tasks field in the database.
        FieldCompletedTasks = "completed_tasks"
        // FieldProgress holds the string denoting the progress field in the database.
        FieldProgress = "progress"
        // EdgeTasks holds the string denoting the tasks edge name in mutations.
        EdgeTasks = "tasks"
        // Table holds the table name of the project in the database.
        Table = "projects"
        // TasksTable is the table that holds the tasks relation/edge.
        TasksTable = "tasks"
        // TasksInverseTable is the table name for the Task entity.
        // It exists in this package in order to avoid circular dependency with the "task" package.
        TasksInverseTable = "tasks"
        // TasksColumn is the table column denoting the tasks relation/edge.
        TasksColumn = "project_id"
)

// Columns holds all SQL columns for project fields.
var Columns = []string{
        FieldID,
        FieldTitle,
        FieldDescription,
        FieldState,
        FieldCreatedAt,
        FieldUpdatedAt,
        FieldTotalTasks,
        FieldCompletedTasks,
        FieldProgress,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var (
        // TitleValidator is a validator for the "title" field. It is called by the builders before save.
        TitleValidator func(string) error
        // DefaultCreatedAt holds the default value on creation for the "created_at" field.
        DefaultCreatedAt func() time.Time
        // DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
        DefaultUpdatedAt func() time.Time
        // UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
        UpdateDefaultUpdatedAt func() time.Time
        // DefaultTotalTasks holds the default value on creation for the "total_tasks" field.
        DefaultTotalTasks int
        // TotalTasksValidator is a validator for the "total_tasks" field. It is called by the builders before save.
        TotalTasksValidator func(int) error
        // DefaultCompletedTasks holds the default value on creation for the "completed_tasks" field.
        DefaultCompletedTasks int
        // CompletedTasksValidator is a validator for the "completed_tasks" field. It is called by the builders before save.
        CompletedTasksValidator func(int) error
        // DefaultProgress holds the default value on creation for the "progress" field.
        DefaultProgress float64
        // ProgressValidator is a validator for the "progress" field. It is called by the builders before save.
        ProgressValidator func(float64) error
        // DefaultID holds the default value on creation for the "id" field.
        DefaultID func() uuid.UUID
)

// State defines the type for the "state" enum field.
type State string

// StateActive is the default value of the State enum.
const DefaultState = StateActive

// State values.
const (
        StateActive          State = "active"
        StateCompleted       State = "completed"
        StateArchived        State = "archived"
        StateDeletionPending State = "deletion-pending"
)

func (s State) String() string <span class="cov0" title="0">{
        return string(s)
}</span>

// StateValidator is a validator for the "state" field enum values. It is called by the builders before save.
func StateValidator(s State) error <span class="cov0" title="0">{
        switch s </span>{
        case StateActive, StateCompleted, StateArchived, StateDeletionPending:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("project: invalid enum value for state field: %q", s)</span>
        }
}

// OrderOption defines the ordering options for the Project queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// ByTitle orders the results by the title field.
func ByTitle(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldTitle, opts...).ToFunc()
}</span>

// ByDescription orders the results by the description field.
func ByDescription(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldDescription, opts...).ToFunc()
}</span>

// ByState orders the results by the state field.
func ByState(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldState, opts...).ToFunc()
}</span>

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}</span>

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}</span>

// ByTotalTasks orders the results by the total_tasks field.
func ByTotalTasks(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldTotalTasks, opts...).ToFunc()
}</span>

// ByCompletedTasks orders the results by the completed_tasks field.
func ByCompletedTasks(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCompletedTasks, opts...).ToFunc()
}</span>

// ByProgress orders the results by the progress field.
func ByProgress(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldProgress, opts...).ToFunc()
}</span>

// ByTasksCount orders the results by tasks count.
func ByTasksCount(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborsCount(s, newTasksStep(), opts...)
        }</span>
}

// ByTasks orders the results by tasks terms.
func ByTasks(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newTasksStep(), append([]sql.OrderTerm{term}, terms...)...)
        }</span>
}
func newTasksStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(TasksInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.O2M, false, TasksTable, TasksColumn),
        )
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Code generated by ent, DO NOT EDIT.

package project

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLTE(FieldID, id))
}</span>

// Title applies equality check predicate on the "title" field. It's identical to TitleEQ.
func Title(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldTitle, v))
}</span>

// Description applies equality check predicate on the "description" field. It's identical to DescriptionEQ.
func Description(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldDescription, v))
}</span>

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// TotalTasks applies equality check predicate on the "total_tasks" field. It's identical to TotalTasksEQ.
func TotalTasks(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldTotalTasks, v))
}</span>

// CompletedTasks applies equality check predicate on the "completed_tasks" field. It's identical to CompletedTasksEQ.
func CompletedTasks(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldCompletedTasks, v))
}</span>

// Progress applies equality check predicate on the "progress" field. It's identical to ProgressEQ.
func Progress(v float64) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldProgress, v))
}</span>

// TitleEQ applies the EQ predicate on the "title" field.
func TitleEQ(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldTitle, v))
}</span>

// TitleNEQ applies the NEQ predicate on the "title" field.
func TitleNEQ(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNEQ(FieldTitle, v))
}</span>

// TitleIn applies the In predicate on the "title" field.
func TitleIn(vs ...string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldIn(FieldTitle, vs...))
}</span>

// TitleNotIn applies the NotIn predicate on the "title" field.
func TitleNotIn(vs ...string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNotIn(FieldTitle, vs...))
}</span>

// TitleGT applies the GT predicate on the "title" field.
func TitleGT(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGT(FieldTitle, v))
}</span>

// TitleGTE applies the GTE predicate on the "title" field.
func TitleGTE(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGTE(FieldTitle, v))
}</span>

// TitleLT applies the LT predicate on the "title" field.
func TitleLT(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLT(FieldTitle, v))
}</span>

// TitleLTE applies the LTE predicate on the "title" field.
func TitleLTE(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLTE(FieldTitle, v))
}</span>

// TitleContains applies the Contains predicate on the "title" field.
func TitleContains(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldContains(FieldTitle, v))
}</span>

// TitleHasPrefix applies the HasPrefix predicate on the "title" field.
func TitleHasPrefix(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldHasPrefix(FieldTitle, v))
}</span>

// TitleHasSuffix applies the HasSuffix predicate on the "title" field.
func TitleHasSuffix(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldHasSuffix(FieldTitle, v))
}</span>

// TitleEqualFold applies the EqualFold predicate on the "title" field.
func TitleEqualFold(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEqualFold(FieldTitle, v))
}</span>

// TitleContainsFold applies the ContainsFold predicate on the "title" field.
func TitleContainsFold(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldContainsFold(FieldTitle, v))
}</span>

// DescriptionEQ applies the EQ predicate on the "description" field.
func DescriptionEQ(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldDescription, v))
}</span>

// DescriptionNEQ applies the NEQ predicate on the "description" field.
func DescriptionNEQ(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNEQ(FieldDescription, v))
}</span>

// DescriptionIn applies the In predicate on the "description" field.
func DescriptionIn(vs ...string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldIn(FieldDescription, vs...))
}</span>

// DescriptionNotIn applies the NotIn predicate on the "description" field.
func DescriptionNotIn(vs ...string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNotIn(FieldDescription, vs...))
}</span>

// DescriptionGT applies the GT predicate on the "description" field.
func DescriptionGT(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGT(FieldDescription, v))
}</span>

// DescriptionGTE applies the GTE predicate on the "description" field.
func DescriptionGTE(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGTE(FieldDescription, v))
}</span>

// DescriptionLT applies the LT predicate on the "description" field.
func DescriptionLT(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLT(FieldDescription, v))
}</span>

// DescriptionLTE applies the LTE predicate on the "description" field.
func DescriptionLTE(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLTE(FieldDescription, v))
}</span>

// DescriptionContains applies the Contains predicate on the "description" field.
func DescriptionContains(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldContains(FieldDescription, v))
}</span>

// DescriptionHasPrefix applies the HasPrefix predicate on the "description" field.
func DescriptionHasPrefix(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldHasPrefix(FieldDescription, v))
}</span>

// DescriptionHasSuffix applies the HasSuffix predicate on the "description" field.
func DescriptionHasSuffix(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldHasSuffix(FieldDescription, v))
}</span>

// DescriptionIsNil applies the IsNil predicate on the "description" field.
func DescriptionIsNil() predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldIsNull(FieldDescription))
}</span>

// DescriptionNotNil applies the NotNil predicate on the "description" field.
func DescriptionNotNil() predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNotNull(FieldDescription))
}</span>

// DescriptionEqualFold applies the EqualFold predicate on the "description" field.
func DescriptionEqualFold(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEqualFold(FieldDescription, v))
}</span>

// DescriptionContainsFold applies the ContainsFold predicate on the "description" field.
func DescriptionContainsFold(v string) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldContainsFold(FieldDescription, v))
}</span>

// StateEQ applies the EQ predicate on the "state" field.
func StateEQ(v State) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldState, v))
}</span>

// StateNEQ applies the NEQ predicate on the "state" field.
func StateNEQ(v State) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNEQ(FieldState, v))
}</span>

// StateIn applies the In predicate on the "state" field.
func StateIn(vs ...State) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldIn(FieldState, vs...))
}</span>

// StateNotIn applies the NotIn predicate on the "state" field.
func StateNotIn(vs ...State) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNotIn(FieldState, vs...))
}</span>

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNEQ(FieldCreatedAt, v))
}</span>

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNotIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGT(FieldCreatedAt, v))
}</span>

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGTE(FieldCreatedAt, v))
}</span>

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLT(FieldCreatedAt, v))
}</span>

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLTE(FieldCreatedAt, v))
}</span>

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNotIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGT(FieldUpdatedAt, v))
}</span>

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGTE(FieldUpdatedAt, v))
}</span>

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLT(FieldUpdatedAt, v))
}</span>

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLTE(FieldUpdatedAt, v))
}</span>

// TotalTasksEQ applies the EQ predicate on the "total_tasks" field.
func TotalTasksEQ(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldTotalTasks, v))
}</span>

// TotalTasksNEQ applies the NEQ predicate on the "total_tasks" field.
func TotalTasksNEQ(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNEQ(FieldTotalTasks, v))
}</span>

// TotalTasksIn applies the In predicate on the "total_tasks" field.
func TotalTasksIn(vs ...int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldIn(FieldTotalTasks, vs...))
}</span>

// TotalTasksNotIn applies the NotIn predicate on the "total_tasks" field.
func TotalTasksNotIn(vs ...int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNotIn(FieldTotalTasks, vs...))
}</span>

// TotalTasksGT applies the GT predicate on the "total_tasks" field.
func TotalTasksGT(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGT(FieldTotalTasks, v))
}</span>

// TotalTasksGTE applies the GTE predicate on the "total_tasks" field.
func TotalTasksGTE(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGTE(FieldTotalTasks, v))
}</span>

// TotalTasksLT applies the LT predicate on the "total_tasks" field.
func TotalTasksLT(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLT(FieldTotalTasks, v))
}</span>

// TotalTasksLTE applies the LTE predicate on the "total_tasks" field.
func TotalTasksLTE(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLTE(FieldTotalTasks, v))
}</span>

// CompletedTasksEQ applies the EQ predicate on the "completed_tasks" field.
func CompletedTasksEQ(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldCompletedTasks, v))
}</span>

// CompletedTasksNEQ applies the NEQ predicate on the "completed_tasks" field.
func CompletedTasksNEQ(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNEQ(FieldCompletedTasks, v))
}</span>

// CompletedTasksIn applies the In predicate on the "completed_tasks" field.
func CompletedTasksIn(vs ...int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldIn(FieldCompletedTasks, vs...))
}</span>

// CompletedTasksNotIn applies the NotIn predicate on the "completed_tasks" field.
func CompletedTasksNotIn(vs ...int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNotIn(FieldCompletedTasks, vs...))
}</span>

// CompletedTasksGT applies the GT predicate on the "completed_tasks" field.
func CompletedTasksGT(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGT(FieldCompletedTasks, v))
}</span>

// CompletedTasksGTE applies the GTE predicate on the "completed_tasks" field.
func CompletedTasksGTE(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGTE(FieldCompletedTasks, v))
}</span>

// CompletedTasksLT applies the LT predicate on the "completed_tasks" field.
func CompletedTasksLT(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLT(FieldCompletedTasks, v))
}</span>

// CompletedTasksLTE applies the LTE predicate on the "completed_tasks" field.
func CompletedTasksLTE(v int) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLTE(FieldCompletedTasks, v))
}</span>

// ProgressEQ applies the EQ predicate on the "progress" field.
func ProgressEQ(v float64) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldEQ(FieldProgress, v))
}</span>

// ProgressNEQ applies the NEQ predicate on the "progress" field.
func ProgressNEQ(v float64) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNEQ(FieldProgress, v))
}</span>

// ProgressIn applies the In predicate on the "progress" field.
func ProgressIn(vs ...float64) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldIn(FieldProgress, vs...))
}</span>

// ProgressNotIn applies the NotIn predicate on the "progress" field.
func ProgressNotIn(vs ...float64) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldNotIn(FieldProgress, vs...))
}</span>

// ProgressGT applies the GT predicate on the "progress" field.
func ProgressGT(v float64) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGT(FieldProgress, v))
}</span>

// ProgressGTE applies the GTE predicate on the "progress" field.
func ProgressGTE(v float64) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldGTE(FieldProgress, v))
}</span>

// ProgressLT applies the LT predicate on the "progress" field.
func ProgressLT(v float64) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLT(FieldProgress, v))
}</span>

// ProgressLTE applies the LTE predicate on the "progress" field.
func ProgressLTE(v float64) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.FieldLTE(FieldProgress, v))
}</span>

// HasTasks applies the HasEdge predicate on the "tasks" edge.
func HasTasks() predicate.Project <span class="cov0" title="0">{
        return predicate.Project(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, TasksTable, TasksColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasTasksWith applies the HasEdge predicate on the "tasks" edge with a given conditions (other predicates).
func HasTasksWith(preds ...predicate.Task) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newTasksStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Project) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Project) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.Project) predicate.Project <span class="cov0" title="0">{
        return predicate.Project(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/google/uuid"
)

// ProjectCreate is the builder for creating a Project entity.
type ProjectCreate struct {
        config
        mutation *ProjectMutation
        hooks    []Hook
}

// SetTitle sets the "title" field.
func (_c *ProjectCreate) SetTitle(v string) *ProjectCreate <span class="cov0" title="0">{
        _c.mutation.SetTitle(v)
        return _c
}</span>

// SetDescription sets the "description" field.
func (_c *ProjectCreate) SetDescription(v string) *ProjectCreate <span class="cov0" title="0">{
        _c.mutation.SetDescription(v)
        return _c
}</span>

// SetNillableDescription sets the "description" field if the given value is not nil.
func (_c *ProjectCreate) SetNillableDescription(v *string) *ProjectCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetDescription(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetState sets the "state" field.
func (_c *ProjectCreate) SetState(v project.State) *ProjectCreate <span class="cov0" title="0">{
        _c.mutation.SetState(v)
        return _c
}</span>

// SetNillableState sets the "state" field if the given value is not nil.
func (_c *ProjectCreate) SetNillableState(v *project.State) *ProjectCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetState(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetCreatedAt sets the "created_at" field.
func (_c *ProjectCreate) SetCreatedAt(v time.Time) *ProjectCreate <span class="cov0" title="0">{
        _c.mutation.SetCreatedAt(v)
        return _c
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_c *ProjectCreate) SetNillableCreatedAt(v *time.Time) *ProjectCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetCreatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (_c *ProjectCreate) SetUpdatedAt(v time.Time) *ProjectCreate <span class="cov0" title="0">{
        _c.mutation.SetUpdatedAt(v)
        return _c
}</span>

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (_c *ProjectCreate) SetNillableUpdatedAt(v *time.Time) *ProjectCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetUpdatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetTotalTasks sets the "total_tasks" field.
func (_c *ProjectCreate) SetTotalTasks(v int) *ProjectCreate <span class="cov0" title="0">{
        _c.mutation.SetTotalTasks(v)
        return _c
}</span>

// SetNillableTotalTasks sets the "total_tasks" field if the given value is not nil.
func (_c *ProjectCreate) SetNillableTotalTasks(v *int) *ProjectCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetTotalTasks(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetCompletedTasks sets the "completed_tasks" field.
func (_c *ProjectCreate) SetCompletedTasks(v int) *ProjectCreate <span class="cov0" title="0">{
        _c.mutation.SetCompletedTasks(v)
        return _c
}</span>

// SetNillableCompletedTasks sets the "completed_tasks" field if the given value is not nil.
func (_c *ProjectCreate) SetNillableCompletedTasks(v *int) *ProjectCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetCompletedTasks(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetProgress sets the "progress" field.
func (_c *ProjectCreate) SetProgress(v float64) *ProjectCreate <span class="cov0" title="0">{
        _c.mutation.SetProgress(v)
        return _c
}</span>

// SetNillableProgress sets the "progress" field if the given value is not nil.
func (_c *ProjectCreate) SetNillableProgress(v *float64) *ProjectCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetProgress(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetID sets the "id" field.
func (_c *ProjectCreate) SetID(v uuid.UUID) *ProjectCreate <span class="cov0" title="0">{
        _c.mutation.SetID(v)
        return _c
}</span>

// SetNillableID sets the "id" field if the given value is not nil.
func (_c *ProjectCreate) SetNillableID(v *uuid.UUID) *ProjectCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetID(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// AddTaskIDs adds the "tasks" edge to the Task entity by IDs.
func (_c *ProjectCreate) AddTaskIDs(ids ...uuid.UUID) *ProjectCreate <span class="cov0" title="0">{
        _c.mutation.AddTaskIDs(ids...)
        return _c
}</span>

// AddTasks adds the "tasks" edges to the Task entity.
func (_c *ProjectCreate) AddTasks(v ...*Task) *ProjectCreate <span class="cov0" title="0">{
        ids := make([]uuid.UUID, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _c.AddTaskIDs(ids...)</span>
}

// Mutation returns the ProjectMutation object of the builder.
func (_c *ProjectCreate) Mutation() *ProjectMutation <span class="cov0" title="0">{
        return _c.mutation
}</span>

// Save creates the Project in the database.
func (_c *ProjectCreate) Save(ctx context.Context) (*Project, error) <span class="cov0" title="0">{
        _c.defaults()
        return withHooks(ctx, _c.sqlSave, _c.mutation, _c.hooks)
}</span>

// SaveX calls Save and panics if Save returns an error.
func (_c *ProjectCreate) SaveX(ctx context.Context) *Project <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *ProjectCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *ProjectCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_c *ProjectCreate) defaults() <span class="cov0" title="0">{
        if _, ok := _c.mutation.State(); !ok </span><span class="cov0" title="0">{
                v := project.DefaultState
                _c.mutation.SetState(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                v := project.DefaultCreatedAt()
                _c.mutation.SetCreatedAt(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                v := project.DefaultUpdatedAt()
                _c.mutation.SetUpdatedAt(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.TotalTasks(); !ok </span><span class="cov0" title="0">{
                v := project.DefaultTotalTasks
                _c.mutation.SetTotalTasks(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.CompletedTasks(); !ok </span><span class="cov0" title="0">{
                v := project.DefaultCompletedTasks
                _c.mutation.SetCompletedTasks(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.Progress(); !ok </span><span class="cov0" title="0">{
                v := project.DefaultProgress
                _c.mutation.SetProgress(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.ID(); !ok </span><span class="cov0" title="0">{
                v := project.DefaultID()
                _c.mutation.SetID(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_c *ProjectCreate) check() error <span class="cov0" title="0">{
        if _, ok := _c.mutation.Title(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "title", err: errors.New(`ent: missing required field "Project.title"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.Title(); ok </span><span class="cov0" title="0">{
                if err := project.TitleValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "Project.title": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.State(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "state", err: errors.New(`ent: missing required field "Project.state"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.State(); ok </span><span class="cov0" title="0">{
                if err := project.StateValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "state", err: fmt.Errorf(`ent: validator failed for field "Project.state": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "Project.created_at"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "updated_at", err: errors.New(`ent: missing required field "Project.updated_at"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.TotalTasks(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "total_tasks", err: errors.New(`ent: missing required field "Project.total_tasks"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.TotalTasks(); ok </span><span class="cov0" title="0">{
                if err := project.TotalTasksValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "total_tasks", err: fmt.Errorf(`ent: validator failed for field "Project.total_tasks": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.CompletedTasks(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "completed_tasks", err: errors.New(`ent: missing required field "Project.completed_tasks"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.CompletedTasks(); ok </span><span class="cov0" title="0">{
                if err := project.CompletedTasksValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "completed_tasks", err: fmt.Errorf(`ent: validator failed for field "Project.completed_tasks": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.Progress(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "progress", err: errors.New(`ent: missing required field "Project.progress"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.Progress(); ok </span><span class="cov0" title="0">{
                if err := project.ProgressValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "progress", err: fmt.Errorf(`ent: validator failed for field "Project.progress": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_c *ProjectCreate) sqlSave(ctx context.Context) (*Project, error) <span class="cov0" title="0">{
        if err := _c.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_node, _spec := _c.createSpec()
        if err := sqlgraph.CreateNode(ctx, _c.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if _spec.ID.Value != nil </span><span class="cov0" title="0">{
                if id, ok := _spec.ID.Value.(*uuid.UUID); ok </span><span class="cov0" title="0">{
                        _node.ID = *id
                }</span> else<span class="cov0" title="0"> if err := _node.ID.Scan(_spec.ID.Value); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">_c.mutation.id = &amp;_node.ID
        _c.mutation.done = true
        return _node, nil</span>
}

func (_c *ProjectCreate) createSpec() (*Project, *sqlgraph.CreateSpec) <span class="cov0" title="0">{
        var (
                _node = &amp;Project{config: _c.config}
                _spec = sqlgraph.NewCreateSpec(project.Table, sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID))
        )
        if id, ok := _c.mutation.ID(); ok </span><span class="cov0" title="0">{
                _node.ID = id
                _spec.ID.Value = &amp;id
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Title(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldTitle, field.TypeString, value)
                _node.Title = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Description(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldDescription, field.TypeString, value)
                _node.Description = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.State(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldState, field.TypeEnum, value)
                _node.State = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldCreatedAt, field.TypeTime, value)
                _node.CreatedAt = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldUpdatedAt, field.TypeTime, value)
                _node.UpdatedAt = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.TotalTasks(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldTotalTasks, field.TypeInt, value)
                _node.TotalTasks = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.CompletedTasks(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldCompletedTasks, field.TypeInt, value)
                _node.CompletedTasks = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Progress(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldProgress, field.TypeFloat64, value)
                _node.Progress = value
        }</span>
        <span class="cov0" title="0">if nodes := _c.mutation.TasksIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   project.TasksTable,
                        Columns: []string{project.TasksColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">return _node, _spec</span>
}

// ProjectCreateBulk is the builder for creating many Project entities in bulk.
type ProjectCreateBulk struct {
        config
        err      error
        builders []*ProjectCreate
}

// Save creates the Project entities in the database.
func (_c *ProjectCreateBulk) Save(ctx context.Context) ([]*Project, error) <span class="cov0" title="0">{
        if _c.err != nil </span><span class="cov0" title="0">{
                return nil, _c.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(_c.builders))
        nodes := make([]*Project, len(_c.builders))
        mutators := make([]Mutator, len(_c.builders))
        for i := range _c.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := _c.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*ProjectMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, _c.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, _c.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, _c.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (_c *ProjectCreateBulk) SaveX(ctx context.Context) []*Project <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *ProjectCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *ProjectCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
)

// ProjectDelete is the builder for deleting a Project entity.
type ProjectDelete struct {
        config
        hooks    []Hook
        mutation *ProjectMutation
}

// Where appends a list predicates to the ProjectDelete builder.
func (_d *ProjectDelete) Where(ps ...predicate.Project) *ProjectDelete <span class="cov0" title="0">{
        _d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (_d *ProjectDelete) Exec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _d.sqlExec, _d.mutation, _d.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_d *ProjectDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := _d.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (_d *ProjectDelete) sqlExec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := sqlgraph.NewDeleteSpec(project.Table, sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID))
        if ps := _d.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">affected, err := sqlgraph.DeleteNodes(ctx, _d.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov0" title="0">_d.mutation.done = true
        return affected, err</span>
}

// ProjectDeleteOne is the builder for deleting a single Project entity.
type ProjectDeleteOne struct {
        _d *ProjectDelete
}

// Where appends a list predicates to the ProjectDelete builder.
func (_d *ProjectDeleteOne) Where(ps ...predicate.Project) *ProjectDeleteOne <span class="cov0" title="0">{
        _d._d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query.
func (_d *ProjectDeleteOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        n, err := _d._d.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov0" title="0">
                return &amp;NotFoundError{project.Label}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (_d *ProjectDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _d.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "database/sql/driver"
        "fmt"
        "math"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/google/uuid"
)

// ProjectQuery is the builder for querying Project entities.
type ProjectQuery struct {
        config
        ctx        *QueryContext
        order      []project.OrderOption
        inters     []Interceptor
        predicates []predicate.Project
        withTasks  *TaskQuery
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the ProjectQuery builder.
func (_q *ProjectQuery) Where(ps ...predicate.Project) *ProjectQuery <span class="cov0" title="0">{
        _q.predicates = append(_q.predicates, ps...)
        return _q
}</span>

// Limit the number of records to be returned by this query.
func (_q *ProjectQuery) Limit(limit int) *ProjectQuery <span class="cov0" title="0">{
        _q.ctx.Limit = &amp;limit
        return _q
}</span>

// Offset to start from.
func (_q *ProjectQuery) Offset(offset int) *ProjectQuery <span class="cov0" title="0">{
        _q.ctx.Offset = &amp;offset
        return _q
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (_q *ProjectQuery) Unique(unique bool) *ProjectQuery <span class="cov0" title="0">{
        _q.ctx.Unique = &amp;unique
        return _q
}</span>

// Order specifies how the records should be ordered.
func (_q *ProjectQuery) Order(o ...project.OrderOption) *ProjectQuery <span class="cov0" title="0">{
        _q.order = append(_q.order, o...)
        return _q
}</span>

// QueryTasks chains the current query on the "tasks" edge.
func (_q *ProjectQuery) QueryTasks() *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(project.Table, project.FieldID, selector),
                        sqlgraph.To(task.Table, task.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, project.TasksTable, project.TasksColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first Project entity from the query.
// Returns a *NotFoundError when no Project was found.
func (_q *ProjectQuery) First(ctx context.Context) (*Project, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(1).All(setContextOp(ctx, _q.ctx, ent.OpQueryFirst))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{project.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (_q *ProjectQuery) FirstX(ctx context.Context) *Project <span class="cov0" title="0">{
        node, err := _q.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first Project ID from the query.
// Returns a *NotFoundError when no Project ID was found.
func (_q *ProjectQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) <span class="cov0" title="0">{
        var ids []uuid.UUID
        if ids, err = _q.Limit(1).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryFirstID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{project.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (_q *ProjectQuery) FirstIDX(ctx context.Context) uuid.UUID <span class="cov0" title="0">{
        id, err := _q.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single Project entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Project entity is found.
// Returns a *NotFoundError when no Project entities are found.
func (_q *ProjectQuery) Only(ctx context.Context) (*Project, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(2).All(setContextOp(ctx, _q.ctx, ent.OpQueryOnly))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch len(nodes) </span>{
        case 1:<span class="cov0" title="0">
                return nodes[0], nil</span>
        case 0:<span class="cov0" title="0">
                return nil, &amp;NotFoundError{project.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{project.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (_q *ProjectQuery) OnlyX(ctx context.Context) *Project <span class="cov0" title="0">{
        node, err := _q.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only Project ID in the query.
// Returns a *NotSingularError when more than one Project ID is found.
// Returns a *NotFoundError when no entities are found.
func (_q *ProjectQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) <span class="cov0" title="0">{
        var ids []uuid.UUID
        if ids, err = _q.Limit(2).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryOnlyID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{project.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{project.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (_q *ProjectQuery) OnlyIDX(ctx context.Context) uuid.UUID <span class="cov0" title="0">{
        id, err := _q.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of Projects.
func (_q *ProjectQuery) All(ctx context.Context) ([]*Project, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryAll)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">qr := querierAll[[]*Project, *ProjectQuery]()
        return withInterceptors[[]*Project](ctx, _q, qr, _q.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (_q *ProjectQuery) AllX(ctx context.Context) []*Project <span class="cov0" title="0">{
        nodes, err := _q.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of Project IDs.
func (_q *ProjectQuery) IDs(ctx context.Context) (ids []uuid.UUID, err error) <span class="cov0" title="0">{
        if _q.ctx.Unique == nil &amp;&amp; _q.path != nil </span><span class="cov0" title="0">{
                _q.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, _q.ctx, ent.OpQueryIDs)
        if err = _q.Select(project.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (_q *ProjectQuery) IDsX(ctx context.Context) []uuid.UUID <span class="cov0" title="0">{
        ids, err := _q.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (_q *ProjectQuery) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryCount)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return withInterceptors[int](ctx, _q, querierCount[*ProjectQuery](), _q.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (_q *ProjectQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := _q.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (_q *ProjectQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryExist)
        switch _, err := _q.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (_q *ProjectQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := _q.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the ProjectQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (_q *ProjectQuery) Clone() *ProjectQuery <span class="cov0" title="0">{
        if _q == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;ProjectQuery{
                config:     _q.config,
                ctx:        _q.ctx.Clone(),
                order:      append([]project.OrderOption{}, _q.order...),
                inters:     append([]Interceptor{}, _q.inters...),
                predicates: append([]predicate.Project{}, _q.predicates...),
                withTasks:  _q.withTasks.Clone(),
                // clone intermediate query.
                sql:  _q.sql.Clone(),
                path: _q.path,
        }</span>
}

// WithTasks tells the query-builder to eager-load the nodes that are connected to
// the "tasks" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ProjectQuery) WithTasks(opts ...func(*TaskQuery)) *ProjectQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withTasks = query
        return _q</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                Title string `json:"title,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.Project.Query().
//                GroupBy(project.FieldTitle).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (_q *ProjectQuery) GroupBy(field string, fields ...string) *ProjectGroupBy <span class="cov0" title="0">{
        _q.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;ProjectGroupBy{build: _q}
        grbuild.flds = &amp;_q.ctx.Fields
        grbuild.label = project.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                Title string `json:"title,omitempty"`
//        }
//
//        client.Project.Query().
//                Select(project.FieldTitle).
//                Scan(ctx, &amp;v)
func (_q *ProjectQuery) Select(fields ...string) *ProjectSelect <span class="cov0" title="0">{
        _q.ctx.Fields = append(_q.ctx.Fields, fields...)
        sbuild := &amp;ProjectSelect{ProjectQuery: _q}
        sbuild.label = project.Label
        sbuild.flds, sbuild.scan = &amp;_q.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a ProjectSelect configured with the given aggregations.
func (_q *ProjectQuery) Aggregate(fns ...AggregateFunc) *ProjectSelect <span class="cov0" title="0">{
        return _q.Select().Aggregate(fns...)
}</span>

func (_q *ProjectQuery) prepareQuery(ctx context.Context) error <span class="cov0" title="0">{
        for _, inter := range _q.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, _q); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, f := range _q.ctx.Fields </span><span class="cov0" title="0">{
                if !project.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov0" title="0">if _q.path != nil </span><span class="cov0" title="0">{
                prev, err := _q.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_q.sql = prev</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *ProjectQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Project, error) <span class="cov0" title="0">{
        var (
                nodes       = []*Project{}
                _spec       = _q.querySpec()
                loadedTypes = [1]bool{
                        _q.withTasks != nil,
                }
        )
        _spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov0" title="0">{
                return (*Project).scanValues(nil, columns)
        }</span>
        <span class="cov0" title="0">_spec.Assign = func(columns []string, values []any) error </span><span class="cov0" title="0">{
                node := &amp;Project{config: _q.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov0" title="0">for i := range hooks </span><span class="cov0" title="0">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov0" title="0">if err := sqlgraph.QueryNodes(ctx, _q.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nodes, nil
        }</span>
        <span class="cov0" title="0">if query := _q.withTasks; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadTasks(ctx, query, nodes,
                        func(n *Project) </span><span class="cov0" title="0">{ n.Edges.Tasks = []*Task{} }</span>,
                        func(n *Project, e *Task) <span class="cov0" title="0">{ n.Edges.Tasks = append(n.Edges.Tasks, e) }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

func (_q *ProjectQuery) loadTasks(ctx context.Context, query *TaskQuery, nodes []*Project, init func(*Project), assign func(*Project, *Task)) error <span class="cov0" title="0">{
        fks := make([]driver.Value, 0, len(nodes))
        nodeids := make(map[uuid.UUID]*Project)
        for i := range nodes </span><span class="cov0" title="0">{
                fks = append(fks, nodes[i].ID)
                nodeids[nodes[i].ID] = nodes[i]
                if init != nil </span><span class="cov0" title="0">{
                        init(nodes[i])
                }</span>
        }
        <span class="cov0" title="0">if len(query.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                query.ctx.AppendFieldOnce(task.FieldProjectID)
        }</span>
        <span class="cov0" title="0">query.Where(predicate.Task(func(s *sql.Selector) </span><span class="cov0" title="0">{
                s.Where(sql.InValues(s.C(project.TasksColumn), fks...))
        }</span>))
        <span class="cov0" title="0">neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                fk := n.ProjectID
                node, ok := nodeids[fk]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected referenced foreign-key "project_id" returned %v for node %v`, fk, n.ID)
                }</span>
                <span class="cov0" title="0">assign(node, n)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *ProjectQuery) sqlCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := _q.querySpec()
        _spec.Node.Columns = _q.ctx.Fields
        if len(_q.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique
        }</span>
        <span class="cov0" title="0">return sqlgraph.CountNodes(ctx, _q.driver, _spec)</span>
}

func (_q *ProjectQuery) querySpec() *sqlgraph.QuerySpec <span class="cov0" title="0">{
        _spec := sqlgraph.NewQuerySpec(project.Table, project.Columns, sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID))
        _spec.From = _q.sql
        if unique := _q.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov0" title="0"> if _q.path != nil </span><span class="cov0" title="0">{
                _spec.Unique = true
        }</span>
        <span class="cov0" title="0">if fields := _q.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, project.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != project.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
        }
        <span class="cov0" title="0">if ps := _q.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                _spec.Limit = *limit
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                _spec.Offset = *offset
        }</span>
        <span class="cov0" title="0">if ps := _q.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">return _spec</span>
}

func (_q *ProjectQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(_q.driver.Dialect())
        t1 := builder.Table(project.Table)
        columns := _q.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = project.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if _q.sql != nil </span><span class="cov0" title="0">{
                selector = _q.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range _q.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range _q.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// ProjectGroupBy is the group-by builder for Project entities.
type ProjectGroupBy struct {
        selector
        build *ProjectQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (_g *ProjectGroupBy) Aggregate(fns ...AggregateFunc) *ProjectGroupBy <span class="cov0" title="0">{
        _g.fns = append(_g.fns, fns...)
        return _g
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_g *ProjectGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _g.build.ctx, ent.OpQueryGroupBy)
        if err := _g.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*ProjectQuery, *ProjectGroupBy](ctx, _g.build, _g, _g.build.inters, v)</span>
}

func (_g *ProjectGroupBy) sqlScan(ctx context.Context, root *ProjectQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(_g.fns))
        for _, fn := range _g.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*_g.flds)+len(_g.fns))
                for _, f := range *_g.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*_g.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _g.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// ProjectSelect is the builder for selecting fields of Project entities.
type ProjectSelect struct {
        *ProjectQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (_s *ProjectSelect) Aggregate(fns ...AggregateFunc) *ProjectSelect <span class="cov0" title="0">{
        _s.fns = append(_s.fns, fns...)
        return _s
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_s *ProjectSelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _s.ctx, ent.OpQuerySelect)
        if err := _s.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*ProjectQuery, *ProjectSelect](ctx, _s.ProjectQuery, _s, _s.inters, v)</span>
}

func (_s *ProjectSelect) sqlScan(ctx context.Context, root *ProjectQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(_s.fns))
        for _, fn := range _s.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*_s.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _s.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/google/uuid"
)

// ProjectUpdate is the builder for updating Project entities.
type ProjectUpdate struct {
        config
        hooks    []Hook
        mutation *ProjectMutation
}

// Where appends a list predicates to the ProjectUpdate builder.
func (_u *ProjectUpdate) Where(ps ...predicate.Project) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// SetTitle sets the "title" field.
func (_u *ProjectUpdate) SetTitle(v string) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.SetTitle(v)
        return _u
}</span>

// SetNillableTitle sets the "title" field if the given value is not nil.
func (_u *ProjectUpdate) SetNillableTitle(v *string) *ProjectUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetTitle(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetDescription sets the "description" field.
func (_u *ProjectUpdate) SetDescription(v string) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.SetDescription(v)
        return _u
}</span>

// SetNillableDescription sets the "description" field if the given value is not nil.
func (_u *ProjectUpdate) SetNillableDescription(v *string) *ProjectUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetDescription(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearDescription clears the value of the "description" field.
func (_u *ProjectUpdate) ClearDescription() *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.ClearDescription()
        return _u
}</span>

// SetState sets the "state" field.
func (_u *ProjectUpdate) SetState(v project.State) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.SetState(v)
        return _u
}</span>

// SetNillableState sets the "state" field if the given value is not nil.
func (_u *ProjectUpdate) SetNillableState(v *project.State) *ProjectUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetState(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (_u *ProjectUpdate) SetUpdatedAt(v time.Time) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.SetUpdatedAt(v)
        return _u
}</span>

// SetTotalTasks sets the "total_tasks" field.
func (_u *ProjectUpdate) SetTotalTasks(v int) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.ResetTotalTasks()
        _u.mutation.SetTotalTasks(v)
        return _u
}</span>

// SetNillableTotalTasks sets the "total_tasks" field if the given value is not nil.
func (_u *ProjectUpdate) SetNillableTotalTasks(v *int) *ProjectUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetTotalTasks(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddTotalTasks adds value to the "total_tasks" field.
func (_u *ProjectUpdate) AddTotalTasks(v int) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.AddTotalTasks(v)
        return _u
}</span>

// SetCompletedTasks sets the "completed_tasks" field.
func (_u *ProjectUpdate) SetCompletedTasks(v int) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.ResetCompletedTasks()
        _u.mutation.SetCompletedTasks(v)
        return _u
}</span>

// SetNillableCompletedTasks sets the "completed_tasks" field if the given value is not nil.
func (_u *ProjectUpdate) SetNillableCompletedTasks(v *int) *ProjectUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetCompletedTasks(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddCompletedTasks adds value to the "completed_tasks" field.
func (_u *ProjectUpdate) AddCompletedTasks(v int) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.AddCompletedTasks(v)
        return _u
}</span>

// SetProgress sets the "progress" field.
func (_u *ProjectUpdate) SetProgress(v float64) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.ResetProgress()
        _u.mutation.SetProgress(v)
        return _u
}</span>

// SetNillableProgress sets the "progress" field if the given value is not nil.
func (_u *ProjectUpdate) SetNillableProgress(v *float64) *ProjectUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetProgress(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddProgress adds value to the "progress" field.
func (_u *ProjectUpdate) AddProgress(v float64) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.AddProgress(v)
        return _u
}</span>

// AddTaskIDs adds the "tasks" edge to the Task entity by IDs.
func (_u *ProjectUpdate) AddTaskIDs(ids ...uuid.UUID) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.AddTaskIDs(ids...)
        return _u
}</span>

// AddTasks adds the "tasks" edges to the Task entity.
func (_u *ProjectUpdate) AddTasks(v ...*Task) *ProjectUpdate <span class="cov0" title="0">{
        ids := make([]uuid.UUID, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddTaskIDs(ids...)</span>
}

// Mutation returns the ProjectMutation object of the builder.
func (_u *ProjectUpdate) Mutation() *ProjectMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearTasks clears all "tasks" edges to the Task entity.
func (_u *ProjectUpdate) ClearTasks() *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.ClearTasks()
        return _u
}</span>

// RemoveTaskIDs removes the "tasks" edge to Task entities by IDs.
func (_u *ProjectUpdate) RemoveTaskIDs(ids ...uuid.UUID) *ProjectUpdate <span class="cov0" title="0">{
        _u.mutation.RemoveTaskIDs(ids...)
        return _u
}</span>

// RemoveTasks removes "tasks" edges to Task entities.
func (_u *ProjectUpdate) RemoveTasks(v ...*Task) *ProjectUpdate <span class="cov0" title="0">{
        ids := make([]uuid.UUID, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveTaskIDs(ids...)</span>
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *ProjectUpdate) Save(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _u.defaults()
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *ProjectUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (_u *ProjectUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *ProjectUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_u *ProjectUpdate) defaults() <span class="cov0" title="0">{
        if _, ok := _u.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                v := project.UpdateDefaultUpdatedAt()
                _u.mutation.SetUpdatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_u *ProjectUpdate) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                if err := project.TitleValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "Project.title": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.State(); ok </span><span class="cov0" title="0">{
                if err := project.StateValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "state", err: fmt.Errorf(`ent: validator failed for field "Project.state": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.TotalTasks(); ok </span><span class="cov0" title="0">{
                if err := project.TotalTasksValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "total_tasks", err: fmt.Errorf(`ent: validator failed for field "Project.total_tasks": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.CompletedTasks(); ok </span><span class="cov0" title="0">{
                if err := project.CompletedTasksValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "completed_tasks", err: fmt.Errorf(`ent: validator failed for field "Project.completed_tasks": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.Progress(); ok </span><span class="cov0" title="0">{
                if err := project.ProgressValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "progress", err: fmt.Errorf(`ent: validator failed for field "Project.progress": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_u *ProjectUpdate) sqlSave(ctx context.Context) (_node int, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(project.Table, project.Columns, sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID))
        if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldTitle, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Description(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldDescription, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.DescriptionCleared() </span><span class="cov0" title="0">{
                _spec.ClearField(project.FieldDescription, field.TypeString)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.State(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldState, field.TypeEnum, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.TotalTasks(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldTotalTasks, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedTotalTasks(); ok </span><span class="cov0" title="0">{
                _spec.AddField(project.FieldTotalTasks, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.CompletedTasks(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldCompletedTasks, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedCompletedTasks(); ok </span><span class="cov0" title="0">{
                _spec.AddField(project.FieldCompletedTasks, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Progress(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldProgress, field.TypeFloat64, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedProgress(); ok </span><span class="cov0" title="0">{
                _spec.AddField(project.FieldProgress, field.TypeFloat64, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.TasksCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   project.TasksTable,
                        Columns: []string{project.TasksColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedTasksIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.TasksCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   project.TasksTable,
                        Columns: []string{project.TasksColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.TasksIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   project.TasksTable,
                        Columns: []string{project.TasksColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{project.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}

// ProjectUpdateOne is the builder for updating a single Project entity.
type ProjectUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *ProjectMutation
}

// SetTitle sets the "title" field.
func (_u *ProjectUpdateOne) SetTitle(v string) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetTitle(v)
        return _u
}</span>

// SetNillableTitle sets the "title" field if the given value is not nil.
func (_u *ProjectUpdateOne) SetNillableTitle(v *string) *ProjectUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetTitle(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetDescription sets the "description" field.
func (_u *ProjectUpdateOne) SetDescription(v string) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetDescription(v)
        return _u
}</span>

// SetNillableDescription sets the "description" field if the given value is not nil.
func (_u *ProjectUpdateOne) SetNillableDescription(v *string) *ProjectUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetDescription(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearDescription clears the value of the "description" field.
func (_u *ProjectUpdateOne) ClearDescription() *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearDescription()
        return _u
}</span>

// SetState sets the "state" field.
func (_u *ProjectUpdateOne) SetState(v project.State) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetState(v)
        return _u
}</span>

// SetNillableState sets the "state" field if the given value is not nil.
func (_u *ProjectUpdateOne) SetNillableState(v *project.State) *ProjectUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetState(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (_u *ProjectUpdateOne) SetUpdatedAt(v time.Time) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetUpdatedAt(v)
        return _u
}</span>

// SetTotalTasks sets the "total_tasks" field.
func (_u *ProjectUpdateOne) SetTotalTasks(v int) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.ResetTotalTasks()
        _u.mutation.SetTotalTasks(v)
        return _u
}</span>

// SetNillableTotalTasks sets the "total_tasks" field if the given value is not nil.
func (_u *ProjectUpdateOne) SetNillableTotalTasks(v *int) *ProjectUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetTotalTasks(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddTotalTasks adds value to the "total_tasks" field.
func (_u *ProjectUpdateOne) AddTotalTasks(v int) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddTotalTasks(v)
        return _u
}</span>

// SetCompletedTasks sets the "completed_tasks" field.
func (_u *ProjectUpdateOne) SetCompletedTasks(v int) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.ResetCompletedTasks()
        _u.mutation.SetCompletedTasks(v)
        return _u
}</span>

// SetNillableCompletedTasks sets the "completed_tasks" field if the given value is not nil.
func (_u *ProjectUpdateOne) SetNillableCompletedTasks(v *int) *ProjectUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetCompletedTasks(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddCompletedTasks adds value to the "completed_tasks" field.
func (_u *ProjectUpdateOne) AddCompletedTasks(v int) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddCompletedTasks(v)
        return _u
}</span>

// SetProgress sets the "progress" field.
func (_u *ProjectUpdateOne) SetProgress(v float64) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.ResetProgress()
        _u.mutation.SetProgress(v)
        return _u
}</span>

// SetNillableProgress sets the "progress" field if the given value is not nil.
func (_u *ProjectUpdateOne) SetNillableProgress(v *float64) *ProjectUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetProgress(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddProgress adds value to the "progress" field.
func (_u *ProjectUpdateOne) AddProgress(v float64) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddProgress(v)
        return _u
}</span>

// AddTaskIDs adds the "tasks" edge to the Task entity by IDs.
func (_u *ProjectUpdateOne) AddTaskIDs(ids ...uuid.UUID) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddTaskIDs(ids...)
        return _u
}</span>

// AddTasks adds the "tasks" edges to the Task entity.
func (_u *ProjectUpdateOne) AddTasks(v ...*Task) *ProjectUpdateOne <span class="cov0" title="0">{
        ids := make([]uuid.UUID, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddTaskIDs(ids...)</span>
}

// Mutation returns the ProjectMutation object of the builder.
func (_u *ProjectUpdateOne) Mutation() *ProjectMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearTasks clears all "tasks" edges to the Task entity.
func (_u *ProjectUpdateOne) ClearTasks() *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearTasks()
        return _u
}</span>

// RemoveTaskIDs removes the "tasks" edge to Task entities by IDs.
func (_u *ProjectUpdateOne) RemoveTaskIDs(ids ...uuid.UUID) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.RemoveTaskIDs(ids...)
        return _u
}</span>

// RemoveTasks removes "tasks" edges to Task entities.
func (_u *ProjectUpdateOne) RemoveTasks(v ...*Task) *ProjectUpdateOne <span class="cov0" title="0">{
        ids := make([]uuid.UUID, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveTaskIDs(ids...)</span>
}

// Where appends a list predicates to the ProjectUpdate builder.
func (_u *ProjectUpdateOne) Where(ps ...predicate.Project) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *ProjectUpdateOne) Select(field string, fields ...string) *ProjectUpdateOne <span class="cov0" title="0">{
        _u.fields = append([]string{field}, fields...)
        return _u
}</span>

// Save executes the query and returns the updated Project entity.
func (_u *ProjectUpdateOne) Save(ctx context.Context) (*Project, error) <span class="cov0" title="0">{
        _u.defaults()
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *ProjectUpdateOne) SaveX(ctx context.Context) *Project <span class="cov0" title="0">{
        node, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (_u *ProjectUpdateOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *ProjectUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_u *ProjectUpdateOne) defaults() <span class="cov0" title="0">{
        if _, ok := _u.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                v := project.UpdateDefaultUpdatedAt()
                _u.mutation.SetUpdatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_u *ProjectUpdateOne) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                if err := project.TitleValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "Project.title": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.State(); ok </span><span class="cov0" title="0">{
                if err := project.StateValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "state", err: fmt.Errorf(`ent: validator failed for field "Project.state": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.TotalTasks(); ok </span><span class="cov0" title="0">{
                if err := project.TotalTasksValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "total_tasks", err: fmt.Errorf(`ent: validator failed for field "Project.total_tasks": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.CompletedTasks(); ok </span><span class="cov0" title="0">{
                if err := project.CompletedTasksValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "completed_tasks", err: fmt.Errorf(`ent: validator failed for field "Project.completed_tasks": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.Progress(); ok </span><span class="cov0" title="0">{
                if err := project.ProgressValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "progress", err: fmt.Errorf(`ent: validator failed for field "Project.progress": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_u *ProjectUpdateOne) sqlSave(ctx context.Context) (_node *Project, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(project.Table, project.Columns, sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID))
        id, ok := _u.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "Project.id" for update`)}
        }</span>
        <span class="cov0" title="0">_spec.Node.ID.Value = id
        if fields := _u.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, project.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !project.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != project.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov0" title="0">if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldTitle, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Description(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldDescription, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.DescriptionCleared() </span><span class="cov0" title="0">{
                _spec.ClearField(project.FieldDescription, field.TypeString)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.State(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldState, field.TypeEnum, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.TotalTasks(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldTotalTasks, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedTotalTasks(); ok </span><span class="cov0" title="0">{
                _spec.AddField(project.FieldTotalTasks, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.CompletedTasks(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldCompletedTasks, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedCompletedTasks(); ok </span><span class="cov0" title="0">{
                _spec.AddField(project.FieldCompletedTasks, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Progress(); ok </span><span class="cov0" title="0">{
                _spec.SetField(project.FieldProgress, field.TypeFloat64, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedProgress(); ok </span><span class="cov0" title="0">{
                _spec.AddField(project.FieldProgress, field.TypeFloat64, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.TasksCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   project.TasksTable,
                        Columns: []string{project.TasksColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedTasksIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.TasksCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   project.TasksTable,
                        Columns: []string{project.TasksColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.TasksIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   project.TasksTable,
                        Columns: []string{project.TasksColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">_node = &amp;Project{config: _u.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{project.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
        "github.com/google/uuid"
)

// ProjectContext is the model entity for the ProjectContext schema.
type ProjectContext struct {
        config `json:"-"`
        // ID of the ent.
        // Primary key - should always be 1 (singleton)
        ID int `json:"id,omitempty"`
        // Currently selected project ID
        SelectedProjectID uuid.UUID `json:"selected_project_id,omitempty"`
        // When the selection was last updated
        UpdatedAt time.Time `json:"updated_at,omitempty"`
        // Who updated the selection
        UpdatedBy string `json:"updated_by,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the ProjectContextQuery when eager-loading is set.
        Edges        ProjectContextEdges `json:"edges"`
        selectValues sql.SelectValues
}

// ProjectContextEdges holds the relations/edges for other nodes in the graph.
type ProjectContextEdges struct {
        // SelectedProject holds the value of the selected_project edge.
        SelectedProject *Project `json:"selected_project,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [1]bool
}

// SelectedProjectOrErr returns the SelectedProject value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ProjectContextEdges) SelectedProjectOrErr() (*Project, error) <span class="cov0" title="0">{
        if e.SelectedProject != nil </span><span class="cov0" title="0">{
                return e.SelectedProject, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: project.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "selected_project"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ProjectContext) scanValues(columns []string) ([]any, error) <span class="cov0" title="0">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case projectcontext.FieldID:<span class="cov0" title="0">
                        values[i] = new(sql.NullInt64)</span>
                case projectcontext.FieldUpdatedBy:<span class="cov0" title="0">
                        values[i] = new(sql.NullString)</span>
                case projectcontext.FieldUpdatedAt:<span class="cov0" title="0">
                        values[i] = new(sql.NullTime)</span>
                case projectcontext.FieldSelectedProjectID:<span class="cov0" title="0">
                        values[i] = new(uuid.UUID)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov0" title="0">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ProjectContext fields.
func (_m *ProjectContext) assignValues(columns []string, values []any) error <span class="cov0" title="0">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov0" title="0">for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case projectcontext.FieldID:<span class="cov0" title="0">
                        value, ok := values[i].(*sql.NullInt64)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", value)
                        }</span>
                        <span class="cov0" title="0">_m.ID = int(value.Int64)</span>
                case projectcontext.FieldSelectedProjectID:<span class="cov0" title="0">
                        if value, ok := values[i].(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field selected_project_id", values[i])
                        }</span> else<span class="cov0" title="0"> if value != nil </span><span class="cov0" title="0">{
                                _m.SelectedProjectID = *value
                        }</span>
                case projectcontext.FieldUpdatedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field updated_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.UpdatedAt = value.Time
                        }</span>
                case projectcontext.FieldUpdatedBy:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field updated_by", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.UpdatedBy = value.String
                        }</span>
                default:<span class="cov0" title="0">
                        _m.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the ProjectContext.
// This includes values selected through modifiers, order, etc.
func (_m *ProjectContext) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return _m.selectValues.Get(name)
}</span>

// QuerySelectedProject queries the "selected_project" edge of the ProjectContext entity.
func (_m *ProjectContext) QuerySelectedProject() *ProjectQuery <span class="cov0" title="0">{
        return NewProjectContextClient(_m.config).QuerySelectedProject(_m)
}</span>

// Update returns a builder for updating this ProjectContext.
// Note that you need to call ProjectContext.Unwrap() before calling this method if this ProjectContext
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *ProjectContext) Update() *ProjectContextUpdateOne <span class="cov0" title="0">{
        return NewProjectContextClient(_m.config).UpdateOne(_m)
}</span>

// Unwrap unwraps the ProjectContext entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *ProjectContext) Unwrap() *ProjectContext <span class="cov0" title="0">{
        _tx, ok := _m.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: ProjectContext is not a transactional entity")</span>
        }
        <span class="cov0" title="0">_m.config.driver = _tx.drv
        return _m</span>
}

// String implements the fmt.Stringer.
func (_m *ProjectContext) String() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("ProjectContext(")
        builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
        builder.WriteString("selected_project_id=")
        builder.WriteString(fmt.Sprintf("%v", _m.SelectedProjectID))
        builder.WriteString(", ")
        builder.WriteString("updated_at=")
        builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
        builder.WriteString(", ")
        builder.WriteString("updated_by=")
        builder.WriteString(_m.UpdatedBy)
        builder.WriteByte(')')
        return builder.String()
}</span>

// ProjectContexts is a parsable slice of ProjectContext.
type ProjectContexts []*ProjectContext
</pre>
		
		<pre class="file" id="file46" style="display: none">// Code generated by ent, DO NOT EDIT.

package projectcontext

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

const (
        // Label holds the string label denoting the projectcontext type in the database.
        Label = "project_context"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldSelectedProjectID holds the string denoting the selected_project_id field in the database.
        FieldSelectedProjectID = "selected_project_id"
        // FieldUpdatedAt holds the string denoting the updated_at field in the database.
        FieldUpdatedAt = "updated_at"
        // FieldUpdatedBy holds the string denoting the updated_by field in the database.
        FieldUpdatedBy = "updated_by"
        // EdgeSelectedProject holds the string denoting the selected_project edge name in mutations.
        EdgeSelectedProject = "selected_project"
        // Table holds the table name of the projectcontext in the database.
        Table = "project_contexts"
        // SelectedProjectTable is the table that holds the selected_project relation/edge.
        SelectedProjectTable = "project_contexts"
        // SelectedProjectInverseTable is the table name for the Project entity.
        // It exists in this package in order to avoid circular dependency with the "project" package.
        SelectedProjectInverseTable = "projects"
        // SelectedProjectColumn is the table column denoting the selected_project relation/edge.
        SelectedProjectColumn = "selected_project_id"
)

// Columns holds all SQL columns for projectcontext fields.
var Columns = []string{
        FieldID,
        FieldSelectedProjectID,
        FieldUpdatedAt,
        FieldUpdatedBy,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var (
        // DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
        DefaultUpdatedAt func() time.Time
        // UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
        UpdateDefaultUpdatedAt func() time.Time
        // UpdatedByValidator is a validator for the "updated_by" field. It is called by the builders before save.
        UpdatedByValidator func(string) error
)

// OrderOption defines the ordering options for the ProjectContext queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// BySelectedProjectID orders the results by the selected_project_id field.
func BySelectedProjectID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldSelectedProjectID, opts...).ToFunc()
}</span>

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}</span>

// ByUpdatedBy orders the results by the updated_by field.
func ByUpdatedBy(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldUpdatedBy, opts...).ToFunc()
}</span>

// BySelectedProjectField orders the results by selected_project field.
func BySelectedProjectField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newSelectedProjectStep(), sql.OrderByField(field, opts...))
        }</span>
}
func newSelectedProjectStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(SelectedProjectInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, false, SelectedProjectTable, SelectedProjectColumn),
        )
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Code generated by ent, DO NOT EDIT.

package projectcontext

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldLTE(FieldID, id))
}</span>

// SelectedProjectID applies equality check predicate on the "selected_project_id" field. It's identical to SelectedProjectIDEQ.
func SelectedProjectID(v uuid.UUID) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldEQ(FieldSelectedProjectID, v))
}</span>

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// UpdatedBy applies equality check predicate on the "updated_by" field. It's identical to UpdatedByEQ.
func UpdatedBy(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldEQ(FieldUpdatedBy, v))
}</span>

// SelectedProjectIDEQ applies the EQ predicate on the "selected_project_id" field.
func SelectedProjectIDEQ(v uuid.UUID) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldEQ(FieldSelectedProjectID, v))
}</span>

// SelectedProjectIDNEQ applies the NEQ predicate on the "selected_project_id" field.
func SelectedProjectIDNEQ(v uuid.UUID) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldNEQ(FieldSelectedProjectID, v))
}</span>

// SelectedProjectIDIn applies the In predicate on the "selected_project_id" field.
func SelectedProjectIDIn(vs ...uuid.UUID) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldIn(FieldSelectedProjectID, vs...))
}</span>

// SelectedProjectIDNotIn applies the NotIn predicate on the "selected_project_id" field.
func SelectedProjectIDNotIn(vs ...uuid.UUID) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldNotIn(FieldSelectedProjectID, vs...))
}</span>

// SelectedProjectIDIsNil applies the IsNil predicate on the "selected_project_id" field.
func SelectedProjectIDIsNil() predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldIsNull(FieldSelectedProjectID))
}</span>

// SelectedProjectIDNotNil applies the NotNil predicate on the "selected_project_id" field.
func SelectedProjectIDNotNil() predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldNotNull(FieldSelectedProjectID))
}</span>

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldNEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldNotIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldGT(FieldUpdatedAt, v))
}</span>

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldGTE(FieldUpdatedAt, v))
}</span>

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldLT(FieldUpdatedAt, v))
}</span>

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldLTE(FieldUpdatedAt, v))
}</span>

// UpdatedByEQ applies the EQ predicate on the "updated_by" field.
func UpdatedByEQ(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldEQ(FieldUpdatedBy, v))
}</span>

// UpdatedByNEQ applies the NEQ predicate on the "updated_by" field.
func UpdatedByNEQ(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldNEQ(FieldUpdatedBy, v))
}</span>

// UpdatedByIn applies the In predicate on the "updated_by" field.
func UpdatedByIn(vs ...string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldIn(FieldUpdatedBy, vs...))
}</span>

// UpdatedByNotIn applies the NotIn predicate on the "updated_by" field.
func UpdatedByNotIn(vs ...string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldNotIn(FieldUpdatedBy, vs...))
}</span>

// UpdatedByGT applies the GT predicate on the "updated_by" field.
func UpdatedByGT(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldGT(FieldUpdatedBy, v))
}</span>

// UpdatedByGTE applies the GTE predicate on the "updated_by" field.
func UpdatedByGTE(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldGTE(FieldUpdatedBy, v))
}</span>

// UpdatedByLT applies the LT predicate on the "updated_by" field.
func UpdatedByLT(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldLT(FieldUpdatedBy, v))
}</span>

// UpdatedByLTE applies the LTE predicate on the "updated_by" field.
func UpdatedByLTE(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldLTE(FieldUpdatedBy, v))
}</span>

// UpdatedByContains applies the Contains predicate on the "updated_by" field.
func UpdatedByContains(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldContains(FieldUpdatedBy, v))
}</span>

// UpdatedByHasPrefix applies the HasPrefix predicate on the "updated_by" field.
func UpdatedByHasPrefix(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldHasPrefix(FieldUpdatedBy, v))
}</span>

// UpdatedByHasSuffix applies the HasSuffix predicate on the "updated_by" field.
func UpdatedByHasSuffix(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldHasSuffix(FieldUpdatedBy, v))
}</span>

// UpdatedByEqualFold applies the EqualFold predicate on the "updated_by" field.
func UpdatedByEqualFold(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldEqualFold(FieldUpdatedBy, v))
}</span>

// UpdatedByContainsFold applies the ContainsFold predicate on the "updated_by" field.
func UpdatedByContainsFold(v string) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.FieldContainsFold(FieldUpdatedBy, v))
}</span>

// HasSelectedProject applies the HasEdge predicate on the "selected_project" edge.
func HasSelectedProject() predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, false, SelectedProjectTable, SelectedProjectColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasSelectedProjectWith applies the HasEdge predicate on the "selected_project" edge with a given conditions (other predicates).
func HasSelectedProjectWith(preds ...predicate.Project) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newSelectedProjectStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.ProjectContext) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.ProjectContext) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.ProjectContext) predicate.ProjectContext <span class="cov0" title="0">{
        return predicate.ProjectContext(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
        "github.com/google/uuid"
)

// ProjectContextCreate is the builder for creating a ProjectContext entity.
type ProjectContextCreate struct {
        config
        mutation *ProjectContextMutation
        hooks    []Hook
}

// SetSelectedProjectID sets the "selected_project_id" field.
func (_c *ProjectContextCreate) SetSelectedProjectID(v uuid.UUID) *ProjectContextCreate <span class="cov0" title="0">{
        _c.mutation.SetSelectedProjectID(v)
        return _c
}</span>

// SetNillableSelectedProjectID sets the "selected_project_id" field if the given value is not nil.
func (_c *ProjectContextCreate) SetNillableSelectedProjectID(v *uuid.UUID) *ProjectContextCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetSelectedProjectID(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (_c *ProjectContextCreate) SetUpdatedAt(v time.Time) *ProjectContextCreate <span class="cov0" title="0">{
        _c.mutation.SetUpdatedAt(v)
        return _c
}</span>

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (_c *ProjectContextCreate) SetNillableUpdatedAt(v *time.Time) *ProjectContextCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetUpdatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetUpdatedBy sets the "updated_by" field.
func (_c *ProjectContextCreate) SetUpdatedBy(v string) *ProjectContextCreate <span class="cov0" title="0">{
        _c.mutation.SetUpdatedBy(v)
        return _c
}</span>

// SetID sets the "id" field.
func (_c *ProjectContextCreate) SetID(v int) *ProjectContextCreate <span class="cov0" title="0">{
        _c.mutation.SetID(v)
        return _c
}</span>

// SetSelectedProject sets the "selected_project" edge to the Project entity.
func (_c *ProjectContextCreate) SetSelectedProject(v *Project) *ProjectContextCreate <span class="cov0" title="0">{
        return _c.SetSelectedProjectID(v.ID)
}</span>

// Mutation returns the ProjectContextMutation object of the builder.
func (_c *ProjectContextCreate) Mutation() *ProjectContextMutation <span class="cov0" title="0">{
        return _c.mutation
}</span>

// Save creates the ProjectContext in the database.
func (_c *ProjectContextCreate) Save(ctx context.Context) (*ProjectContext, error) <span class="cov0" title="0">{
        _c.defaults()
        return withHooks(ctx, _c.sqlSave, _c.mutation, _c.hooks)
}</span>

// SaveX calls Save and panics if Save returns an error.
func (_c *ProjectContextCreate) SaveX(ctx context.Context) *ProjectContext <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *ProjectContextCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *ProjectContextCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_c *ProjectContextCreate) defaults() <span class="cov0" title="0">{
        if _, ok := _c.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                v := projectcontext.DefaultUpdatedAt()
                _c.mutation.SetUpdatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_c *ProjectContextCreate) check() error <span class="cov0" title="0">{
        if _, ok := _c.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "updated_at", err: errors.New(`ent: missing required field "ProjectContext.updated_at"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.UpdatedBy(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "updated_by", err: errors.New(`ent: missing required field "ProjectContext.updated_by"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.UpdatedBy(); ok </span><span class="cov0" title="0">{
                if err := projectcontext.UpdatedByValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "updated_by", err: fmt.Errorf(`ent: validator failed for field "ProjectContext.updated_by": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_c *ProjectContextCreate) sqlSave(ctx context.Context) (*ProjectContext, error) <span class="cov0" title="0">{
        if err := _c.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_node, _spec := _c.createSpec()
        if err := sqlgraph.CreateNode(ctx, _c.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if _spec.ID.Value != _node.ID </span><span class="cov0" title="0">{
                id := _spec.ID.Value.(int64)
                _node.ID = int(id)
        }</span>
        <span class="cov0" title="0">_c.mutation.id = &amp;_node.ID
        _c.mutation.done = true
        return _node, nil</span>
}

func (_c *ProjectContextCreate) createSpec() (*ProjectContext, *sqlgraph.CreateSpec) <span class="cov0" title="0">{
        var (
                _node = &amp;ProjectContext{config: _c.config}
                _spec = sqlgraph.NewCreateSpec(projectcontext.Table, sqlgraph.NewFieldSpec(projectcontext.FieldID, field.TypeInt))
        )
        if id, ok := _c.mutation.ID(); ok </span><span class="cov0" title="0">{
                _node.ID = id
                _spec.ID.Value = id
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(projectcontext.FieldUpdatedAt, field.TypeTime, value)
                _node.UpdatedAt = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.UpdatedBy(); ok </span><span class="cov0" title="0">{
                _spec.SetField(projectcontext.FieldUpdatedBy, field.TypeString, value)
                _node.UpdatedBy = value
        }</span>
        <span class="cov0" title="0">if nodes := _c.mutation.SelectedProjectIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   projectcontext.SelectedProjectTable,
                        Columns: []string{projectcontext.SelectedProjectColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_node.SelectedProjectID = nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">return _node, _spec</span>
}

// ProjectContextCreateBulk is the builder for creating many ProjectContext entities in bulk.
type ProjectContextCreateBulk struct {
        config
        err      error
        builders []*ProjectContextCreate
}

// Save creates the ProjectContext entities in the database.
func (_c *ProjectContextCreateBulk) Save(ctx context.Context) ([]*ProjectContext, error) <span class="cov0" title="0">{
        if _c.err != nil </span><span class="cov0" title="0">{
                return nil, _c.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(_c.builders))
        nodes := make([]*ProjectContext, len(_c.builders))
        mutators := make([]Mutator, len(_c.builders))
        for i := range _c.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := _c.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*ProjectContextMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, _c.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, _c.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                if specs[i].ID.Value != nil &amp;&amp; nodes[i].ID == 0 </span><span class="cov0" title="0">{
                                        id := specs[i].ID.Value.(int64)
                                        nodes[i].ID = int(id)
                                }</span>
                                <span class="cov0" title="0">mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, _c.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (_c *ProjectContextCreateBulk) SaveX(ctx context.Context) []*ProjectContext <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *ProjectContextCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *ProjectContextCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
)

// ProjectContextDelete is the builder for deleting a ProjectContext entity.
type ProjectContextDelete struct {
        config
        hooks    []Hook
        mutation *ProjectContextMutation
}

// Where appends a list predicates to the ProjectContextDelete builder.
func (_d *ProjectContextDelete) Where(ps ...predicate.ProjectContext) *ProjectContextDelete <span class="cov0" title="0">{
        _d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (_d *ProjectContextDelete) Exec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _d.sqlExec, _d.mutation, _d.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_d *ProjectContextDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := _d.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (_d *ProjectContextDelete) sqlExec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := sqlgraph.NewDeleteSpec(projectcontext.Table, sqlgraph.NewFieldSpec(projectcontext.FieldID, field.TypeInt))
        if ps := _d.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">affected, err := sqlgraph.DeleteNodes(ctx, _d.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov0" title="0">_d.mutation.done = true
        return affected, err</span>
}

// ProjectContextDeleteOne is the builder for deleting a single ProjectContext entity.
type ProjectContextDeleteOne struct {
        _d *ProjectContextDelete
}

// Where appends a list predicates to the ProjectContextDelete builder.
func (_d *ProjectContextDeleteOne) Where(ps ...predicate.ProjectContext) *ProjectContextDeleteOne <span class="cov0" title="0">{
        _d._d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query.
func (_d *ProjectContextDeleteOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        n, err := _d._d.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov0" title="0">
                return &amp;NotFoundError{projectcontext.Label}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (_d *ProjectContextDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _d.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "fmt"
        "math"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
        "github.com/google/uuid"
)

// ProjectContextQuery is the builder for querying ProjectContext entities.
type ProjectContextQuery struct {
        config
        ctx                 *QueryContext
        order               []projectcontext.OrderOption
        inters              []Interceptor
        predicates          []predicate.ProjectContext
        withSelectedProject *ProjectQuery
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the ProjectContextQuery builder.
func (_q *ProjectContextQuery) Where(ps ...predicate.ProjectContext) *ProjectContextQuery <span class="cov0" title="0">{
        _q.predicates = append(_q.predicates, ps...)
        return _q
}</span>

// Limit the number of records to be returned by this query.
func (_q *ProjectContextQuery) Limit(limit int) *ProjectContextQuery <span class="cov0" title="0">{
        _q.ctx.Limit = &amp;limit
        return _q
}</span>

// Offset to start from.
func (_q *ProjectContextQuery) Offset(offset int) *ProjectContextQuery <span class="cov0" title="0">{
        _q.ctx.Offset = &amp;offset
        return _q
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (_q *ProjectContextQuery) Unique(unique bool) *ProjectContextQuery <span class="cov0" title="0">{
        _q.ctx.Unique = &amp;unique
        return _q
}</span>

// Order specifies how the records should be ordered.
func (_q *ProjectContextQuery) Order(o ...projectcontext.OrderOption) *ProjectContextQuery <span class="cov0" title="0">{
        _q.order = append(_q.order, o...)
        return _q
}</span>

// QuerySelectedProject chains the current query on the "selected_project" edge.
func (_q *ProjectContextQuery) QuerySelectedProject() *ProjectQuery <span class="cov0" title="0">{
        query := (&amp;ProjectClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(projectcontext.Table, projectcontext.FieldID, selector),
                        sqlgraph.To(project.Table, project.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, false, projectcontext.SelectedProjectTable, projectcontext.SelectedProjectColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first ProjectContext entity from the query.
// Returns a *NotFoundError when no ProjectContext was found.
func (_q *ProjectContextQuery) First(ctx context.Context) (*ProjectContext, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(1).All(setContextOp(ctx, _q.ctx, ent.OpQueryFirst))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{projectcontext.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (_q *ProjectContextQuery) FirstX(ctx context.Context) *ProjectContext <span class="cov0" title="0">{
        node, err := _q.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first ProjectContext ID from the query.
// Returns a *NotFoundError when no ProjectContext ID was found.
func (_q *ProjectContextQuery) FirstID(ctx context.Context) (id int, err error) <span class="cov0" title="0">{
        var ids []int
        if ids, err = _q.Limit(1).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryFirstID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{projectcontext.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (_q *ProjectContextQuery) FirstIDX(ctx context.Context) int <span class="cov0" title="0">{
        id, err := _q.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single ProjectContext entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one ProjectContext entity is found.
// Returns a *NotFoundError when no ProjectContext entities are found.
func (_q *ProjectContextQuery) Only(ctx context.Context) (*ProjectContext, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(2).All(setContextOp(ctx, _q.ctx, ent.OpQueryOnly))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch len(nodes) </span>{
        case 1:<span class="cov0" title="0">
                return nodes[0], nil</span>
        case 0:<span class="cov0" title="0">
                return nil, &amp;NotFoundError{projectcontext.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{projectcontext.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (_q *ProjectContextQuery) OnlyX(ctx context.Context) *ProjectContext <span class="cov0" title="0">{
        node, err := _q.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only ProjectContext ID in the query.
// Returns a *NotSingularError when more than one ProjectContext ID is found.
// Returns a *NotFoundError when no entities are found.
func (_q *ProjectContextQuery) OnlyID(ctx context.Context) (id int, err error) <span class="cov0" title="0">{
        var ids []int
        if ids, err = _q.Limit(2).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryOnlyID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{projectcontext.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{projectcontext.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (_q *ProjectContextQuery) OnlyIDX(ctx context.Context) int <span class="cov0" title="0">{
        id, err := _q.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of ProjectContexts.
func (_q *ProjectContextQuery) All(ctx context.Context) ([]*ProjectContext, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryAll)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">qr := querierAll[[]*ProjectContext, *ProjectContextQuery]()
        return withInterceptors[[]*ProjectContext](ctx, _q, qr, _q.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (_q *ProjectContextQuery) AllX(ctx context.Context) []*ProjectContext <span class="cov0" title="0">{
        nodes, err := _q.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of ProjectContext IDs.
func (_q *ProjectContextQuery) IDs(ctx context.Context) (ids []int, err error) <span class="cov0" title="0">{
        if _q.ctx.Unique == nil &amp;&amp; _q.path != nil </span><span class="cov0" title="0">{
                _q.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, _q.ctx, ent.OpQueryIDs)
        if err = _q.Select(projectcontext.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (_q *ProjectContextQuery) IDsX(ctx context.Context) []int <span class="cov0" title="0">{
        ids, err := _q.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (_q *ProjectContextQuery) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryCount)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return withInterceptors[int](ctx, _q, querierCount[*ProjectContextQuery](), _q.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (_q *ProjectContextQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := _q.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (_q *ProjectContextQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryExist)
        switch _, err := _q.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (_q *ProjectContextQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := _q.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the ProjectContextQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (_q *ProjectContextQuery) Clone() *ProjectContextQuery <span class="cov0" title="0">{
        if _q == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;ProjectContextQuery{
                config:              _q.config,
                ctx:                 _q.ctx.Clone(),
                order:               append([]projectcontext.OrderOption{}, _q.order...),
                inters:              append([]Interceptor{}, _q.inters...),
                predicates:          append([]predicate.ProjectContext{}, _q.predicates...),
                withSelectedProject: _q.withSelectedProject.Clone(),
                // clone intermediate query.
                sql:  _q.sql.Clone(),
                path: _q.path,
        }</span>
}

// WithSelectedProject tells the query-builder to eager-load the nodes that are connected to
// the "selected_project" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ProjectContextQuery) WithSelectedProject(opts ...func(*ProjectQuery)) *ProjectContextQuery <span class="cov0" title="0">{
        query := (&amp;ProjectClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withSelectedProject = query
        return _q</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                SelectedProjectID uuid.UUID `json:"selected_project_id,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.ProjectContext.Query().
//                GroupBy(projectcontext.FieldSelectedProjectID).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (_q *ProjectContextQuery) GroupBy(field string, fields ...string) *ProjectContextGroupBy <span class="cov0" title="0">{
        _q.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;ProjectContextGroupBy{build: _q}
        grbuild.flds = &amp;_q.ctx.Fields
        grbuild.label = projectcontext.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                SelectedProjectID uuid.UUID `json:"selected_project_id,omitempty"`
//        }
//
//        client.ProjectContext.Query().
//                Select(projectcontext.FieldSelectedProjectID).
//                Scan(ctx, &amp;v)
func (_q *ProjectContextQuery) Select(fields ...string) *ProjectContextSelect <span class="cov0" title="0">{
        _q.ctx.Fields = append(_q.ctx.Fields, fields...)
        sbuild := &amp;ProjectContextSelect{ProjectContextQuery: _q}
        sbuild.label = projectcontext.Label
        sbuild.flds, sbuild.scan = &amp;_q.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a ProjectContextSelect configured with the given aggregations.
func (_q *ProjectContextQuery) Aggregate(fns ...AggregateFunc) *ProjectContextSelect <span class="cov0" title="0">{
        return _q.Select().Aggregate(fns...)
}</span>

func (_q *ProjectContextQuery) prepareQuery(ctx context.Context) error <span class="cov0" title="0">{
        for _, inter := range _q.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, _q); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, f := range _q.ctx.Fields </span><span class="cov0" title="0">{
                if !projectcontext.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov0" title="0">if _q.path != nil </span><span class="cov0" title="0">{
                prev, err := _q.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_q.sql = prev</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *ProjectContextQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*ProjectContext, error) <span class="cov0" title="0">{
        var (
                nodes       = []*ProjectContext{}
                _spec       = _q.querySpec()
                loadedTypes = [1]bool{
                        _q.withSelectedProject != nil,
                }
        )
        _spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov0" title="0">{
                return (*ProjectContext).scanValues(nil, columns)
        }</span>
        <span class="cov0" title="0">_spec.Assign = func(columns []string, values []any) error </span><span class="cov0" title="0">{
                node := &amp;ProjectContext{config: _q.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov0" title="0">for i := range hooks </span><span class="cov0" title="0">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov0" title="0">if err := sqlgraph.QueryNodes(ctx, _q.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nodes, nil
        }</span>
        <span class="cov0" title="0">if query := _q.withSelectedProject; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadSelectedProject(ctx, query, nodes, nil,
                        func(n *ProjectContext, e *Project) </span><span class="cov0" title="0">{ n.Edges.SelectedProject = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

func (_q *ProjectContextQuery) loadSelectedProject(ctx context.Context, query *ProjectQuery, nodes []*ProjectContext, init func(*ProjectContext), assign func(*ProjectContext, *Project)) error <span class="cov0" title="0">{
        ids := make([]uuid.UUID, 0, len(nodes))
        nodeids := make(map[uuid.UUID][]*ProjectContext)
        for i := range nodes </span><span class="cov0" title="0">{
                fk := nodes[i].SelectedProjectID
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(project.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "selected_project_id" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *ProjectContextQuery) sqlCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := _q.querySpec()
        _spec.Node.Columns = _q.ctx.Fields
        if len(_q.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique
        }</span>
        <span class="cov0" title="0">return sqlgraph.CountNodes(ctx, _q.driver, _spec)</span>
}

func (_q *ProjectContextQuery) querySpec() *sqlgraph.QuerySpec <span class="cov0" title="0">{
        _spec := sqlgraph.NewQuerySpec(projectcontext.Table, projectcontext.Columns, sqlgraph.NewFieldSpec(projectcontext.FieldID, field.TypeInt))
        _spec.From = _q.sql
        if unique := _q.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov0" title="0"> if _q.path != nil </span><span class="cov0" title="0">{
                _spec.Unique = true
        }</span>
        <span class="cov0" title="0">if fields := _q.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, projectcontext.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != projectcontext.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
                <span class="cov0" title="0">if _q.withSelectedProject != nil </span><span class="cov0" title="0">{
                        _spec.Node.AddColumnOnce(projectcontext.FieldSelectedProjectID)
                }</span>
        }
        <span class="cov0" title="0">if ps := _q.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                _spec.Limit = *limit
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                _spec.Offset = *offset
        }</span>
        <span class="cov0" title="0">if ps := _q.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">return _spec</span>
}

func (_q *ProjectContextQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(_q.driver.Dialect())
        t1 := builder.Table(projectcontext.Table)
        columns := _q.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = projectcontext.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if _q.sql != nil </span><span class="cov0" title="0">{
                selector = _q.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range _q.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range _q.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// ProjectContextGroupBy is the group-by builder for ProjectContext entities.
type ProjectContextGroupBy struct {
        selector
        build *ProjectContextQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (_g *ProjectContextGroupBy) Aggregate(fns ...AggregateFunc) *ProjectContextGroupBy <span class="cov0" title="0">{
        _g.fns = append(_g.fns, fns...)
        return _g
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_g *ProjectContextGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _g.build.ctx, ent.OpQueryGroupBy)
        if err := _g.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*ProjectContextQuery, *ProjectContextGroupBy](ctx, _g.build, _g, _g.build.inters, v)</span>
}

func (_g *ProjectContextGroupBy) sqlScan(ctx context.Context, root *ProjectContextQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(_g.fns))
        for _, fn := range _g.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*_g.flds)+len(_g.fns))
                for _, f := range *_g.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*_g.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _g.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// ProjectContextSelect is the builder for selecting fields of ProjectContext entities.
type ProjectContextSelect struct {
        *ProjectContextQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (_s *ProjectContextSelect) Aggregate(fns ...AggregateFunc) *ProjectContextSelect <span class="cov0" title="0">{
        _s.fns = append(_s.fns, fns...)
        return _s
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_s *ProjectContextSelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _s.ctx, ent.OpQuerySelect)
        if err := _s.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*ProjectContextQuery, *ProjectContextSelect](ctx, _s.ProjectContextQuery, _s, _s.inters, v)</span>
}

func (_s *ProjectContextSelect) sqlScan(ctx context.Context, root *ProjectContextQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(_s.fns))
        for _, fn := range _s.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*_s.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _s.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
        "github.com/google/uuid"
)

// ProjectContextUpdate is the builder for updating ProjectContext entities.
type ProjectContextUpdate struct {
        config
        hooks    []Hook
        mutation *ProjectContextMutation
}

// Where appends a list predicates to the ProjectContextUpdate builder.
func (_u *ProjectContextUpdate) Where(ps ...predicate.ProjectContext) *ProjectContextUpdate <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// SetSelectedProjectID sets the "selected_project_id" field.
func (_u *ProjectContextUpdate) SetSelectedProjectID(v uuid.UUID) *ProjectContextUpdate <span class="cov0" title="0">{
        _u.mutation.SetSelectedProjectID(v)
        return _u
}</span>

// SetNillableSelectedProjectID sets the "selected_project_id" field if the given value is not nil.
func (_u *ProjectContextUpdate) SetNillableSelectedProjectID(v *uuid.UUID) *ProjectContextUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetSelectedProjectID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearSelectedProjectID clears the value of the "selected_project_id" field.
func (_u *ProjectContextUpdate) ClearSelectedProjectID() *ProjectContextUpdate <span class="cov0" title="0">{
        _u.mutation.ClearSelectedProjectID()
        return _u
}</span>

// SetUpdatedAt sets the "updated_at" field.
func (_u *ProjectContextUpdate) SetUpdatedAt(v time.Time) *ProjectContextUpdate <span class="cov0" title="0">{
        _u.mutation.SetUpdatedAt(v)
        return _u
}</span>

// SetUpdatedBy sets the "updated_by" field.
func (_u *ProjectContextUpdate) SetUpdatedBy(v string) *ProjectContextUpdate <span class="cov0" title="0">{
        _u.mutation.SetUpdatedBy(v)
        return _u
}</span>

// SetNillableUpdatedBy sets the "updated_by" field if the given value is not nil.
func (_u *ProjectContextUpdate) SetNillableUpdatedBy(v *string) *ProjectContextUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetUpdatedBy(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetSelectedProject sets the "selected_project" edge to the Project entity.
func (_u *ProjectContextUpdate) SetSelectedProject(v *Project) *ProjectContextUpdate <span class="cov0" title="0">{
        return _u.SetSelectedProjectID(v.ID)
}</span>

// Mutation returns the ProjectContextMutation object of the builder.
func (_u *ProjectContextUpdate) Mutation() *ProjectContextMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearSelectedProject clears the "selected_project" edge to the Project entity.
func (_u *ProjectContextUpdate) ClearSelectedProject() *ProjectContextUpdate <span class="cov0" title="0">{
        _u.mutation.ClearSelectedProject()
        return _u
}</span>

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *ProjectContextUpdate) Save(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _u.defaults()
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *ProjectContextUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (_u *ProjectContextUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *ProjectContextUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_u *ProjectContextUpdate) defaults() <span class="cov0" title="0">{
        if _, ok := _u.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                v := projectcontext.UpdateDefaultUpdatedAt()
                _u.mutation.SetUpdatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_u *ProjectContextUpdate) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.UpdatedBy(); ok </span><span class="cov0" title="0">{
                if err := projectcontext.UpdatedByValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "updated_by", err: fmt.Errorf(`ent: validator failed for field "ProjectContext.updated_by": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_u *ProjectContextUpdate) sqlSave(ctx context.Context) (_node int, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(projectcontext.Table, projectcontext.Columns, sqlgraph.NewFieldSpec(projectcontext.FieldID, field.TypeInt))
        if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(projectcontext.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.UpdatedBy(); ok </span><span class="cov0" title="0">{
                _spec.SetField(projectcontext.FieldUpdatedBy, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.SelectedProjectCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   projectcontext.SelectedProjectTable,
                        Columns: []string{projectcontext.SelectedProjectColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.SelectedProjectIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   projectcontext.SelectedProjectTable,
                        Columns: []string{projectcontext.SelectedProjectColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{projectcontext.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}

// ProjectContextUpdateOne is the builder for updating a single ProjectContext entity.
type ProjectContextUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *ProjectContextMutation
}

// SetSelectedProjectID sets the "selected_project_id" field.
func (_u *ProjectContextUpdateOne) SetSelectedProjectID(v uuid.UUID) *ProjectContextUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetSelectedProjectID(v)
        return _u
}</span>

// SetNillableSelectedProjectID sets the "selected_project_id" field if the given value is not nil.
func (_u *ProjectContextUpdateOne) SetNillableSelectedProjectID(v *uuid.UUID) *ProjectContextUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetSelectedProjectID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearSelectedProjectID clears the value of the "selected_project_id" field.
func (_u *ProjectContextUpdateOne) ClearSelectedProjectID() *ProjectContextUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearSelectedProjectID()
        return _u
}</span>

// SetUpdatedAt sets the "updated_at" field.
func (_u *ProjectContextUpdateOne) SetUpdatedAt(v time.Time) *ProjectContextUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetUpdatedAt(v)
        return _u
}</span>

// SetUpdatedBy sets the "updated_by" field.
func (_u *ProjectContextUpdateOne) SetUpdatedBy(v string) *ProjectContextUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetUpdatedBy(v)
        return _u
}</span>

// SetNillableUpdatedBy sets the "updated_by" field if the given value is not nil.
func (_u *ProjectContextUpdateOne) SetNillableUpdatedBy(v *string) *ProjectContextUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetUpdatedBy(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetSelectedProject sets the "selected_project" edge to the Project entity.
func (_u *ProjectContextUpdateOne) SetSelectedProject(v *Project) *ProjectContextUpdateOne <span class="cov0" title="0">{
        return _u.SetSelectedProjectID(v.ID)
}</span>

// Mutation returns the ProjectContextMutation object of the builder.
func (_u *ProjectContextUpdateOne) Mutation() *ProjectContextMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearSelectedProject clears the "selected_project" edge to the Project entity.
func (_u *ProjectContextUpdateOne) ClearSelectedProject() *ProjectContextUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearSelectedProject()
        return _u
}</span>

// Where appends a list predicates to the ProjectContextUpdate builder.
func (_u *ProjectContextUpdateOne) Where(ps ...predicate.ProjectContext) *ProjectContextUpdateOne <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *ProjectContextUpdateOne) Select(field string, fields ...string) *ProjectContextUpdateOne <span class="cov0" title="0">{
        _u.fields = append([]string{field}, fields...)
        return _u
}</span>

// Save executes the query and returns the updated ProjectContext entity.
func (_u *ProjectContextUpdateOne) Save(ctx context.Context) (*ProjectContext, error) <span class="cov0" title="0">{
        _u.defaults()
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *ProjectContextUpdateOne) SaveX(ctx context.Context) *ProjectContext <span class="cov0" title="0">{
        node, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (_u *ProjectContextUpdateOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *ProjectContextUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_u *ProjectContextUpdateOne) defaults() <span class="cov0" title="0">{
        if _, ok := _u.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                v := projectcontext.UpdateDefaultUpdatedAt()
                _u.mutation.SetUpdatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_u *ProjectContextUpdateOne) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.UpdatedBy(); ok </span><span class="cov0" title="0">{
                if err := projectcontext.UpdatedByValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "updated_by", err: fmt.Errorf(`ent: validator failed for field "ProjectContext.updated_by": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_u *ProjectContextUpdateOne) sqlSave(ctx context.Context) (_node *ProjectContext, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(projectcontext.Table, projectcontext.Columns, sqlgraph.NewFieldSpec(projectcontext.FieldID, field.TypeInt))
        id, ok := _u.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "ProjectContext.id" for update`)}
        }</span>
        <span class="cov0" title="0">_spec.Node.ID.Value = id
        if fields := _u.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, projectcontext.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !projectcontext.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != projectcontext.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov0" title="0">if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(projectcontext.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.UpdatedBy(); ok </span><span class="cov0" title="0">{
                _spec.SetField(projectcontext.FieldUpdatedBy, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.SelectedProjectCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   projectcontext.SelectedProjectTable,
                        Columns: []string{projectcontext.SelectedProjectColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.SelectedProjectIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   projectcontext.SelectedProjectTable,
                        Columns: []string{projectcontext.SelectedProjectColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">_node = &amp;ProjectContext{config: _u.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{projectcontext.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "time"

        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/schema"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
        "github.com/google/uuid"
)

// The init function reads all schema descriptors with runtime code
// (default values, validators, hooks and policies) and stitches it
// to their package variables.
func init() <span class="cov0" title="0">{
        projectFields := schema.Project{}.Fields()
        _ = projectFields
        // projectDescTitle is the schema descriptor for title field.
        projectDescTitle := projectFields[1].Descriptor()
        // project.TitleValidator is a validator for the "title" field. It is called by the builders before save.
        project.TitleValidator = func() func(string) error </span><span class="cov0" title="0">{
                validators := projectDescTitle.Validators
                fns := [...]func(string) error{
                        validators[0].(func(string) error),
                        validators[1].(func(string) error),
                }
                return func(title string) error </span><span class="cov0" title="0">{
                        for _, fn := range fns </span><span class="cov0" title="0">{
                                if err := fn(title); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
        }()
        // projectDescCreatedAt is the schema descriptor for created_at field.
        <span class="cov0" title="0">projectDescCreatedAt := projectFields[4].Descriptor()
        // project.DefaultCreatedAt holds the default value on creation for the created_at field.
        project.DefaultCreatedAt = projectDescCreatedAt.Default.(func() time.Time)
        // projectDescUpdatedAt is the schema descriptor for updated_at field.
        projectDescUpdatedAt := projectFields[5].Descriptor()
        // project.DefaultUpdatedAt holds the default value on creation for the updated_at field.
        project.DefaultUpdatedAt = projectDescUpdatedAt.Default.(func() time.Time)
        // project.UpdateDefaultUpdatedAt holds the default value on update for the updated_at field.
        project.UpdateDefaultUpdatedAt = projectDescUpdatedAt.UpdateDefault.(func() time.Time)
        // projectDescTotalTasks is the schema descriptor for total_tasks field.
        projectDescTotalTasks := projectFields[6].Descriptor()
        // project.DefaultTotalTasks holds the default value on creation for the total_tasks field.
        project.DefaultTotalTasks = projectDescTotalTasks.Default.(int)
        // project.TotalTasksValidator is a validator for the "total_tasks" field. It is called by the builders before save.
        project.TotalTasksValidator = projectDescTotalTasks.Validators[0].(func(int) error)
        // projectDescCompletedTasks is the schema descriptor for completed_tasks field.
        projectDescCompletedTasks := projectFields[7].Descriptor()
        // project.DefaultCompletedTasks holds the default value on creation for the completed_tasks field.
        project.DefaultCompletedTasks = projectDescCompletedTasks.Default.(int)
        // project.CompletedTasksValidator is a validator for the "completed_tasks" field. It is called by the builders before save.
        project.CompletedTasksValidator = projectDescCompletedTasks.Validators[0].(func(int) error)
        // projectDescProgress is the schema descriptor for progress field.
        projectDescProgress := projectFields[8].Descriptor()
        // project.DefaultProgress holds the default value on creation for the progress field.
        project.DefaultProgress = projectDescProgress.Default.(float64)
        // project.ProgressValidator is a validator for the "progress" field. It is called by the builders before save.
        project.ProgressValidator = func() func(float64) error </span><span class="cov0" title="0">{
                validators := projectDescProgress.Validators
                fns := [...]func(float64) error{
                        validators[0].(func(float64) error),
                        validators[1].(func(float64) error),
                }
                return func(progress float64) error </span><span class="cov0" title="0">{
                        for _, fn := range fns </span><span class="cov0" title="0">{
                                if err := fn(progress); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
        }()
        // projectDescID is the schema descriptor for id field.
        <span class="cov0" title="0">projectDescID := projectFields[0].Descriptor()
        // project.DefaultID holds the default value on creation for the id field.
        project.DefaultID = projectDescID.Default.(func() uuid.UUID)
        projectcontextFields := schema.ProjectContext{}.Fields()
        _ = projectcontextFields
        // projectcontextDescUpdatedAt is the schema descriptor for updated_at field.
        projectcontextDescUpdatedAt := projectcontextFields[2].Descriptor()
        // projectcontext.DefaultUpdatedAt holds the default value on creation for the updated_at field.
        projectcontext.DefaultUpdatedAt = projectcontextDescUpdatedAt.Default.(func() time.Time)
        // projectcontext.UpdateDefaultUpdatedAt holds the default value on update for the updated_at field.
        projectcontext.UpdateDefaultUpdatedAt = projectcontextDescUpdatedAt.UpdateDefault.(func() time.Time)
        // projectcontextDescUpdatedBy is the schema descriptor for updated_by field.
        projectcontextDescUpdatedBy := projectcontextFields[3].Descriptor()
        // projectcontext.UpdatedByValidator is a validator for the "updated_by" field. It is called by the builders before save.
        projectcontext.UpdatedByValidator = projectcontextDescUpdatedBy.Validators[0].(func(string) error)
        taskFields := schema.Task{}.Fields()
        _ = taskFields
        // taskDescTitle is the schema descriptor for title field.
        taskDescTitle := taskFields[3].Descriptor()
        // task.TitleValidator is a validator for the "title" field. It is called by the builders before save.
        task.TitleValidator = func() func(string) error </span><span class="cov0" title="0">{
                validators := taskDescTitle.Validators
                fns := [...]func(string) error{
                        validators[0].(func(string) error),
                        validators[1].(func(string) error),
                }
                return func(title string) error </span><span class="cov0" title="0">{
                        for _, fn := range fns </span><span class="cov0" title="0">{
                                if err := fn(title); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
        }()
        // taskDescComplexity is the schema descriptor for complexity field.
        <span class="cov0" title="0">taskDescComplexity := taskFields[7].Descriptor()
        // task.ComplexityValidator is a validator for the "complexity" field. It is called by the builders before save.
        task.ComplexityValidator = func() func(int) error </span><span class="cov0" title="0">{
                validators := taskDescComplexity.Validators
                fns := [...]func(int) error{
                        validators[0].(func(int) error),
                        validators[1].(func(int) error),
                }
                return func(complexity int) error </span><span class="cov0" title="0">{
                        for _, fn := range fns </span><span class="cov0" title="0">{
                                if err := fn(complexity); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
        }()
        // taskDescDepth is the schema descriptor for depth field.
        <span class="cov0" title="0">taskDescDepth := taskFields[8].Descriptor()
        // task.DefaultDepth holds the default value on creation for the depth field.
        task.DefaultDepth = taskDescDepth.Default.(int)
        // task.DepthValidator is a validator for the "depth" field. It is called by the builders before save.
        task.DepthValidator = taskDescDepth.Validators[0].(func(int) error)
        // taskDescCreatedAt is the schema descriptor for created_at field.
        taskDescCreatedAt := taskFields[11].Descriptor()
        // task.DefaultCreatedAt holds the default value on creation for the created_at field.
        task.DefaultCreatedAt = taskDescCreatedAt.Default.(func() time.Time)
        // taskDescUpdatedAt is the schema descriptor for updated_at field.
        taskDescUpdatedAt := taskFields[12].Descriptor()
        // task.DefaultUpdatedAt holds the default value on creation for the updated_at field.
        task.DefaultUpdatedAt = taskDescUpdatedAt.Default.(func() time.Time)
        // task.UpdateDefaultUpdatedAt holds the default value on update for the updated_at field.
        task.UpdateDefaultUpdatedAt = taskDescUpdatedAt.UpdateDefault.(func() time.Time)
        // taskDescID is the schema descriptor for id field.
        taskDescID := taskFields[0].Descriptor()
        // task.DefaultID holds the default value on creation for the id field.
        task.DefaultID = taskDescID.Default.(func() uuid.UUID)
        taskdependencyFields := schema.TaskDependency{}.Fields()
        _ = taskdependencyFields
        // taskdependencyDescCreatedAt is the schema descriptor for created_at field.
        taskdependencyDescCreatedAt := taskdependencyFields[3].Descriptor()
        // taskdependency.DefaultCreatedAt holds the default value on creation for the created_at field.
        taskdependency.DefaultCreatedAt = taskdependencyDescCreatedAt.Default.(func() time.Time)
        // taskdependencyDescID is the schema descriptor for id field.
        taskdependencyDescID := taskdependencyFields[0].Descriptor()
        // taskdependency.DefaultID holds the default value on creation for the id field.
        taskdependency.DefaultID = taskdependencyDescID.Default.(func() uuid.UUID)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package schema

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
        "entgo.io/ent/schema/index"
        "github.com/google/uuid"
)

// Project holds the schema definition for the Project entity.
type Project struct {
        ent.Schema
}

// Fields of the Project.
func (Project) Fields() []ent.Field <span class="cov0" title="0">{
        return []ent.Field{
                field.UUID("id", uuid.UUID{}).
                        Default(uuid.New).
                        Unique().
                        Immutable(),
                field.String("title").
                        MaxLen(200).
                        NotEmpty(),
                field.Text("description").
                        Optional(),
                field.Enum("state").
                        Values("active", "completed", "archived", "deletion-pending").
                        Default("active"),
                field.Time("created_at").
                        Default(time.Now).
                        Immutable(),
                field.Time("updated_at").
                        Default(time.Now).
                        UpdateDefault(time.Now),
                field.Int("total_tasks").
                        Default(0).
                        NonNegative(),
                field.Int("completed_tasks").
                        Default(0).
                        NonNegative(),
                field.Float("progress").
                        Default(0.0).
                        Min(0.0).
                        Max(100.0),
        }
}</span>

// Edges of the Project.
func (Project) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                edge.To("tasks", Task.Type),
        }
}</span>

// Indexes of the Project.
func (Project) Indexes() []ent.Index <span class="cov0" title="0">{
        return []ent.Index{
                index.Fields("created_at"),
                index.Fields("title"),
                index.Fields("progress"),
                index.Fields("state"),
        }
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package schema

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
        "github.com/google/uuid"
)

// ProjectContext holds the schema definition for the ProjectContext entity.
// This stores the currently selected project for the CLI context.
type ProjectContext struct {
        ent.Schema
}

// Fields of the ProjectContext.
func (ProjectContext) Fields() []ent.Field <span class="cov0" title="0">{
        return []ent.Field{
                field.Int("id").
                        Unique().
                        Immutable().
                        Comment("Primary key - should always be 1 (singleton)"),
                field.UUID("selected_project_id", uuid.UUID{}).
                        Optional().
                        Comment("Currently selected project ID"),
                field.Time("updated_at").
                        Default(time.Now).
                        UpdateDefault(time.Now).
                        Comment("When the selection was last updated"),
                field.String("updated_by").
                        NotEmpty().
                        Comment("Who updated the selection"),
        }
}</span>

// Edges of the ProjectContext.
func (ProjectContext) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                // Reference to the selected project
                // Note: Not using Required() to allow project deletion without constraint issues
                edge.To("selected_project", Project.Type).
                        Field("selected_project_id").
                        Unique(),
        }
}</pre>
		
		<pre class="file" id="file55" style="display: none">package schema

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
        "entgo.io/ent/schema/index"
        "github.com/google/uuid"
)

// Task holds the schema definition for the Task entity.
type Task struct {
        ent.Schema
}

// Fields of the Task.
func (Task) Fields() []ent.Field <span class="cov0" title="0">{
        return []ent.Field{
                field.UUID("id", uuid.UUID{}).
                        Default(uuid.New).
                        Unique().
                        Immutable(),
                field.UUID("project_id", uuid.UUID{}),
                field.UUID("parent_id", uuid.UUID{}).
                        Optional().
                        Nillable(),
                field.String("title").
                        MaxLen(200).
                        NotEmpty(),
                field.Text("description").
                        Optional(),
                field.Enum("state").
                        Values("pending", "in-progress", "completed", "blocked", "cancelled", "deletion-pending").
                        Default("pending"),
                field.Enum("priority").
                        Values("low", "medium", "high").
                        Default("medium"),
                field.Int("complexity").
                        Min(1).
                        Max(10),
                field.Int("depth").
                        Default(0).
                        NonNegative(),
                field.Int64("estimate").
                        Optional().
                        Nillable().
                        Comment("Time estimate in minutes"),
                field.UUID("assigned_agent", uuid.UUID{}).
                        Optional().
                        Nillable(),
                field.Time("created_at").
                        Default(time.Now).
                        Immutable(),
                field.Time("updated_at").
                        Default(time.Now).
                        UpdateDefault(time.Now),
                field.Time("completed_at").
                        Optional().
                        Nillable(),
        }
}</span>

// Edges of the Task.
func (Task) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                // Belongs to a project
                edge.From("project", Project.Type).
                        Ref("tasks").
                        Field("project_id").
                        Unique().
                        Required(),
                
                // Self-referencing parent-child relationship
                edge.To("children", Task.Type).
                        From("parent").
                        Field("parent_id").
                        Unique(),
        }
}</span>

// Indexes of the Task.
func (Task) Indexes() []ent.Index <span class="cov0" title="0">{
        return []ent.Index{
                // Core indexes for foreign keys and filtering
                index.Fields("project_id"),
                index.Fields("parent_id"),
                index.Fields("state"),
                index.Fields("priority"),
                index.Fields("assigned_agent"),
                index.Fields("complexity"),
                index.Fields("depth"),
                index.Fields("created_at"),
                
                // Composite indexes for common query patterns
                index.Fields("project_id", "state"),
                index.Fields("project_id", "priority"),
                index.Fields("project_id", "assigned_agent"),
                index.Fields("project_id", "parent_id"),
                index.Fields("project_id", "depth"),
                index.Fields("state", "complexity"),
                index.Fields("priority", "state"),
                index.Fields("priority", "complexity"),
        }
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package schema

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
        "entgo.io/ent/schema/index"
        "github.com/google/uuid"
)

// TaskDependency holds the schema definition for the TaskDependency entity.
// This is a junction table for many-to-many task dependencies.
type TaskDependency struct {
        ent.Schema
}

// Fields of the TaskDependency.
func (TaskDependency) Fields() []ent.Field <span class="cov0" title="0">{
        return []ent.Field{
                field.UUID("id", uuid.UUID{}).
                        Default(uuid.New).
                        Unique().
                        Immutable(),
                field.UUID("task_id", uuid.UUID{}),
                field.UUID("depends_on_task_id", uuid.UUID{}),
                field.Time("created_at").
                        Default(time.Now).
                        Immutable(),
        }
}</span>

// Edges of the TaskDependency.
func (TaskDependency) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                // The task that has the dependency
                edge.To("task", Task.Type).
                        Field("task_id").
                        Unique().
                        Required(),
                
                // The task that is depended upon
                edge.To("depends_on_task", Task.Type).
                        Field("depends_on_task_id").
                        Unique().
                        Required(),
        }
}</span>

// Indexes of the TaskDependency.
func (TaskDependency) Indexes() []ent.Index <span class="cov0" title="0">{
        return []ent.Index{
                // Individual indexes for foreign keys
                index.Fields("task_id"),
                index.Fields("depends_on_task_id"),
                
                // Unique constraint to prevent duplicate dependencies
                index.Fields("task_id", "depends_on_task_id").Unique(),
                
                // Index for reverse lookups (what depends on this task)
                index.Fields("depends_on_task_id", "task_id"),
                
                // Index for time-based queries
                index.Fields("created_at"),
        }
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/google/uuid"
)

// Task is the model entity for the Task schema.
type Task struct {
        config `json:"-"`
        // ID of the ent.
        ID uuid.UUID `json:"id,omitempty"`
        // ProjectID holds the value of the "project_id" field.
        ProjectID uuid.UUID `json:"project_id,omitempty"`
        // ParentID holds the value of the "parent_id" field.
        ParentID *uuid.UUID `json:"parent_id,omitempty"`
        // Title holds the value of the "title" field.
        Title string `json:"title,omitempty"`
        // Description holds the value of the "description" field.
        Description string `json:"description,omitempty"`
        // State holds the value of the "state" field.
        State task.State `json:"state,omitempty"`
        // Priority holds the value of the "priority" field.
        Priority task.Priority `json:"priority,omitempty"`
        // Complexity holds the value of the "complexity" field.
        Complexity int `json:"complexity,omitempty"`
        // Depth holds the value of the "depth" field.
        Depth int `json:"depth,omitempty"`
        // Time estimate in minutes
        Estimate *int64 `json:"estimate,omitempty"`
        // AssignedAgent holds the value of the "assigned_agent" field.
        AssignedAgent *uuid.UUID `json:"assigned_agent,omitempty"`
        // CreatedAt holds the value of the "created_at" field.
        CreatedAt time.Time `json:"created_at,omitempty"`
        // UpdatedAt holds the value of the "updated_at" field.
        UpdatedAt time.Time `json:"updated_at,omitempty"`
        // CompletedAt holds the value of the "completed_at" field.
        CompletedAt *time.Time `json:"completed_at,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the TaskQuery when eager-loading is set.
        Edges        TaskEdges `json:"edges"`
        selectValues sql.SelectValues
}

// TaskEdges holds the relations/edges for other nodes in the graph.
type TaskEdges struct {
        // Project holds the value of the project edge.
        Project *Project `json:"project,omitempty"`
        // Parent holds the value of the parent edge.
        Parent *Task `json:"parent,omitempty"`
        // Children holds the value of the children edge.
        Children []*Task `json:"children,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [3]bool
}

// ProjectOrErr returns the Project value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TaskEdges) ProjectOrErr() (*Project, error) <span class="cov0" title="0">{
        if e.Project != nil </span><span class="cov0" title="0">{
                return e.Project, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: project.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "project"}</span>
}

// ParentOrErr returns the Parent value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TaskEdges) ParentOrErr() (*Task, error) <span class="cov0" title="0">{
        if e.Parent != nil </span><span class="cov0" title="0">{
                return e.Parent, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[1] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: task.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "parent"}</span>
}

// ChildrenOrErr returns the Children value or an error if the edge
// was not loaded in eager-loading.
func (e TaskEdges) ChildrenOrErr() ([]*Task, error) <span class="cov0" title="0">{
        if e.loadedTypes[2] </span><span class="cov0" title="0">{
                return e.Children, nil
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "children"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Task) scanValues(columns []string) ([]any, error) <span class="cov0" title="0">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case task.FieldParentID, task.FieldAssignedAgent:<span class="cov0" title="0">
                        values[i] = &amp;sql.NullScanner{S: new(uuid.UUID)}</span>
                case task.FieldComplexity, task.FieldDepth, task.FieldEstimate:<span class="cov0" title="0">
                        values[i] = new(sql.NullInt64)</span>
                case task.FieldTitle, task.FieldDescription, task.FieldState, task.FieldPriority:<span class="cov0" title="0">
                        values[i] = new(sql.NullString)</span>
                case task.FieldCreatedAt, task.FieldUpdatedAt, task.FieldCompletedAt:<span class="cov0" title="0">
                        values[i] = new(sql.NullTime)</span>
                case task.FieldID, task.FieldProjectID:<span class="cov0" title="0">
                        values[i] = new(uuid.UUID)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov0" title="0">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Task fields.
func (_m *Task) assignValues(columns []string, values []any) error <span class="cov0" title="0">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov0" title="0">for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case task.FieldID:<span class="cov0" title="0">
                        if value, ok := values[i].(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", values[i])
                        }</span> else<span class="cov0" title="0"> if value != nil </span><span class="cov0" title="0">{
                                _m.ID = *value
                        }</span>
                case task.FieldProjectID:<span class="cov0" title="0">
                        if value, ok := values[i].(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field project_id", values[i])
                        }</span> else<span class="cov0" title="0"> if value != nil </span><span class="cov0" title="0">{
                                _m.ProjectID = *value
                        }</span>
                case task.FieldParentID:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullScanner); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field parent_id", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.ParentID = new(uuid.UUID)
                                *_m.ParentID = *value.S.(*uuid.UUID)
                        }</span>
                case task.FieldTitle:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field title", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Title = value.String
                        }</span>
                case task.FieldDescription:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field description", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Description = value.String
                        }</span>
                case task.FieldState:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field state", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.State = task.State(value.String)
                        }</span>
                case task.FieldPriority:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field priority", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Priority = task.Priority(value.String)
                        }</span>
                case task.FieldComplexity:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullInt64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field complexity", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Complexity = int(value.Int64)
                        }</span>
                case task.FieldDepth:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullInt64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field depth", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Depth = int(value.Int64)
                        }</span>
                case task.FieldEstimate:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullInt64); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field estimate", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.Estimate = new(int64)
                                *_m.Estimate = value.Int64
                        }</span>
                case task.FieldAssignedAgent:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullScanner); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field assigned_agent", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.AssignedAgent = new(uuid.UUID)
                                *_m.AssignedAgent = *value.S.(*uuid.UUID)
                        }</span>
                case task.FieldCreatedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field created_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.CreatedAt = value.Time
                        }</span>
                case task.FieldUpdatedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field updated_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.UpdatedAt = value.Time
                        }</span>
                case task.FieldCompletedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field completed_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.CompletedAt = new(time.Time)
                                *_m.CompletedAt = value.Time
                        }</span>
                default:<span class="cov0" title="0">
                        _m.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the Task.
// This includes values selected through modifiers, order, etc.
func (_m *Task) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return _m.selectValues.Get(name)
}</span>

// QueryProject queries the "project" edge of the Task entity.
func (_m *Task) QueryProject() *ProjectQuery <span class="cov0" title="0">{
        return NewTaskClient(_m.config).QueryProject(_m)
}</span>

// QueryParent queries the "parent" edge of the Task entity.
func (_m *Task) QueryParent() *TaskQuery <span class="cov0" title="0">{
        return NewTaskClient(_m.config).QueryParent(_m)
}</span>

// QueryChildren queries the "children" edge of the Task entity.
func (_m *Task) QueryChildren() *TaskQuery <span class="cov0" title="0">{
        return NewTaskClient(_m.config).QueryChildren(_m)
}</span>

// Update returns a builder for updating this Task.
// Note that you need to call Task.Unwrap() before calling this method if this Task
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Task) Update() *TaskUpdateOne <span class="cov0" title="0">{
        return NewTaskClient(_m.config).UpdateOne(_m)
}</span>

// Unwrap unwraps the Task entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Task) Unwrap() *Task <span class="cov0" title="0">{
        _tx, ok := _m.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: Task is not a transactional entity")</span>
        }
        <span class="cov0" title="0">_m.config.driver = _tx.drv
        return _m</span>
}

// String implements the fmt.Stringer.
func (_m *Task) String() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("Task(")
        builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
        builder.WriteString("project_id=")
        builder.WriteString(fmt.Sprintf("%v", _m.ProjectID))
        builder.WriteString(", ")
        if v := _m.ParentID; v != nil </span><span class="cov0" title="0">{
                builder.WriteString("parent_id=")
                builder.WriteString(fmt.Sprintf("%v", *v))
        }</span>
        <span class="cov0" title="0">builder.WriteString(", ")
        builder.WriteString("title=")
        builder.WriteString(_m.Title)
        builder.WriteString(", ")
        builder.WriteString("description=")
        builder.WriteString(_m.Description)
        builder.WriteString(", ")
        builder.WriteString("state=")
        builder.WriteString(fmt.Sprintf("%v", _m.State))
        builder.WriteString(", ")
        builder.WriteString("priority=")
        builder.WriteString(fmt.Sprintf("%v", _m.Priority))
        builder.WriteString(", ")
        builder.WriteString("complexity=")
        builder.WriteString(fmt.Sprintf("%v", _m.Complexity))
        builder.WriteString(", ")
        builder.WriteString("depth=")
        builder.WriteString(fmt.Sprintf("%v", _m.Depth))
        builder.WriteString(", ")
        if v := _m.Estimate; v != nil </span><span class="cov0" title="0">{
                builder.WriteString("estimate=")
                builder.WriteString(fmt.Sprintf("%v", *v))
        }</span>
        <span class="cov0" title="0">builder.WriteString(", ")
        if v := _m.AssignedAgent; v != nil </span><span class="cov0" title="0">{
                builder.WriteString("assigned_agent=")
                builder.WriteString(fmt.Sprintf("%v", *v))
        }</span>
        <span class="cov0" title="0">builder.WriteString(", ")
        builder.WriteString("created_at=")
        builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
        builder.WriteString(", ")
        builder.WriteString("updated_at=")
        builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
        builder.WriteString(", ")
        if v := _m.CompletedAt; v != nil </span><span class="cov0" title="0">{
                builder.WriteString("completed_at=")
                builder.WriteString(v.Format(time.ANSIC))
        }</span>
        <span class="cov0" title="0">builder.WriteByte(')')
        return builder.String()</span>
}

// Tasks is a parsable slice of Task.
type Tasks []*Task
</pre>
		
		<pre class="file" id="file58" style="display: none">// Code generated by ent, DO NOT EDIT.

package task

import (
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/google/uuid"
)

const (
        // Label holds the string label denoting the task type in the database.
        Label = "task"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldProjectID holds the string denoting the project_id field in the database.
        FieldProjectID = "project_id"
        // FieldParentID holds the string denoting the parent_id field in the database.
        FieldParentID = "parent_id"
        // FieldTitle holds the string denoting the title field in the database.
        FieldTitle = "title"
        // FieldDescription holds the string denoting the description field in the database.
        FieldDescription = "description"
        // FieldState holds the string denoting the state field in the database.
        FieldState = "state"
        // FieldPriority holds the string denoting the priority field in the database.
        FieldPriority = "priority"
        // FieldComplexity holds the string denoting the complexity field in the database.
        FieldComplexity = "complexity"
        // FieldDepth holds the string denoting the depth field in the database.
        FieldDepth = "depth"
        // FieldEstimate holds the string denoting the estimate field in the database.
        FieldEstimate = "estimate"
        // FieldAssignedAgent holds the string denoting the assigned_agent field in the database.
        FieldAssignedAgent = "assigned_agent"
        // FieldCreatedAt holds the string denoting the created_at field in the database.
        FieldCreatedAt = "created_at"
        // FieldUpdatedAt holds the string denoting the updated_at field in the database.
        FieldUpdatedAt = "updated_at"
        // FieldCompletedAt holds the string denoting the completed_at field in the database.
        FieldCompletedAt = "completed_at"
        // EdgeProject holds the string denoting the project edge name in mutations.
        EdgeProject = "project"
        // EdgeParent holds the string denoting the parent edge name in mutations.
        EdgeParent = "parent"
        // EdgeChildren holds the string denoting the children edge name in mutations.
        EdgeChildren = "children"
        // Table holds the table name of the task in the database.
        Table = "tasks"
        // ProjectTable is the table that holds the project relation/edge.
        ProjectTable = "tasks"
        // ProjectInverseTable is the table name for the Project entity.
        // It exists in this package in order to avoid circular dependency with the "project" package.
        ProjectInverseTable = "projects"
        // ProjectColumn is the table column denoting the project relation/edge.
        ProjectColumn = "project_id"
        // ParentTable is the table that holds the parent relation/edge.
        ParentTable = "tasks"
        // ParentColumn is the table column denoting the parent relation/edge.
        ParentColumn = "parent_id"
        // ChildrenTable is the table that holds the children relation/edge.
        ChildrenTable = "tasks"
        // ChildrenColumn is the table column denoting the children relation/edge.
        ChildrenColumn = "parent_id"
)

// Columns holds all SQL columns for task fields.
var Columns = []string{
        FieldID,
        FieldProjectID,
        FieldParentID,
        FieldTitle,
        FieldDescription,
        FieldState,
        FieldPriority,
        FieldComplexity,
        FieldDepth,
        FieldEstimate,
        FieldAssignedAgent,
        FieldCreatedAt,
        FieldUpdatedAt,
        FieldCompletedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var (
        // TitleValidator is a validator for the "title" field. It is called by the builders before save.
        TitleValidator func(string) error
        // ComplexityValidator is a validator for the "complexity" field. It is called by the builders before save.
        ComplexityValidator func(int) error
        // DefaultDepth holds the default value on creation for the "depth" field.
        DefaultDepth int
        // DepthValidator is a validator for the "depth" field. It is called by the builders before save.
        DepthValidator func(int) error
        // DefaultCreatedAt holds the default value on creation for the "created_at" field.
        DefaultCreatedAt func() time.Time
        // DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
        DefaultUpdatedAt func() time.Time
        // UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
        UpdateDefaultUpdatedAt func() time.Time
        // DefaultID holds the default value on creation for the "id" field.
        DefaultID func() uuid.UUID
)

// State defines the type for the "state" enum field.
type State string

// StatePending is the default value of the State enum.
const DefaultState = StatePending

// State values.
const (
        StatePending         State = "pending"
        StateInProgress      State = "in-progress"
        StateCompleted       State = "completed"
        StateBlocked         State = "blocked"
        StateCancelled       State = "cancelled"
        StateDeletionPending State = "deletion-pending"
)

func (s State) String() string <span class="cov0" title="0">{
        return string(s)
}</span>

// StateValidator is a validator for the "state" field enum values. It is called by the builders before save.
func StateValidator(s State) error <span class="cov0" title="0">{
        switch s </span>{
        case StatePending, StateInProgress, StateCompleted, StateBlocked, StateCancelled, StateDeletionPending:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("task: invalid enum value for state field: %q", s)</span>
        }
}

// Priority defines the type for the "priority" enum field.
type Priority string

// PriorityMedium is the default value of the Priority enum.
const DefaultPriority = PriorityMedium

// Priority values.
const (
        PriorityLow    Priority = "low"
        PriorityMedium Priority = "medium"
        PriorityHigh   Priority = "high"
)

func (pr Priority) String() string <span class="cov0" title="0">{
        return string(pr)
}</span>

// PriorityValidator is a validator for the "priority" field enum values. It is called by the builders before save.
func PriorityValidator(pr Priority) error <span class="cov0" title="0">{
        switch pr </span>{
        case PriorityLow, PriorityMedium, PriorityHigh:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("task: invalid enum value for priority field: %q", pr)</span>
        }
}

// OrderOption defines the ordering options for the Task queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// ByProjectID orders the results by the project_id field.
func ByProjectID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldProjectID, opts...).ToFunc()
}</span>

// ByParentID orders the results by the parent_id field.
func ByParentID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldParentID, opts...).ToFunc()
}</span>

// ByTitle orders the results by the title field.
func ByTitle(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldTitle, opts...).ToFunc()
}</span>

// ByDescription orders the results by the description field.
func ByDescription(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldDescription, opts...).ToFunc()
}</span>

// ByState orders the results by the state field.
func ByState(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldState, opts...).ToFunc()
}</span>

// ByPriority orders the results by the priority field.
func ByPriority(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldPriority, opts...).ToFunc()
}</span>

// ByComplexity orders the results by the complexity field.
func ByComplexity(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldComplexity, opts...).ToFunc()
}</span>

// ByDepth orders the results by the depth field.
func ByDepth(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldDepth, opts...).ToFunc()
}</span>

// ByEstimate orders the results by the estimate field.
func ByEstimate(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldEstimate, opts...).ToFunc()
}</span>

// ByAssignedAgent orders the results by the assigned_agent field.
func ByAssignedAgent(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldAssignedAgent, opts...).ToFunc()
}</span>

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}</span>

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}</span>

// ByCompletedAt orders the results by the completed_at field.
func ByCompletedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCompletedAt, opts...).ToFunc()
}</span>

// ByProjectField orders the results by project field.
func ByProjectField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newProjectStep(), sql.OrderByField(field, opts...))
        }</span>
}

// ByParentField orders the results by parent field.
func ByParentField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newParentStep(), sql.OrderByField(field, opts...))
        }</span>
}

// ByChildrenCount orders the results by children count.
func ByChildrenCount(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborsCount(s, newChildrenStep(), opts...)
        }</span>
}

// ByChildren orders the results by children terms.
func ByChildren(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newChildrenStep(), append([]sql.OrderTerm{term}, terms...)...)
        }</span>
}
func newProjectStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(ProjectInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, true, ProjectTable, ProjectColumn),
        )
}</span>
func newParentStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(Table, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, true, ParentTable, ParentColumn),
        )
}</span>
func newChildrenStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(Table, FieldID),
                sqlgraph.Edge(sqlgraph.O2M, false, ChildrenTable, ChildrenColumn),
        )
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">// Code generated by ent, DO NOT EDIT.

package task

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLTE(FieldID, id))
}</span>

// ProjectID applies equality check predicate on the "project_id" field. It's identical to ProjectIDEQ.
func ProjectID(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldProjectID, v))
}</span>

// ParentID applies equality check predicate on the "parent_id" field. It's identical to ParentIDEQ.
func ParentID(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldParentID, v))
}</span>

// Title applies equality check predicate on the "title" field. It's identical to TitleEQ.
func Title(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldTitle, v))
}</span>

// Description applies equality check predicate on the "description" field. It's identical to DescriptionEQ.
func Description(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldDescription, v))
}</span>

// Complexity applies equality check predicate on the "complexity" field. It's identical to ComplexityEQ.
func Complexity(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldComplexity, v))
}</span>

// Depth applies equality check predicate on the "depth" field. It's identical to DepthEQ.
func Depth(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldDepth, v))
}</span>

// Estimate applies equality check predicate on the "estimate" field. It's identical to EstimateEQ.
func Estimate(v int64) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldEstimate, v))
}</span>

// AssignedAgent applies equality check predicate on the "assigned_agent" field. It's identical to AssignedAgentEQ.
func AssignedAgent(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldAssignedAgent, v))
}</span>

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// CompletedAt applies equality check predicate on the "completed_at" field. It's identical to CompletedAtEQ.
func CompletedAt(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldCompletedAt, v))
}</span>

// ProjectIDEQ applies the EQ predicate on the "project_id" field.
func ProjectIDEQ(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldProjectID, v))
}</span>

// ProjectIDNEQ applies the NEQ predicate on the "project_id" field.
func ProjectIDNEQ(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldProjectID, v))
}</span>

// ProjectIDIn applies the In predicate on the "project_id" field.
func ProjectIDIn(vs ...uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldProjectID, vs...))
}</span>

// ProjectIDNotIn applies the NotIn predicate on the "project_id" field.
func ProjectIDNotIn(vs ...uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldProjectID, vs...))
}</span>

// ParentIDEQ applies the EQ predicate on the "parent_id" field.
func ParentIDEQ(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldParentID, v))
}</span>

// ParentIDNEQ applies the NEQ predicate on the "parent_id" field.
func ParentIDNEQ(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldParentID, v))
}</span>

// ParentIDIn applies the In predicate on the "parent_id" field.
func ParentIDIn(vs ...uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldParentID, vs...))
}</span>

// ParentIDNotIn applies the NotIn predicate on the "parent_id" field.
func ParentIDNotIn(vs ...uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldParentID, vs...))
}</span>

// ParentIDIsNil applies the IsNil predicate on the "parent_id" field.
func ParentIDIsNil() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIsNull(FieldParentID))
}</span>

// ParentIDNotNil applies the NotNil predicate on the "parent_id" field.
func ParentIDNotNil() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotNull(FieldParentID))
}</span>

// TitleEQ applies the EQ predicate on the "title" field.
func TitleEQ(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldTitle, v))
}</span>

// TitleNEQ applies the NEQ predicate on the "title" field.
func TitleNEQ(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldTitle, v))
}</span>

// TitleIn applies the In predicate on the "title" field.
func TitleIn(vs ...string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldTitle, vs...))
}</span>

// TitleNotIn applies the NotIn predicate on the "title" field.
func TitleNotIn(vs ...string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldTitle, vs...))
}</span>

// TitleGT applies the GT predicate on the "title" field.
func TitleGT(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGT(FieldTitle, v))
}</span>

// TitleGTE applies the GTE predicate on the "title" field.
func TitleGTE(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGTE(FieldTitle, v))
}</span>

// TitleLT applies the LT predicate on the "title" field.
func TitleLT(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLT(FieldTitle, v))
}</span>

// TitleLTE applies the LTE predicate on the "title" field.
func TitleLTE(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLTE(FieldTitle, v))
}</span>

// TitleContains applies the Contains predicate on the "title" field.
func TitleContains(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldContains(FieldTitle, v))
}</span>

// TitleHasPrefix applies the HasPrefix predicate on the "title" field.
func TitleHasPrefix(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldHasPrefix(FieldTitle, v))
}</span>

// TitleHasSuffix applies the HasSuffix predicate on the "title" field.
func TitleHasSuffix(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldHasSuffix(FieldTitle, v))
}</span>

// TitleEqualFold applies the EqualFold predicate on the "title" field.
func TitleEqualFold(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEqualFold(FieldTitle, v))
}</span>

// TitleContainsFold applies the ContainsFold predicate on the "title" field.
func TitleContainsFold(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldContainsFold(FieldTitle, v))
}</span>

// DescriptionEQ applies the EQ predicate on the "description" field.
func DescriptionEQ(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldDescription, v))
}</span>

// DescriptionNEQ applies the NEQ predicate on the "description" field.
func DescriptionNEQ(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldDescription, v))
}</span>

// DescriptionIn applies the In predicate on the "description" field.
func DescriptionIn(vs ...string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldDescription, vs...))
}</span>

// DescriptionNotIn applies the NotIn predicate on the "description" field.
func DescriptionNotIn(vs ...string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldDescription, vs...))
}</span>

// DescriptionGT applies the GT predicate on the "description" field.
func DescriptionGT(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGT(FieldDescription, v))
}</span>

// DescriptionGTE applies the GTE predicate on the "description" field.
func DescriptionGTE(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGTE(FieldDescription, v))
}</span>

// DescriptionLT applies the LT predicate on the "description" field.
func DescriptionLT(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLT(FieldDescription, v))
}</span>

// DescriptionLTE applies the LTE predicate on the "description" field.
func DescriptionLTE(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLTE(FieldDescription, v))
}</span>

// DescriptionContains applies the Contains predicate on the "description" field.
func DescriptionContains(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldContains(FieldDescription, v))
}</span>

// DescriptionHasPrefix applies the HasPrefix predicate on the "description" field.
func DescriptionHasPrefix(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldHasPrefix(FieldDescription, v))
}</span>

// DescriptionHasSuffix applies the HasSuffix predicate on the "description" field.
func DescriptionHasSuffix(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldHasSuffix(FieldDescription, v))
}</span>

// DescriptionIsNil applies the IsNil predicate on the "description" field.
func DescriptionIsNil() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIsNull(FieldDescription))
}</span>

// DescriptionNotNil applies the NotNil predicate on the "description" field.
func DescriptionNotNil() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotNull(FieldDescription))
}</span>

// DescriptionEqualFold applies the EqualFold predicate on the "description" field.
func DescriptionEqualFold(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEqualFold(FieldDescription, v))
}</span>

// DescriptionContainsFold applies the ContainsFold predicate on the "description" field.
func DescriptionContainsFold(v string) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldContainsFold(FieldDescription, v))
}</span>

// StateEQ applies the EQ predicate on the "state" field.
func StateEQ(v State) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldState, v))
}</span>

// StateNEQ applies the NEQ predicate on the "state" field.
func StateNEQ(v State) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldState, v))
}</span>

// StateIn applies the In predicate on the "state" field.
func StateIn(vs ...State) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldState, vs...))
}</span>

// StateNotIn applies the NotIn predicate on the "state" field.
func StateNotIn(vs ...State) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldState, vs...))
}</span>

// PriorityEQ applies the EQ predicate on the "priority" field.
func PriorityEQ(v Priority) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldPriority, v))
}</span>

// PriorityNEQ applies the NEQ predicate on the "priority" field.
func PriorityNEQ(v Priority) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldPriority, v))
}</span>

// PriorityIn applies the In predicate on the "priority" field.
func PriorityIn(vs ...Priority) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldPriority, vs...))
}</span>

// PriorityNotIn applies the NotIn predicate on the "priority" field.
func PriorityNotIn(vs ...Priority) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldPriority, vs...))
}</span>

// ComplexityEQ applies the EQ predicate on the "complexity" field.
func ComplexityEQ(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldComplexity, v))
}</span>

// ComplexityNEQ applies the NEQ predicate on the "complexity" field.
func ComplexityNEQ(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldComplexity, v))
}</span>

// ComplexityIn applies the In predicate on the "complexity" field.
func ComplexityIn(vs ...int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldComplexity, vs...))
}</span>

// ComplexityNotIn applies the NotIn predicate on the "complexity" field.
func ComplexityNotIn(vs ...int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldComplexity, vs...))
}</span>

// ComplexityGT applies the GT predicate on the "complexity" field.
func ComplexityGT(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGT(FieldComplexity, v))
}</span>

// ComplexityGTE applies the GTE predicate on the "complexity" field.
func ComplexityGTE(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGTE(FieldComplexity, v))
}</span>

// ComplexityLT applies the LT predicate on the "complexity" field.
func ComplexityLT(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLT(FieldComplexity, v))
}</span>

// ComplexityLTE applies the LTE predicate on the "complexity" field.
func ComplexityLTE(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLTE(FieldComplexity, v))
}</span>

// DepthEQ applies the EQ predicate on the "depth" field.
func DepthEQ(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldDepth, v))
}</span>

// DepthNEQ applies the NEQ predicate on the "depth" field.
func DepthNEQ(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldDepth, v))
}</span>

// DepthIn applies the In predicate on the "depth" field.
func DepthIn(vs ...int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldDepth, vs...))
}</span>

// DepthNotIn applies the NotIn predicate on the "depth" field.
func DepthNotIn(vs ...int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldDepth, vs...))
}</span>

// DepthGT applies the GT predicate on the "depth" field.
func DepthGT(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGT(FieldDepth, v))
}</span>

// DepthGTE applies the GTE predicate on the "depth" field.
func DepthGTE(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGTE(FieldDepth, v))
}</span>

// DepthLT applies the LT predicate on the "depth" field.
func DepthLT(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLT(FieldDepth, v))
}</span>

// DepthLTE applies the LTE predicate on the "depth" field.
func DepthLTE(v int) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLTE(FieldDepth, v))
}</span>

// EstimateEQ applies the EQ predicate on the "estimate" field.
func EstimateEQ(v int64) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldEstimate, v))
}</span>

// EstimateNEQ applies the NEQ predicate on the "estimate" field.
func EstimateNEQ(v int64) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldEstimate, v))
}</span>

// EstimateIn applies the In predicate on the "estimate" field.
func EstimateIn(vs ...int64) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldEstimate, vs...))
}</span>

// EstimateNotIn applies the NotIn predicate on the "estimate" field.
func EstimateNotIn(vs ...int64) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldEstimate, vs...))
}</span>

// EstimateGT applies the GT predicate on the "estimate" field.
func EstimateGT(v int64) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGT(FieldEstimate, v))
}</span>

// EstimateGTE applies the GTE predicate on the "estimate" field.
func EstimateGTE(v int64) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGTE(FieldEstimate, v))
}</span>

// EstimateLT applies the LT predicate on the "estimate" field.
func EstimateLT(v int64) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLT(FieldEstimate, v))
}</span>

// EstimateLTE applies the LTE predicate on the "estimate" field.
func EstimateLTE(v int64) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLTE(FieldEstimate, v))
}</span>

// EstimateIsNil applies the IsNil predicate on the "estimate" field.
func EstimateIsNil() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIsNull(FieldEstimate))
}</span>

// EstimateNotNil applies the NotNil predicate on the "estimate" field.
func EstimateNotNil() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotNull(FieldEstimate))
}</span>

// AssignedAgentEQ applies the EQ predicate on the "assigned_agent" field.
func AssignedAgentEQ(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldAssignedAgent, v))
}</span>

// AssignedAgentNEQ applies the NEQ predicate on the "assigned_agent" field.
func AssignedAgentNEQ(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldAssignedAgent, v))
}</span>

// AssignedAgentIn applies the In predicate on the "assigned_agent" field.
func AssignedAgentIn(vs ...uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldAssignedAgent, vs...))
}</span>

// AssignedAgentNotIn applies the NotIn predicate on the "assigned_agent" field.
func AssignedAgentNotIn(vs ...uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldAssignedAgent, vs...))
}</span>

// AssignedAgentGT applies the GT predicate on the "assigned_agent" field.
func AssignedAgentGT(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGT(FieldAssignedAgent, v))
}</span>

// AssignedAgentGTE applies the GTE predicate on the "assigned_agent" field.
func AssignedAgentGTE(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGTE(FieldAssignedAgent, v))
}</span>

// AssignedAgentLT applies the LT predicate on the "assigned_agent" field.
func AssignedAgentLT(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLT(FieldAssignedAgent, v))
}</span>

// AssignedAgentLTE applies the LTE predicate on the "assigned_agent" field.
func AssignedAgentLTE(v uuid.UUID) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLTE(FieldAssignedAgent, v))
}</span>

// AssignedAgentIsNil applies the IsNil predicate on the "assigned_agent" field.
func AssignedAgentIsNil() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIsNull(FieldAssignedAgent))
}</span>

// AssignedAgentNotNil applies the NotNil predicate on the "assigned_agent" field.
func AssignedAgentNotNil() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotNull(FieldAssignedAgent))
}</span>

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldCreatedAt, v))
}</span>

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGT(FieldCreatedAt, v))
}</span>

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGTE(FieldCreatedAt, v))
}</span>

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLT(FieldCreatedAt, v))
}</span>

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLTE(FieldCreatedAt, v))
}</span>

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGT(FieldUpdatedAt, v))
}</span>

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGTE(FieldUpdatedAt, v))
}</span>

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLT(FieldUpdatedAt, v))
}</span>

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLTE(FieldUpdatedAt, v))
}</span>

// CompletedAtEQ applies the EQ predicate on the "completed_at" field.
func CompletedAtEQ(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldEQ(FieldCompletedAt, v))
}</span>

// CompletedAtNEQ applies the NEQ predicate on the "completed_at" field.
func CompletedAtNEQ(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNEQ(FieldCompletedAt, v))
}</span>

// CompletedAtIn applies the In predicate on the "completed_at" field.
func CompletedAtIn(vs ...time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIn(FieldCompletedAt, vs...))
}</span>

// CompletedAtNotIn applies the NotIn predicate on the "completed_at" field.
func CompletedAtNotIn(vs ...time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotIn(FieldCompletedAt, vs...))
}</span>

// CompletedAtGT applies the GT predicate on the "completed_at" field.
func CompletedAtGT(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGT(FieldCompletedAt, v))
}</span>

// CompletedAtGTE applies the GTE predicate on the "completed_at" field.
func CompletedAtGTE(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldGTE(FieldCompletedAt, v))
}</span>

// CompletedAtLT applies the LT predicate on the "completed_at" field.
func CompletedAtLT(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLT(FieldCompletedAt, v))
}</span>

// CompletedAtLTE applies the LTE predicate on the "completed_at" field.
func CompletedAtLTE(v time.Time) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldLTE(FieldCompletedAt, v))
}</span>

// CompletedAtIsNil applies the IsNil predicate on the "completed_at" field.
func CompletedAtIsNil() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldIsNull(FieldCompletedAt))
}</span>

// CompletedAtNotNil applies the NotNil predicate on the "completed_at" field.
func CompletedAtNotNil() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.FieldNotNull(FieldCompletedAt))
}</span>

// HasProject applies the HasEdge predicate on the "project" edge.
func HasProject() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, ProjectTable, ProjectColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasProjectWith applies the HasEdge predicate on the "project" edge with a given conditions (other predicates).
func HasProjectWith(preds ...predicate.Project) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newProjectStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// HasParent applies the HasEdge predicate on the "parent" edge.
func HasParent() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, ParentTable, ParentColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasParentWith applies the HasEdge predicate on the "parent" edge with a given conditions (other predicates).
func HasParentWith(preds ...predicate.Task) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newParentStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// HasChildren applies the HasEdge predicate on the "children" edge.
func HasChildren() predicate.Task <span class="cov0" title="0">{
        return predicate.Task(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, ChildrenTable, ChildrenColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasChildrenWith applies the HasEdge predicate on the "children" edge with a given conditions (other predicates).
func HasChildrenWith(preds ...predicate.Task) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newChildrenStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Task) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Task) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.Task) predicate.Task <span class="cov0" title="0">{
        return predicate.Task(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/google/uuid"
)

// TaskCreate is the builder for creating a Task entity.
type TaskCreate struct {
        config
        mutation *TaskMutation
        hooks    []Hook
}

// SetProjectID sets the "project_id" field.
func (_c *TaskCreate) SetProjectID(v uuid.UUID) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetProjectID(v)
        return _c
}</span>

// SetParentID sets the "parent_id" field.
func (_c *TaskCreate) SetParentID(v uuid.UUID) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetParentID(v)
        return _c
}</span>

// SetNillableParentID sets the "parent_id" field if the given value is not nil.
func (_c *TaskCreate) SetNillableParentID(v *uuid.UUID) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetParentID(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetTitle sets the "title" field.
func (_c *TaskCreate) SetTitle(v string) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetTitle(v)
        return _c
}</span>

// SetDescription sets the "description" field.
func (_c *TaskCreate) SetDescription(v string) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetDescription(v)
        return _c
}</span>

// SetNillableDescription sets the "description" field if the given value is not nil.
func (_c *TaskCreate) SetNillableDescription(v *string) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetDescription(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetState sets the "state" field.
func (_c *TaskCreate) SetState(v task.State) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetState(v)
        return _c
}</span>

// SetNillableState sets the "state" field if the given value is not nil.
func (_c *TaskCreate) SetNillableState(v *task.State) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetState(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetPriority sets the "priority" field.
func (_c *TaskCreate) SetPriority(v task.Priority) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetPriority(v)
        return _c
}</span>

// SetNillablePriority sets the "priority" field if the given value is not nil.
func (_c *TaskCreate) SetNillablePriority(v *task.Priority) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetPriority(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetComplexity sets the "complexity" field.
func (_c *TaskCreate) SetComplexity(v int) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetComplexity(v)
        return _c
}</span>

// SetDepth sets the "depth" field.
func (_c *TaskCreate) SetDepth(v int) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetDepth(v)
        return _c
}</span>

// SetNillableDepth sets the "depth" field if the given value is not nil.
func (_c *TaskCreate) SetNillableDepth(v *int) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetDepth(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetEstimate sets the "estimate" field.
func (_c *TaskCreate) SetEstimate(v int64) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetEstimate(v)
        return _c
}</span>

// SetNillableEstimate sets the "estimate" field if the given value is not nil.
func (_c *TaskCreate) SetNillableEstimate(v *int64) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetEstimate(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetAssignedAgent sets the "assigned_agent" field.
func (_c *TaskCreate) SetAssignedAgent(v uuid.UUID) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetAssignedAgent(v)
        return _c
}</span>

// SetNillableAssignedAgent sets the "assigned_agent" field if the given value is not nil.
func (_c *TaskCreate) SetNillableAssignedAgent(v *uuid.UUID) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetAssignedAgent(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetCreatedAt sets the "created_at" field.
func (_c *TaskCreate) SetCreatedAt(v time.Time) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetCreatedAt(v)
        return _c
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_c *TaskCreate) SetNillableCreatedAt(v *time.Time) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetCreatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (_c *TaskCreate) SetUpdatedAt(v time.Time) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetUpdatedAt(v)
        return _c
}</span>

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (_c *TaskCreate) SetNillableUpdatedAt(v *time.Time) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetUpdatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetCompletedAt sets the "completed_at" field.
func (_c *TaskCreate) SetCompletedAt(v time.Time) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetCompletedAt(v)
        return _c
}</span>

// SetNillableCompletedAt sets the "completed_at" field if the given value is not nil.
func (_c *TaskCreate) SetNillableCompletedAt(v *time.Time) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetCompletedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetID sets the "id" field.
func (_c *TaskCreate) SetID(v uuid.UUID) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.SetID(v)
        return _c
}</span>

// SetNillableID sets the "id" field if the given value is not nil.
func (_c *TaskCreate) SetNillableID(v *uuid.UUID) *TaskCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetID(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetProject sets the "project" edge to the Project entity.
func (_c *TaskCreate) SetProject(v *Project) *TaskCreate <span class="cov0" title="0">{
        return _c.SetProjectID(v.ID)
}</span>

// SetParent sets the "parent" edge to the Task entity.
func (_c *TaskCreate) SetParent(v *Task) *TaskCreate <span class="cov0" title="0">{
        return _c.SetParentID(v.ID)
}</span>

// AddChildIDs adds the "children" edge to the Task entity by IDs.
func (_c *TaskCreate) AddChildIDs(ids ...uuid.UUID) *TaskCreate <span class="cov0" title="0">{
        _c.mutation.AddChildIDs(ids...)
        return _c
}</span>

// AddChildren adds the "children" edges to the Task entity.
func (_c *TaskCreate) AddChildren(v ...*Task) *TaskCreate <span class="cov0" title="0">{
        ids := make([]uuid.UUID, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _c.AddChildIDs(ids...)</span>
}

// Mutation returns the TaskMutation object of the builder.
func (_c *TaskCreate) Mutation() *TaskMutation <span class="cov0" title="0">{
        return _c.mutation
}</span>

// Save creates the Task in the database.
func (_c *TaskCreate) Save(ctx context.Context) (*Task, error) <span class="cov0" title="0">{
        _c.defaults()
        return withHooks(ctx, _c.sqlSave, _c.mutation, _c.hooks)
}</span>

// SaveX calls Save and panics if Save returns an error.
func (_c *TaskCreate) SaveX(ctx context.Context) *Task <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *TaskCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *TaskCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_c *TaskCreate) defaults() <span class="cov0" title="0">{
        if _, ok := _c.mutation.State(); !ok </span><span class="cov0" title="0">{
                v := task.DefaultState
                _c.mutation.SetState(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.Priority(); !ok </span><span class="cov0" title="0">{
                v := task.DefaultPriority
                _c.mutation.SetPriority(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.Depth(); !ok </span><span class="cov0" title="0">{
                v := task.DefaultDepth
                _c.mutation.SetDepth(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                v := task.DefaultCreatedAt()
                _c.mutation.SetCreatedAt(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                v := task.DefaultUpdatedAt()
                _c.mutation.SetUpdatedAt(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.ID(); !ok </span><span class="cov0" title="0">{
                v := task.DefaultID()
                _c.mutation.SetID(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_c *TaskCreate) check() error <span class="cov0" title="0">{
        if _, ok := _c.mutation.ProjectID(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "project_id", err: errors.New(`ent: missing required field "Task.project_id"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.Title(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "title", err: errors.New(`ent: missing required field "Task.title"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.Title(); ok </span><span class="cov0" title="0">{
                if err := task.TitleValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "Task.title": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.State(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "state", err: errors.New(`ent: missing required field "Task.state"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.State(); ok </span><span class="cov0" title="0">{
                if err := task.StateValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "state", err: fmt.Errorf(`ent: validator failed for field "Task.state": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.Priority(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "priority", err: errors.New(`ent: missing required field "Task.priority"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.Priority(); ok </span><span class="cov0" title="0">{
                if err := task.PriorityValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "priority", err: fmt.Errorf(`ent: validator failed for field "Task.priority": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.Complexity(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "complexity", err: errors.New(`ent: missing required field "Task.complexity"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.Complexity(); ok </span><span class="cov0" title="0">{
                if err := task.ComplexityValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "complexity", err: fmt.Errorf(`ent: validator failed for field "Task.complexity": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.Depth(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "depth", err: errors.New(`ent: missing required field "Task.depth"`)}
        }</span>
        <span class="cov0" title="0">if v, ok := _c.mutation.Depth(); ok </span><span class="cov0" title="0">{
                if err := task.DepthValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "depth", err: fmt.Errorf(`ent: validator failed for field "Task.depth": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "Task.created_at"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "updated_at", err: errors.New(`ent: missing required field "Task.updated_at"`)}
        }</span>
        <span class="cov0" title="0">if len(_c.mutation.ProjectIDs()) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "project", err: errors.New(`ent: missing required edge "Task.project"`)}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_c *TaskCreate) sqlSave(ctx context.Context) (*Task, error) <span class="cov0" title="0">{
        if err := _c.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_node, _spec := _c.createSpec()
        if err := sqlgraph.CreateNode(ctx, _c.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if _spec.ID.Value != nil </span><span class="cov0" title="0">{
                if id, ok := _spec.ID.Value.(*uuid.UUID); ok </span><span class="cov0" title="0">{
                        _node.ID = *id
                }</span> else<span class="cov0" title="0"> if err := _node.ID.Scan(_spec.ID.Value); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">_c.mutation.id = &amp;_node.ID
        _c.mutation.done = true
        return _node, nil</span>
}

func (_c *TaskCreate) createSpec() (*Task, *sqlgraph.CreateSpec) <span class="cov0" title="0">{
        var (
                _node = &amp;Task{config: _c.config}
                _spec = sqlgraph.NewCreateSpec(task.Table, sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID))
        )
        if id, ok := _c.mutation.ID(); ok </span><span class="cov0" title="0">{
                _node.ID = id
                _spec.ID.Value = &amp;id
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Title(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldTitle, field.TypeString, value)
                _node.Title = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Description(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldDescription, field.TypeString, value)
                _node.Description = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.State(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldState, field.TypeEnum, value)
                _node.State = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Priority(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldPriority, field.TypeEnum, value)
                _node.Priority = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Complexity(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldComplexity, field.TypeInt, value)
                _node.Complexity = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Depth(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldDepth, field.TypeInt, value)
                _node.Depth = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.Estimate(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldEstimate, field.TypeInt64, value)
                _node.Estimate = &amp;value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.AssignedAgent(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldAssignedAgent, field.TypeUUID, value)
                _node.AssignedAgent = &amp;value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldCreatedAt, field.TypeTime, value)
                _node.CreatedAt = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldUpdatedAt, field.TypeTime, value)
                _node.UpdatedAt = value
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.CompletedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldCompletedAt, field.TypeTime, value)
                _node.CompletedAt = &amp;value
        }</span>
        <span class="cov0" title="0">if nodes := _c.mutation.ProjectIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   task.ProjectTable,
                        Columns: []string{task.ProjectColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_node.ProjectID = nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _c.mutation.ParentIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   task.ParentTable,
                        Columns: []string{task.ParentColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_node.ParentID = &amp;nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _c.mutation.ChildrenIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   task.ChildrenTable,
                        Columns: []string{task.ChildrenColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">return _node, _spec</span>
}

// TaskCreateBulk is the builder for creating many Task entities in bulk.
type TaskCreateBulk struct {
        config
        err      error
        builders []*TaskCreate
}

// Save creates the Task entities in the database.
func (_c *TaskCreateBulk) Save(ctx context.Context) ([]*Task, error) <span class="cov0" title="0">{
        if _c.err != nil </span><span class="cov0" title="0">{
                return nil, _c.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(_c.builders))
        nodes := make([]*Task, len(_c.builders))
        mutators := make([]Mutator, len(_c.builders))
        for i := range _c.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := _c.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*TaskMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, _c.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, _c.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, _c.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (_c *TaskCreateBulk) SaveX(ctx context.Context) []*Task <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *TaskCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *TaskCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file61" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
)

// TaskDelete is the builder for deleting a Task entity.
type TaskDelete struct {
        config
        hooks    []Hook
        mutation *TaskMutation
}

// Where appends a list predicates to the TaskDelete builder.
func (_d *TaskDelete) Where(ps ...predicate.Task) *TaskDelete <span class="cov0" title="0">{
        _d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (_d *TaskDelete) Exec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _d.sqlExec, _d.mutation, _d.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_d *TaskDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := _d.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (_d *TaskDelete) sqlExec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := sqlgraph.NewDeleteSpec(task.Table, sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID))
        if ps := _d.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">affected, err := sqlgraph.DeleteNodes(ctx, _d.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov0" title="0">_d.mutation.done = true
        return affected, err</span>
}

// TaskDeleteOne is the builder for deleting a single Task entity.
type TaskDeleteOne struct {
        _d *TaskDelete
}

// Where appends a list predicates to the TaskDelete builder.
func (_d *TaskDeleteOne) Where(ps ...predicate.Task) *TaskDeleteOne <span class="cov0" title="0">{
        _d._d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query.
func (_d *TaskDeleteOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        n, err := _d._d.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov0" title="0">
                return &amp;NotFoundError{task.Label}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (_d *TaskDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _d.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "database/sql/driver"
        "fmt"
        "math"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/google/uuid"
)

// TaskQuery is the builder for querying Task entities.
type TaskQuery struct {
        config
        ctx          *QueryContext
        order        []task.OrderOption
        inters       []Interceptor
        predicates   []predicate.Task
        withProject  *ProjectQuery
        withParent   *TaskQuery
        withChildren *TaskQuery
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the TaskQuery builder.
func (_q *TaskQuery) Where(ps ...predicate.Task) *TaskQuery <span class="cov0" title="0">{
        _q.predicates = append(_q.predicates, ps...)
        return _q
}</span>

// Limit the number of records to be returned by this query.
func (_q *TaskQuery) Limit(limit int) *TaskQuery <span class="cov0" title="0">{
        _q.ctx.Limit = &amp;limit
        return _q
}</span>

// Offset to start from.
func (_q *TaskQuery) Offset(offset int) *TaskQuery <span class="cov0" title="0">{
        _q.ctx.Offset = &amp;offset
        return _q
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (_q *TaskQuery) Unique(unique bool) *TaskQuery <span class="cov0" title="0">{
        _q.ctx.Unique = &amp;unique
        return _q
}</span>

// Order specifies how the records should be ordered.
func (_q *TaskQuery) Order(o ...task.OrderOption) *TaskQuery <span class="cov0" title="0">{
        _q.order = append(_q.order, o...)
        return _q
}</span>

// QueryProject chains the current query on the "project" edge.
func (_q *TaskQuery) QueryProject() *ProjectQuery <span class="cov0" title="0">{
        query := (&amp;ProjectClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(task.Table, task.FieldID, selector),
                        sqlgraph.To(project.Table, project.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, task.ProjectTable, task.ProjectColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// QueryParent chains the current query on the "parent" edge.
func (_q *TaskQuery) QueryParent() *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(task.Table, task.FieldID, selector),
                        sqlgraph.To(task.Table, task.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, task.ParentTable, task.ParentColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// QueryChildren chains the current query on the "children" edge.
func (_q *TaskQuery) QueryChildren() *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(task.Table, task.FieldID, selector),
                        sqlgraph.To(task.Table, task.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, task.ChildrenTable, task.ChildrenColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first Task entity from the query.
// Returns a *NotFoundError when no Task was found.
func (_q *TaskQuery) First(ctx context.Context) (*Task, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(1).All(setContextOp(ctx, _q.ctx, ent.OpQueryFirst))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{task.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (_q *TaskQuery) FirstX(ctx context.Context) *Task <span class="cov0" title="0">{
        node, err := _q.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first Task ID from the query.
// Returns a *NotFoundError when no Task ID was found.
func (_q *TaskQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) <span class="cov0" title="0">{
        var ids []uuid.UUID
        if ids, err = _q.Limit(1).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryFirstID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{task.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (_q *TaskQuery) FirstIDX(ctx context.Context) uuid.UUID <span class="cov0" title="0">{
        id, err := _q.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single Task entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Task entity is found.
// Returns a *NotFoundError when no Task entities are found.
func (_q *TaskQuery) Only(ctx context.Context) (*Task, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(2).All(setContextOp(ctx, _q.ctx, ent.OpQueryOnly))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch len(nodes) </span>{
        case 1:<span class="cov0" title="0">
                return nodes[0], nil</span>
        case 0:<span class="cov0" title="0">
                return nil, &amp;NotFoundError{task.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{task.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (_q *TaskQuery) OnlyX(ctx context.Context) *Task <span class="cov0" title="0">{
        node, err := _q.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only Task ID in the query.
// Returns a *NotSingularError when more than one Task ID is found.
// Returns a *NotFoundError when no entities are found.
func (_q *TaskQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) <span class="cov0" title="0">{
        var ids []uuid.UUID
        if ids, err = _q.Limit(2).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryOnlyID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{task.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{task.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (_q *TaskQuery) OnlyIDX(ctx context.Context) uuid.UUID <span class="cov0" title="0">{
        id, err := _q.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of Tasks.
func (_q *TaskQuery) All(ctx context.Context) ([]*Task, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryAll)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">qr := querierAll[[]*Task, *TaskQuery]()
        return withInterceptors[[]*Task](ctx, _q, qr, _q.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (_q *TaskQuery) AllX(ctx context.Context) []*Task <span class="cov0" title="0">{
        nodes, err := _q.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of Task IDs.
func (_q *TaskQuery) IDs(ctx context.Context) (ids []uuid.UUID, err error) <span class="cov0" title="0">{
        if _q.ctx.Unique == nil &amp;&amp; _q.path != nil </span><span class="cov0" title="0">{
                _q.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, _q.ctx, ent.OpQueryIDs)
        if err = _q.Select(task.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (_q *TaskQuery) IDsX(ctx context.Context) []uuid.UUID <span class="cov0" title="0">{
        ids, err := _q.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (_q *TaskQuery) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryCount)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return withInterceptors[int](ctx, _q, querierCount[*TaskQuery](), _q.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (_q *TaskQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := _q.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (_q *TaskQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryExist)
        switch _, err := _q.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (_q *TaskQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := _q.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the TaskQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (_q *TaskQuery) Clone() *TaskQuery <span class="cov0" title="0">{
        if _q == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;TaskQuery{
                config:       _q.config,
                ctx:          _q.ctx.Clone(),
                order:        append([]task.OrderOption{}, _q.order...),
                inters:       append([]Interceptor{}, _q.inters...),
                predicates:   append([]predicate.Task{}, _q.predicates...),
                withProject:  _q.withProject.Clone(),
                withParent:   _q.withParent.Clone(),
                withChildren: _q.withChildren.Clone(),
                // clone intermediate query.
                sql:  _q.sql.Clone(),
                path: _q.path,
        }</span>
}

// WithProject tells the query-builder to eager-load the nodes that are connected to
// the "project" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TaskQuery) WithProject(opts ...func(*ProjectQuery)) *TaskQuery <span class="cov0" title="0">{
        query := (&amp;ProjectClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withProject = query
        return _q</span>
}

// WithParent tells the query-builder to eager-load the nodes that are connected to
// the "parent" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TaskQuery) WithParent(opts ...func(*TaskQuery)) *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withParent = query
        return _q</span>
}

// WithChildren tells the query-builder to eager-load the nodes that are connected to
// the "children" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TaskQuery) WithChildren(opts ...func(*TaskQuery)) *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withChildren = query
        return _q</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                ProjectID uuid.UUID `json:"project_id,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.Task.Query().
//                GroupBy(task.FieldProjectID).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (_q *TaskQuery) GroupBy(field string, fields ...string) *TaskGroupBy <span class="cov0" title="0">{
        _q.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;TaskGroupBy{build: _q}
        grbuild.flds = &amp;_q.ctx.Fields
        grbuild.label = task.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                ProjectID uuid.UUID `json:"project_id,omitempty"`
//        }
//
//        client.Task.Query().
//                Select(task.FieldProjectID).
//                Scan(ctx, &amp;v)
func (_q *TaskQuery) Select(fields ...string) *TaskSelect <span class="cov0" title="0">{
        _q.ctx.Fields = append(_q.ctx.Fields, fields...)
        sbuild := &amp;TaskSelect{TaskQuery: _q}
        sbuild.label = task.Label
        sbuild.flds, sbuild.scan = &amp;_q.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a TaskSelect configured with the given aggregations.
func (_q *TaskQuery) Aggregate(fns ...AggregateFunc) *TaskSelect <span class="cov0" title="0">{
        return _q.Select().Aggregate(fns...)
}</span>

func (_q *TaskQuery) prepareQuery(ctx context.Context) error <span class="cov0" title="0">{
        for _, inter := range _q.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, _q); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, f := range _q.ctx.Fields </span><span class="cov0" title="0">{
                if !task.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov0" title="0">if _q.path != nil </span><span class="cov0" title="0">{
                prev, err := _q.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_q.sql = prev</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *TaskQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Task, error) <span class="cov0" title="0">{
        var (
                nodes       = []*Task{}
                _spec       = _q.querySpec()
                loadedTypes = [3]bool{
                        _q.withProject != nil,
                        _q.withParent != nil,
                        _q.withChildren != nil,
                }
        )
        _spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov0" title="0">{
                return (*Task).scanValues(nil, columns)
        }</span>
        <span class="cov0" title="0">_spec.Assign = func(columns []string, values []any) error </span><span class="cov0" title="0">{
                node := &amp;Task{config: _q.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov0" title="0">for i := range hooks </span><span class="cov0" title="0">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov0" title="0">if err := sqlgraph.QueryNodes(ctx, _q.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nodes, nil
        }</span>
        <span class="cov0" title="0">if query := _q.withProject; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadProject(ctx, query, nodes, nil,
                        func(n *Task, e *Project) </span><span class="cov0" title="0">{ n.Edges.Project = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if query := _q.withParent; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadParent(ctx, query, nodes, nil,
                        func(n *Task, e *Task) </span><span class="cov0" title="0">{ n.Edges.Parent = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if query := _q.withChildren; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadChildren(ctx, query, nodes,
                        func(n *Task) </span><span class="cov0" title="0">{ n.Edges.Children = []*Task{} }</span>,
                        func(n *Task, e *Task) <span class="cov0" title="0">{ n.Edges.Children = append(n.Edges.Children, e) }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

func (_q *TaskQuery) loadProject(ctx context.Context, query *ProjectQuery, nodes []*Task, init func(*Task), assign func(*Task, *Project)) error <span class="cov0" title="0">{
        ids := make([]uuid.UUID, 0, len(nodes))
        nodeids := make(map[uuid.UUID][]*Task)
        for i := range nodes </span><span class="cov0" title="0">{
                fk := nodes[i].ProjectID
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(project.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "project_id" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (_q *TaskQuery) loadParent(ctx context.Context, query *TaskQuery, nodes []*Task, init func(*Task), assign func(*Task, *Task)) error <span class="cov0" title="0">{
        ids := make([]uuid.UUID, 0, len(nodes))
        nodeids := make(map[uuid.UUID][]*Task)
        for i := range nodes </span><span class="cov0" title="0">{
                if nodes[i].ParentID == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fk := *nodes[i].ParentID
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(task.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "parent_id" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (_q *TaskQuery) loadChildren(ctx context.Context, query *TaskQuery, nodes []*Task, init func(*Task), assign func(*Task, *Task)) error <span class="cov0" title="0">{
        fks := make([]driver.Value, 0, len(nodes))
        nodeids := make(map[uuid.UUID]*Task)
        for i := range nodes </span><span class="cov0" title="0">{
                fks = append(fks, nodes[i].ID)
                nodeids[nodes[i].ID] = nodes[i]
                if init != nil </span><span class="cov0" title="0">{
                        init(nodes[i])
                }</span>
        }
        <span class="cov0" title="0">if len(query.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                query.ctx.AppendFieldOnce(task.FieldParentID)
        }</span>
        <span class="cov0" title="0">query.Where(predicate.Task(func(s *sql.Selector) </span><span class="cov0" title="0">{
                s.Where(sql.InValues(s.C(task.ChildrenColumn), fks...))
        }</span>))
        <span class="cov0" title="0">neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                fk := n.ParentID
                if fk == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf(`foreign-key "parent_id" is nil for node %v`, n.ID)
                }</span>
                <span class="cov0" title="0">node, ok := nodeids[*fk]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected referenced foreign-key "parent_id" returned %v for node %v`, *fk, n.ID)
                }</span>
                <span class="cov0" title="0">assign(node, n)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *TaskQuery) sqlCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := _q.querySpec()
        _spec.Node.Columns = _q.ctx.Fields
        if len(_q.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique
        }</span>
        <span class="cov0" title="0">return sqlgraph.CountNodes(ctx, _q.driver, _spec)</span>
}

func (_q *TaskQuery) querySpec() *sqlgraph.QuerySpec <span class="cov0" title="0">{
        _spec := sqlgraph.NewQuerySpec(task.Table, task.Columns, sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID))
        _spec.From = _q.sql
        if unique := _q.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov0" title="0"> if _q.path != nil </span><span class="cov0" title="0">{
                _spec.Unique = true
        }</span>
        <span class="cov0" title="0">if fields := _q.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, task.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != task.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
                <span class="cov0" title="0">if _q.withProject != nil </span><span class="cov0" title="0">{
                        _spec.Node.AddColumnOnce(task.FieldProjectID)
                }</span>
                <span class="cov0" title="0">if _q.withParent != nil </span><span class="cov0" title="0">{
                        _spec.Node.AddColumnOnce(task.FieldParentID)
                }</span>
        }
        <span class="cov0" title="0">if ps := _q.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                _spec.Limit = *limit
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                _spec.Offset = *offset
        }</span>
        <span class="cov0" title="0">if ps := _q.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">return _spec</span>
}

func (_q *TaskQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(_q.driver.Dialect())
        t1 := builder.Table(task.Table)
        columns := _q.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = task.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if _q.sql != nil </span><span class="cov0" title="0">{
                selector = _q.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range _q.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range _q.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// TaskGroupBy is the group-by builder for Task entities.
type TaskGroupBy struct {
        selector
        build *TaskQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (_g *TaskGroupBy) Aggregate(fns ...AggregateFunc) *TaskGroupBy <span class="cov0" title="0">{
        _g.fns = append(_g.fns, fns...)
        return _g
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_g *TaskGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _g.build.ctx, ent.OpQueryGroupBy)
        if err := _g.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*TaskQuery, *TaskGroupBy](ctx, _g.build, _g, _g.build.inters, v)</span>
}

func (_g *TaskGroupBy) sqlScan(ctx context.Context, root *TaskQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(_g.fns))
        for _, fn := range _g.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*_g.flds)+len(_g.fns))
                for _, f := range *_g.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*_g.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _g.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// TaskSelect is the builder for selecting fields of Task entities.
type TaskSelect struct {
        *TaskQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (_s *TaskSelect) Aggregate(fns ...AggregateFunc) *TaskSelect <span class="cov0" title="0">{
        _s.fns = append(_s.fns, fns...)
        return _s
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_s *TaskSelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _s.ctx, ent.OpQuerySelect)
        if err := _s.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*TaskQuery, *TaskSelect](ctx, _s.TaskQuery, _s, _s.inters, v)</span>
}

func (_s *TaskSelect) sqlScan(ctx context.Context, root *TaskQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(_s.fns))
        for _, fn := range _s.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*_s.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _s.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/google/uuid"
)

// TaskUpdate is the builder for updating Task entities.
type TaskUpdate struct {
        config
        hooks    []Hook
        mutation *TaskMutation
}

// Where appends a list predicates to the TaskUpdate builder.
func (_u *TaskUpdate) Where(ps ...predicate.Task) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// SetProjectID sets the "project_id" field.
func (_u *TaskUpdate) SetProjectID(v uuid.UUID) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.SetProjectID(v)
        return _u
}</span>

// SetNillableProjectID sets the "project_id" field if the given value is not nil.
func (_u *TaskUpdate) SetNillableProjectID(v *uuid.UUID) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetProjectID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetParentID sets the "parent_id" field.
func (_u *TaskUpdate) SetParentID(v uuid.UUID) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.SetParentID(v)
        return _u
}</span>

// SetNillableParentID sets the "parent_id" field if the given value is not nil.
func (_u *TaskUpdate) SetNillableParentID(v *uuid.UUID) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetParentID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearParentID clears the value of the "parent_id" field.
func (_u *TaskUpdate) ClearParentID() *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ClearParentID()
        return _u
}</span>

// SetTitle sets the "title" field.
func (_u *TaskUpdate) SetTitle(v string) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.SetTitle(v)
        return _u
}</span>

// SetNillableTitle sets the "title" field if the given value is not nil.
func (_u *TaskUpdate) SetNillableTitle(v *string) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetTitle(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetDescription sets the "description" field.
func (_u *TaskUpdate) SetDescription(v string) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.SetDescription(v)
        return _u
}</span>

// SetNillableDescription sets the "description" field if the given value is not nil.
func (_u *TaskUpdate) SetNillableDescription(v *string) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetDescription(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearDescription clears the value of the "description" field.
func (_u *TaskUpdate) ClearDescription() *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ClearDescription()
        return _u
}</span>

// SetState sets the "state" field.
func (_u *TaskUpdate) SetState(v task.State) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.SetState(v)
        return _u
}</span>

// SetNillableState sets the "state" field if the given value is not nil.
func (_u *TaskUpdate) SetNillableState(v *task.State) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetState(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetPriority sets the "priority" field.
func (_u *TaskUpdate) SetPriority(v task.Priority) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.SetPriority(v)
        return _u
}</span>

// SetNillablePriority sets the "priority" field if the given value is not nil.
func (_u *TaskUpdate) SetNillablePriority(v *task.Priority) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetPriority(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetComplexity sets the "complexity" field.
func (_u *TaskUpdate) SetComplexity(v int) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ResetComplexity()
        _u.mutation.SetComplexity(v)
        return _u
}</span>

// SetNillableComplexity sets the "complexity" field if the given value is not nil.
func (_u *TaskUpdate) SetNillableComplexity(v *int) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetComplexity(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddComplexity adds value to the "complexity" field.
func (_u *TaskUpdate) AddComplexity(v int) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.AddComplexity(v)
        return _u
}</span>

// SetDepth sets the "depth" field.
func (_u *TaskUpdate) SetDepth(v int) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ResetDepth()
        _u.mutation.SetDepth(v)
        return _u
}</span>

// SetNillableDepth sets the "depth" field if the given value is not nil.
func (_u *TaskUpdate) SetNillableDepth(v *int) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetDepth(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddDepth adds value to the "depth" field.
func (_u *TaskUpdate) AddDepth(v int) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.AddDepth(v)
        return _u
}</span>

// SetEstimate sets the "estimate" field.
func (_u *TaskUpdate) SetEstimate(v int64) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ResetEstimate()
        _u.mutation.SetEstimate(v)
        return _u
}</span>

// SetNillableEstimate sets the "estimate" field if the given value is not nil.
func (_u *TaskUpdate) SetNillableEstimate(v *int64) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetEstimate(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddEstimate adds value to the "estimate" field.
func (_u *TaskUpdate) AddEstimate(v int64) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.AddEstimate(v)
        return _u
}</span>

// ClearEstimate clears the value of the "estimate" field.
func (_u *TaskUpdate) ClearEstimate() *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ClearEstimate()
        return _u
}</span>

// SetAssignedAgent sets the "assigned_agent" field.
func (_u *TaskUpdate) SetAssignedAgent(v uuid.UUID) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.SetAssignedAgent(v)
        return _u
}</span>

// SetNillableAssignedAgent sets the "assigned_agent" field if the given value is not nil.
func (_u *TaskUpdate) SetNillableAssignedAgent(v *uuid.UUID) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetAssignedAgent(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearAssignedAgent clears the value of the "assigned_agent" field.
func (_u *TaskUpdate) ClearAssignedAgent() *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ClearAssignedAgent()
        return _u
}</span>

// SetUpdatedAt sets the "updated_at" field.
func (_u *TaskUpdate) SetUpdatedAt(v time.Time) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.SetUpdatedAt(v)
        return _u
}</span>

// SetCompletedAt sets the "completed_at" field.
func (_u *TaskUpdate) SetCompletedAt(v time.Time) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.SetCompletedAt(v)
        return _u
}</span>

// SetNillableCompletedAt sets the "completed_at" field if the given value is not nil.
func (_u *TaskUpdate) SetNillableCompletedAt(v *time.Time) *TaskUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetCompletedAt(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (_u *TaskUpdate) ClearCompletedAt() *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ClearCompletedAt()
        return _u
}</span>

// SetProject sets the "project" edge to the Project entity.
func (_u *TaskUpdate) SetProject(v *Project) *TaskUpdate <span class="cov0" title="0">{
        return _u.SetProjectID(v.ID)
}</span>

// SetParent sets the "parent" edge to the Task entity.
func (_u *TaskUpdate) SetParent(v *Task) *TaskUpdate <span class="cov0" title="0">{
        return _u.SetParentID(v.ID)
}</span>

// AddChildIDs adds the "children" edge to the Task entity by IDs.
func (_u *TaskUpdate) AddChildIDs(ids ...uuid.UUID) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.AddChildIDs(ids...)
        return _u
}</span>

// AddChildren adds the "children" edges to the Task entity.
func (_u *TaskUpdate) AddChildren(v ...*Task) *TaskUpdate <span class="cov0" title="0">{
        ids := make([]uuid.UUID, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddChildIDs(ids...)</span>
}

// Mutation returns the TaskMutation object of the builder.
func (_u *TaskUpdate) Mutation() *TaskMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearProject clears the "project" edge to the Project entity.
func (_u *TaskUpdate) ClearProject() *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ClearProject()
        return _u
}</span>

// ClearParent clears the "parent" edge to the Task entity.
func (_u *TaskUpdate) ClearParent() *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ClearParent()
        return _u
}</span>

// ClearChildren clears all "children" edges to the Task entity.
func (_u *TaskUpdate) ClearChildren() *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.ClearChildren()
        return _u
}</span>

// RemoveChildIDs removes the "children" edge to Task entities by IDs.
func (_u *TaskUpdate) RemoveChildIDs(ids ...uuid.UUID) *TaskUpdate <span class="cov0" title="0">{
        _u.mutation.RemoveChildIDs(ids...)
        return _u
}</span>

// RemoveChildren removes "children" edges to Task entities.
func (_u *TaskUpdate) RemoveChildren(v ...*Task) *TaskUpdate <span class="cov0" title="0">{
        ids := make([]uuid.UUID, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveChildIDs(ids...)</span>
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *TaskUpdate) Save(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _u.defaults()
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *TaskUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (_u *TaskUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *TaskUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_u *TaskUpdate) defaults() <span class="cov0" title="0">{
        if _, ok := _u.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                v := task.UpdateDefaultUpdatedAt()
                _u.mutation.SetUpdatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_u *TaskUpdate) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                if err := task.TitleValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "Task.title": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.State(); ok </span><span class="cov0" title="0">{
                if err := task.StateValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "state", err: fmt.Errorf(`ent: validator failed for field "Task.state": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.Priority(); ok </span><span class="cov0" title="0">{
                if err := task.PriorityValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "priority", err: fmt.Errorf(`ent: validator failed for field "Task.priority": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.Complexity(); ok </span><span class="cov0" title="0">{
                if err := task.ComplexityValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "complexity", err: fmt.Errorf(`ent: validator failed for field "Task.complexity": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.Depth(); ok </span><span class="cov0" title="0">{
                if err := task.DepthValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "depth", err: fmt.Errorf(`ent: validator failed for field "Task.depth": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _u.mutation.ProjectCleared() &amp;&amp; len(_u.mutation.ProjectIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Task.project"`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_u *TaskUpdate) sqlSave(ctx context.Context) (_node int, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(task.Table, task.Columns, sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID))
        if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldTitle, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Description(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldDescription, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.DescriptionCleared() </span><span class="cov0" title="0">{
                _spec.ClearField(task.FieldDescription, field.TypeString)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.State(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldState, field.TypeEnum, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Priority(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldPriority, field.TypeEnum, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Complexity(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldComplexity, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedComplexity(); ok </span><span class="cov0" title="0">{
                _spec.AddField(task.FieldComplexity, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Depth(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldDepth, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedDepth(); ok </span><span class="cov0" title="0">{
                _spec.AddField(task.FieldDepth, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Estimate(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldEstimate, field.TypeInt64, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedEstimate(); ok </span><span class="cov0" title="0">{
                _spec.AddField(task.FieldEstimate, field.TypeInt64, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.EstimateCleared() </span><span class="cov0" title="0">{
                _spec.ClearField(task.FieldEstimate, field.TypeInt64)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AssignedAgent(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldAssignedAgent, field.TypeUUID, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.AssignedAgentCleared() </span><span class="cov0" title="0">{
                _spec.ClearField(task.FieldAssignedAgent, field.TypeUUID)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.CompletedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldCompletedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.CompletedAtCleared() </span><span class="cov0" title="0">{
                _spec.ClearField(task.FieldCompletedAt, field.TypeTime)
        }</span>
        <span class="cov0" title="0">if _u.mutation.ProjectCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   task.ProjectTable,
                        Columns: []string{task.ProjectColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.ProjectIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   task.ProjectTable,
                        Columns: []string{task.ProjectColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.ParentCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   task.ParentTable,
                        Columns: []string{task.ParentColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.ParentIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   task.ParentTable,
                        Columns: []string{task.ParentColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.ChildrenCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   task.ChildrenTable,
                        Columns: []string{task.ChildrenColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedChildrenIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.ChildrenCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   task.ChildrenTable,
                        Columns: []string{task.ChildrenColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.ChildrenIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   task.ChildrenTable,
                        Columns: []string{task.ChildrenColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{task.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}

// TaskUpdateOne is the builder for updating a single Task entity.
type TaskUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *TaskMutation
}

// SetProjectID sets the "project_id" field.
func (_u *TaskUpdateOne) SetProjectID(v uuid.UUID) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetProjectID(v)
        return _u
}</span>

// SetNillableProjectID sets the "project_id" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillableProjectID(v *uuid.UUID) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetProjectID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetParentID sets the "parent_id" field.
func (_u *TaskUpdateOne) SetParentID(v uuid.UUID) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetParentID(v)
        return _u
}</span>

// SetNillableParentID sets the "parent_id" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillableParentID(v *uuid.UUID) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetParentID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearParentID clears the value of the "parent_id" field.
func (_u *TaskUpdateOne) ClearParentID() *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearParentID()
        return _u
}</span>

// SetTitle sets the "title" field.
func (_u *TaskUpdateOne) SetTitle(v string) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetTitle(v)
        return _u
}</span>

// SetNillableTitle sets the "title" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillableTitle(v *string) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetTitle(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetDescription sets the "description" field.
func (_u *TaskUpdateOne) SetDescription(v string) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetDescription(v)
        return _u
}</span>

// SetNillableDescription sets the "description" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillableDescription(v *string) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetDescription(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearDescription clears the value of the "description" field.
func (_u *TaskUpdateOne) ClearDescription() *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearDescription()
        return _u
}</span>

// SetState sets the "state" field.
func (_u *TaskUpdateOne) SetState(v task.State) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetState(v)
        return _u
}</span>

// SetNillableState sets the "state" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillableState(v *task.State) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetState(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetPriority sets the "priority" field.
func (_u *TaskUpdateOne) SetPriority(v task.Priority) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetPriority(v)
        return _u
}</span>

// SetNillablePriority sets the "priority" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillablePriority(v *task.Priority) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetPriority(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetComplexity sets the "complexity" field.
func (_u *TaskUpdateOne) SetComplexity(v int) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ResetComplexity()
        _u.mutation.SetComplexity(v)
        return _u
}</span>

// SetNillableComplexity sets the "complexity" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillableComplexity(v *int) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetComplexity(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddComplexity adds value to the "complexity" field.
func (_u *TaskUpdateOne) AddComplexity(v int) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddComplexity(v)
        return _u
}</span>

// SetDepth sets the "depth" field.
func (_u *TaskUpdateOne) SetDepth(v int) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ResetDepth()
        _u.mutation.SetDepth(v)
        return _u
}</span>

// SetNillableDepth sets the "depth" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillableDepth(v *int) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetDepth(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddDepth adds value to the "depth" field.
func (_u *TaskUpdateOne) AddDepth(v int) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddDepth(v)
        return _u
}</span>

// SetEstimate sets the "estimate" field.
func (_u *TaskUpdateOne) SetEstimate(v int64) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ResetEstimate()
        _u.mutation.SetEstimate(v)
        return _u
}</span>

// SetNillableEstimate sets the "estimate" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillableEstimate(v *int64) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetEstimate(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// AddEstimate adds value to the "estimate" field.
func (_u *TaskUpdateOne) AddEstimate(v int64) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddEstimate(v)
        return _u
}</span>

// ClearEstimate clears the value of the "estimate" field.
func (_u *TaskUpdateOne) ClearEstimate() *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearEstimate()
        return _u
}</span>

// SetAssignedAgent sets the "assigned_agent" field.
func (_u *TaskUpdateOne) SetAssignedAgent(v uuid.UUID) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetAssignedAgent(v)
        return _u
}</span>

// SetNillableAssignedAgent sets the "assigned_agent" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillableAssignedAgent(v *uuid.UUID) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetAssignedAgent(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearAssignedAgent clears the value of the "assigned_agent" field.
func (_u *TaskUpdateOne) ClearAssignedAgent() *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearAssignedAgent()
        return _u
}</span>

// SetUpdatedAt sets the "updated_at" field.
func (_u *TaskUpdateOne) SetUpdatedAt(v time.Time) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetUpdatedAt(v)
        return _u
}</span>

// SetCompletedAt sets the "completed_at" field.
func (_u *TaskUpdateOne) SetCompletedAt(v time.Time) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetCompletedAt(v)
        return _u
}</span>

// SetNillableCompletedAt sets the "completed_at" field if the given value is not nil.
func (_u *TaskUpdateOne) SetNillableCompletedAt(v *time.Time) *TaskUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetCompletedAt(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (_u *TaskUpdateOne) ClearCompletedAt() *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearCompletedAt()
        return _u
}</span>

// SetProject sets the "project" edge to the Project entity.
func (_u *TaskUpdateOne) SetProject(v *Project) *TaskUpdateOne <span class="cov0" title="0">{
        return _u.SetProjectID(v.ID)
}</span>

// SetParent sets the "parent" edge to the Task entity.
func (_u *TaskUpdateOne) SetParent(v *Task) *TaskUpdateOne <span class="cov0" title="0">{
        return _u.SetParentID(v.ID)
}</span>

// AddChildIDs adds the "children" edge to the Task entity by IDs.
func (_u *TaskUpdateOne) AddChildIDs(ids ...uuid.UUID) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.AddChildIDs(ids...)
        return _u
}</span>

// AddChildren adds the "children" edges to the Task entity.
func (_u *TaskUpdateOne) AddChildren(v ...*Task) *TaskUpdateOne <span class="cov0" title="0">{
        ids := make([]uuid.UUID, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.AddChildIDs(ids...)</span>
}

// Mutation returns the TaskMutation object of the builder.
func (_u *TaskUpdateOne) Mutation() *TaskMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearProject clears the "project" edge to the Project entity.
func (_u *TaskUpdateOne) ClearProject() *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearProject()
        return _u
}</span>

// ClearParent clears the "parent" edge to the Task entity.
func (_u *TaskUpdateOne) ClearParent() *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearParent()
        return _u
}</span>

// ClearChildren clears all "children" edges to the Task entity.
func (_u *TaskUpdateOne) ClearChildren() *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearChildren()
        return _u
}</span>

// RemoveChildIDs removes the "children" edge to Task entities by IDs.
func (_u *TaskUpdateOne) RemoveChildIDs(ids ...uuid.UUID) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.RemoveChildIDs(ids...)
        return _u
}</span>

// RemoveChildren removes "children" edges to Task entities.
func (_u *TaskUpdateOne) RemoveChildren(v ...*Task) *TaskUpdateOne <span class="cov0" title="0">{
        ids := make([]uuid.UUID, len(v))
        for i := range v </span><span class="cov0" title="0">{
                ids[i] = v[i].ID
        }</span>
        <span class="cov0" title="0">return _u.RemoveChildIDs(ids...)</span>
}

// Where appends a list predicates to the TaskUpdate builder.
func (_u *TaskUpdateOne) Where(ps ...predicate.Task) *TaskUpdateOne <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *TaskUpdateOne) Select(field string, fields ...string) *TaskUpdateOne <span class="cov0" title="0">{
        _u.fields = append([]string{field}, fields...)
        return _u
}</span>

// Save executes the query and returns the updated Task entity.
func (_u *TaskUpdateOne) Save(ctx context.Context) (*Task, error) <span class="cov0" title="0">{
        _u.defaults()
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *TaskUpdateOne) SaveX(ctx context.Context) *Task <span class="cov0" title="0">{
        node, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (_u *TaskUpdateOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *TaskUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_u *TaskUpdateOne) defaults() <span class="cov0" title="0">{
        if _, ok := _u.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                v := task.UpdateDefaultUpdatedAt()
                _u.mutation.SetUpdatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_u *TaskUpdateOne) check() error <span class="cov0" title="0">{
        if v, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                if err := task.TitleValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "Task.title": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.State(); ok </span><span class="cov0" title="0">{
                if err := task.StateValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "state", err: fmt.Errorf(`ent: validator failed for field "Task.state": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.Priority(); ok </span><span class="cov0" title="0">{
                if err := task.PriorityValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "priority", err: fmt.Errorf(`ent: validator failed for field "Task.priority": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.Complexity(); ok </span><span class="cov0" title="0">{
                if err := task.ComplexityValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "complexity", err: fmt.Errorf(`ent: validator failed for field "Task.complexity": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if v, ok := _u.mutation.Depth(); ok </span><span class="cov0" title="0">{
                if err := task.DepthValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "depth", err: fmt.Errorf(`ent: validator failed for field "Task.depth": %w`, err)}
                }</span>
        }
        <span class="cov0" title="0">if _u.mutation.ProjectCleared() &amp;&amp; len(_u.mutation.ProjectIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Task.project"`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_u *TaskUpdateOne) sqlSave(ctx context.Context) (_node *Task, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(task.Table, task.Columns, sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID))
        id, ok := _u.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "Task.id" for update`)}
        }</span>
        <span class="cov0" title="0">_spec.Node.ID.Value = id
        if fields := _u.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, task.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !task.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != task.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov0" title="0">if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := _u.mutation.Title(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldTitle, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Description(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldDescription, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.DescriptionCleared() </span><span class="cov0" title="0">{
                _spec.ClearField(task.FieldDescription, field.TypeString)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.State(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldState, field.TypeEnum, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Priority(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldPriority, field.TypeEnum, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Complexity(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldComplexity, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedComplexity(); ok </span><span class="cov0" title="0">{
                _spec.AddField(task.FieldComplexity, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Depth(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldDepth, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedDepth(); ok </span><span class="cov0" title="0">{
                _spec.AddField(task.FieldDepth, field.TypeInt, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.Estimate(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldEstimate, field.TypeInt64, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AddedEstimate(); ok </span><span class="cov0" title="0">{
                _spec.AddField(task.FieldEstimate, field.TypeInt64, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.EstimateCleared() </span><span class="cov0" title="0">{
                _spec.ClearField(task.FieldEstimate, field.TypeInt64)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.AssignedAgent(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldAssignedAgent, field.TypeUUID, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.AssignedAgentCleared() </span><span class="cov0" title="0">{
                _spec.ClearField(task.FieldAssignedAgent, field.TypeUUID)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if value, ok := _u.mutation.CompletedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(task.FieldCompletedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if _u.mutation.CompletedAtCleared() </span><span class="cov0" title="0">{
                _spec.ClearField(task.FieldCompletedAt, field.TypeTime)
        }</span>
        <span class="cov0" title="0">if _u.mutation.ProjectCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   task.ProjectTable,
                        Columns: []string{task.ProjectColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.ProjectIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   task.ProjectTable,
                        Columns: []string{task.ProjectColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(project.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.ParentCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   task.ParentTable,
                        Columns: []string{task.ParentColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.ParentIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   task.ParentTable,
                        Columns: []string{task.ParentColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.ChildrenCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   task.ChildrenTable,
                        Columns: []string{task.ChildrenColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.RemovedChildrenIDs(); len(nodes) &gt; 0 &amp;&amp; !_u.mutation.ChildrenCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   task.ChildrenTable,
                        Columns: []string{task.ChildrenColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _u.mutation.ChildrenIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   task.ChildrenTable,
                        Columns: []string{task.ChildrenColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">_node = &amp;Task{config: _u.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{task.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
        "github.com/google/uuid"
)

// TaskDependency is the model entity for the TaskDependency schema.
type TaskDependency struct {
        config `json:"-"`
        // ID of the ent.
        ID uuid.UUID `json:"id,omitempty"`
        // TaskID holds the value of the "task_id" field.
        TaskID uuid.UUID `json:"task_id,omitempty"`
        // DependsOnTaskID holds the value of the "depends_on_task_id" field.
        DependsOnTaskID uuid.UUID `json:"depends_on_task_id,omitempty"`
        // CreatedAt holds the value of the "created_at" field.
        CreatedAt time.Time `json:"created_at,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the TaskDependencyQuery when eager-loading is set.
        Edges        TaskDependencyEdges `json:"edges"`
        selectValues sql.SelectValues
}

// TaskDependencyEdges holds the relations/edges for other nodes in the graph.
type TaskDependencyEdges struct {
        // Task holds the value of the task edge.
        Task *Task `json:"task,omitempty"`
        // DependsOnTask holds the value of the depends_on_task edge.
        DependsOnTask *Task `json:"depends_on_task,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [2]bool
}

// TaskOrErr returns the Task value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TaskDependencyEdges) TaskOrErr() (*Task, error) <span class="cov0" title="0">{
        if e.Task != nil </span><span class="cov0" title="0">{
                return e.Task, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: task.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "task"}</span>
}

// DependsOnTaskOrErr returns the DependsOnTask value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TaskDependencyEdges) DependsOnTaskOrErr() (*Task, error) <span class="cov0" title="0">{
        if e.DependsOnTask != nil </span><span class="cov0" title="0">{
                return e.DependsOnTask, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[1] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: task.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "depends_on_task"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*TaskDependency) scanValues(columns []string) ([]any, error) <span class="cov0" title="0">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case taskdependency.FieldCreatedAt:<span class="cov0" title="0">
                        values[i] = new(sql.NullTime)</span>
                case taskdependency.FieldID, taskdependency.FieldTaskID, taskdependency.FieldDependsOnTaskID:<span class="cov0" title="0">
                        values[i] = new(uuid.UUID)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov0" title="0">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the TaskDependency fields.
func (_m *TaskDependency) assignValues(columns []string, values []any) error <span class="cov0" title="0">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov0" title="0">for i := range columns </span><span class="cov0" title="0">{
                switch columns[i] </span>{
                case taskdependency.FieldID:<span class="cov0" title="0">
                        if value, ok := values[i].(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", values[i])
                        }</span> else<span class="cov0" title="0"> if value != nil </span><span class="cov0" title="0">{
                                _m.ID = *value
                        }</span>
                case taskdependency.FieldTaskID:<span class="cov0" title="0">
                        if value, ok := values[i].(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field task_id", values[i])
                        }</span> else<span class="cov0" title="0"> if value != nil </span><span class="cov0" title="0">{
                                _m.TaskID = *value
                        }</span>
                case taskdependency.FieldDependsOnTaskID:<span class="cov0" title="0">
                        if value, ok := values[i].(*uuid.UUID); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field depends_on_task_id", values[i])
                        }</span> else<span class="cov0" title="0"> if value != nil </span><span class="cov0" title="0">{
                                _m.DependsOnTaskID = *value
                        }</span>
                case taskdependency.FieldCreatedAt:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field created_at", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                _m.CreatedAt = value.Time
                        }</span>
                default:<span class="cov0" title="0">
                        _m.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the TaskDependency.
// This includes values selected through modifiers, order, etc.
func (_m *TaskDependency) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return _m.selectValues.Get(name)
}</span>

// QueryTask queries the "task" edge of the TaskDependency entity.
func (_m *TaskDependency) QueryTask() *TaskQuery <span class="cov0" title="0">{
        return NewTaskDependencyClient(_m.config).QueryTask(_m)
}</span>

// QueryDependsOnTask queries the "depends_on_task" edge of the TaskDependency entity.
func (_m *TaskDependency) QueryDependsOnTask() *TaskQuery <span class="cov0" title="0">{
        return NewTaskDependencyClient(_m.config).QueryDependsOnTask(_m)
}</span>

// Update returns a builder for updating this TaskDependency.
// Note that you need to call TaskDependency.Unwrap() before calling this method if this TaskDependency
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *TaskDependency) Update() *TaskDependencyUpdateOne <span class="cov0" title="0">{
        return NewTaskDependencyClient(_m.config).UpdateOne(_m)
}</span>

// Unwrap unwraps the TaskDependency entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *TaskDependency) Unwrap() *TaskDependency <span class="cov0" title="0">{
        _tx, ok := _m.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: TaskDependency is not a transactional entity")</span>
        }
        <span class="cov0" title="0">_m.config.driver = _tx.drv
        return _m</span>
}

// String implements the fmt.Stringer.
func (_m *TaskDependency) String() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("TaskDependency(")
        builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
        builder.WriteString("task_id=")
        builder.WriteString(fmt.Sprintf("%v", _m.TaskID))
        builder.WriteString(", ")
        builder.WriteString("depends_on_task_id=")
        builder.WriteString(fmt.Sprintf("%v", _m.DependsOnTaskID))
        builder.WriteString(", ")
        builder.WriteString("created_at=")
        builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
        builder.WriteByte(')')
        return builder.String()
}</span>

// TaskDependencies is a parsable slice of TaskDependency.
type TaskDependencies []*TaskDependency
</pre>
		
		<pre class="file" id="file65" style="display: none">// Code generated by ent, DO NOT EDIT.

package taskdependency

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/google/uuid"
)

const (
        // Label holds the string label denoting the taskdependency type in the database.
        Label = "task_dependency"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldTaskID holds the string denoting the task_id field in the database.
        FieldTaskID = "task_id"
        // FieldDependsOnTaskID holds the string denoting the depends_on_task_id field in the database.
        FieldDependsOnTaskID = "depends_on_task_id"
        // FieldCreatedAt holds the string denoting the created_at field in the database.
        FieldCreatedAt = "created_at"
        // EdgeTask holds the string denoting the task edge name in mutations.
        EdgeTask = "task"
        // EdgeDependsOnTask holds the string denoting the depends_on_task edge name in mutations.
        EdgeDependsOnTask = "depends_on_task"
        // Table holds the table name of the taskdependency in the database.
        Table = "task_dependencies"
        // TaskTable is the table that holds the task relation/edge.
        TaskTable = "task_dependencies"
        // TaskInverseTable is the table name for the Task entity.
        // It exists in this package in order to avoid circular dependency with the "task" package.
        TaskInverseTable = "tasks"
        // TaskColumn is the table column denoting the task relation/edge.
        TaskColumn = "task_id"
        // DependsOnTaskTable is the table that holds the depends_on_task relation/edge.
        DependsOnTaskTable = "task_dependencies"
        // DependsOnTaskInverseTable is the table name for the Task entity.
        // It exists in this package in order to avoid circular dependency with the "task" package.
        DependsOnTaskInverseTable = "tasks"
        // DependsOnTaskColumn is the table column denoting the depends_on_task relation/edge.
        DependsOnTaskColumn = "depends_on_task_id"
)

// Columns holds all SQL columns for taskdependency fields.
var Columns = []string{
        FieldID,
        FieldTaskID,
        FieldDependsOnTaskID,
        FieldCreatedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var (
        // DefaultCreatedAt holds the default value on creation for the "created_at" field.
        DefaultCreatedAt func() time.Time
        // DefaultID holds the default value on creation for the "id" field.
        DefaultID func() uuid.UUID
)

// OrderOption defines the ordering options for the TaskDependency queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// ByTaskID orders the results by the task_id field.
func ByTaskID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldTaskID, opts...).ToFunc()
}</span>

// ByDependsOnTaskID orders the results by the depends_on_task_id field.
func ByDependsOnTaskID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldDependsOnTaskID, opts...).ToFunc()
}</span>

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}</span>

// ByTaskField orders the results by task field.
func ByTaskField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newTaskStep(), sql.OrderByField(field, opts...))
        }</span>
}

// ByDependsOnTaskField orders the results by depends_on_task field.
func ByDependsOnTaskField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newDependsOnTaskStep(), sql.OrderByField(field, opts...))
        }</span>
}
func newTaskStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(TaskInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, false, TaskTable, TaskColumn),
        )
}</span>
func newDependsOnTaskStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(DependsOnTaskInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, false, DependsOnTaskTable, DependsOnTaskColumn),
        )
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">// Code generated by ent, DO NOT EDIT.

package taskdependency

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldLTE(FieldID, id))
}</span>

// TaskID applies equality check predicate on the "task_id" field. It's identical to TaskIDEQ.
func TaskID(v uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldEQ(FieldTaskID, v))
}</span>

// DependsOnTaskID applies equality check predicate on the "depends_on_task_id" field. It's identical to DependsOnTaskIDEQ.
func DependsOnTaskID(v uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldEQ(FieldDependsOnTaskID, v))
}</span>

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// TaskIDEQ applies the EQ predicate on the "task_id" field.
func TaskIDEQ(v uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldEQ(FieldTaskID, v))
}</span>

// TaskIDNEQ applies the NEQ predicate on the "task_id" field.
func TaskIDNEQ(v uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldNEQ(FieldTaskID, v))
}</span>

// TaskIDIn applies the In predicate on the "task_id" field.
func TaskIDIn(vs ...uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldIn(FieldTaskID, vs...))
}</span>

// TaskIDNotIn applies the NotIn predicate on the "task_id" field.
func TaskIDNotIn(vs ...uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldNotIn(FieldTaskID, vs...))
}</span>

// DependsOnTaskIDEQ applies the EQ predicate on the "depends_on_task_id" field.
func DependsOnTaskIDEQ(v uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldEQ(FieldDependsOnTaskID, v))
}</span>

// DependsOnTaskIDNEQ applies the NEQ predicate on the "depends_on_task_id" field.
func DependsOnTaskIDNEQ(v uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldNEQ(FieldDependsOnTaskID, v))
}</span>

// DependsOnTaskIDIn applies the In predicate on the "depends_on_task_id" field.
func DependsOnTaskIDIn(vs ...uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldIn(FieldDependsOnTaskID, vs...))
}</span>

// DependsOnTaskIDNotIn applies the NotIn predicate on the "depends_on_task_id" field.
func DependsOnTaskIDNotIn(vs ...uuid.UUID) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldNotIn(FieldDependsOnTaskID, vs...))
}</span>

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldNEQ(FieldCreatedAt, v))
}</span>

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldNotIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldGT(FieldCreatedAt, v))
}</span>

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldGTE(FieldCreatedAt, v))
}</span>

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldLT(FieldCreatedAt, v))
}</span>

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.FieldLTE(FieldCreatedAt, v))
}</span>

// HasTask applies the HasEdge predicate on the "task" edge.
func HasTask() predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, false, TaskTable, TaskColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasTaskWith applies the HasEdge predicate on the "task" edge with a given conditions (other predicates).
func HasTaskWith(preds ...predicate.Task) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newTaskStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// HasDependsOnTask applies the HasEdge predicate on the "depends_on_task" edge.
func HasDependsOnTask() predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, false, DependsOnTaskTable, DependsOnTaskColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasDependsOnTaskWith applies the HasEdge predicate on the "depends_on_task" edge with a given conditions (other predicates).
func HasDependsOnTaskWith(preds ...predicate.Task) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newDependsOnTaskStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.TaskDependency) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.TaskDependency) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.TaskDependency) predicate.TaskDependency <span class="cov0" title="0">{
        return predicate.TaskDependency(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
        "github.com/google/uuid"
)

// TaskDependencyCreate is the builder for creating a TaskDependency entity.
type TaskDependencyCreate struct {
        config
        mutation *TaskDependencyMutation
        hooks    []Hook
}

// SetTaskID sets the "task_id" field.
func (_c *TaskDependencyCreate) SetTaskID(v uuid.UUID) *TaskDependencyCreate <span class="cov0" title="0">{
        _c.mutation.SetTaskID(v)
        return _c
}</span>

// SetDependsOnTaskID sets the "depends_on_task_id" field.
func (_c *TaskDependencyCreate) SetDependsOnTaskID(v uuid.UUID) *TaskDependencyCreate <span class="cov0" title="0">{
        _c.mutation.SetDependsOnTaskID(v)
        return _c
}</span>

// SetCreatedAt sets the "created_at" field.
func (_c *TaskDependencyCreate) SetCreatedAt(v time.Time) *TaskDependencyCreate <span class="cov0" title="0">{
        _c.mutation.SetCreatedAt(v)
        return _c
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (_c *TaskDependencyCreate) SetNillableCreatedAt(v *time.Time) *TaskDependencyCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetCreatedAt(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetID sets the "id" field.
func (_c *TaskDependencyCreate) SetID(v uuid.UUID) *TaskDependencyCreate <span class="cov0" title="0">{
        _c.mutation.SetID(v)
        return _c
}</span>

// SetNillableID sets the "id" field if the given value is not nil.
func (_c *TaskDependencyCreate) SetNillableID(v *uuid.UUID) *TaskDependencyCreate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _c.SetID(*v)
        }</span>
        <span class="cov0" title="0">return _c</span>
}

// SetTask sets the "task" edge to the Task entity.
func (_c *TaskDependencyCreate) SetTask(v *Task) *TaskDependencyCreate <span class="cov0" title="0">{
        return _c.SetTaskID(v.ID)
}</span>

// SetDependsOnTask sets the "depends_on_task" edge to the Task entity.
func (_c *TaskDependencyCreate) SetDependsOnTask(v *Task) *TaskDependencyCreate <span class="cov0" title="0">{
        return _c.SetDependsOnTaskID(v.ID)
}</span>

// Mutation returns the TaskDependencyMutation object of the builder.
func (_c *TaskDependencyCreate) Mutation() *TaskDependencyMutation <span class="cov0" title="0">{
        return _c.mutation
}</span>

// Save creates the TaskDependency in the database.
func (_c *TaskDependencyCreate) Save(ctx context.Context) (*TaskDependency, error) <span class="cov0" title="0">{
        _c.defaults()
        return withHooks(ctx, _c.sqlSave, _c.mutation, _c.hooks)
}</span>

// SaveX calls Save and panics if Save returns an error.
func (_c *TaskDependencyCreate) SaveX(ctx context.Context) *TaskDependency <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *TaskDependencyCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *TaskDependencyCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (_c *TaskDependencyCreate) defaults() <span class="cov0" title="0">{
        if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                v := taskdependency.DefaultCreatedAt()
                _c.mutation.SetCreatedAt(v)
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.ID(); !ok </span><span class="cov0" title="0">{
                v := taskdependency.DefaultID()
                _c.mutation.SetID(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (_c *TaskDependencyCreate) check() error <span class="cov0" title="0">{
        if _, ok := _c.mutation.TaskID(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "task_id", err: errors.New(`ent: missing required field "TaskDependency.task_id"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.DependsOnTaskID(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "depends_on_task_id", err: errors.New(`ent: missing required field "TaskDependency.depends_on_task_id"`)}
        }</span>
        <span class="cov0" title="0">if _, ok := _c.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "TaskDependency.created_at"`)}
        }</span>
        <span class="cov0" title="0">if len(_c.mutation.TaskIDs()) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "task", err: errors.New(`ent: missing required edge "TaskDependency.task"`)}
        }</span>
        <span class="cov0" title="0">if len(_c.mutation.DependsOnTaskIDs()) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "depends_on_task", err: errors.New(`ent: missing required edge "TaskDependency.depends_on_task"`)}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_c *TaskDependencyCreate) sqlSave(ctx context.Context) (*TaskDependency, error) <span class="cov0" title="0">{
        if err := _c.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_node, _spec := _c.createSpec()
        if err := sqlgraph.CreateNode(ctx, _c.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if _spec.ID.Value != nil </span><span class="cov0" title="0">{
                if id, ok := _spec.ID.Value.(*uuid.UUID); ok </span><span class="cov0" title="0">{
                        _node.ID = *id
                }</span> else<span class="cov0" title="0"> if err := _node.ID.Scan(_spec.ID.Value); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">_c.mutation.id = &amp;_node.ID
        _c.mutation.done = true
        return _node, nil</span>
}

func (_c *TaskDependencyCreate) createSpec() (*TaskDependency, *sqlgraph.CreateSpec) <span class="cov0" title="0">{
        var (
                _node = &amp;TaskDependency{config: _c.config}
                _spec = sqlgraph.NewCreateSpec(taskdependency.Table, sqlgraph.NewFieldSpec(taskdependency.FieldID, field.TypeUUID))
        )
        if id, ok := _c.mutation.ID(); ok </span><span class="cov0" title="0">{
                _node.ID = id
                _spec.ID.Value = &amp;id
        }</span>
        <span class="cov0" title="0">if value, ok := _c.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(taskdependency.FieldCreatedAt, field.TypeTime, value)
                _node.CreatedAt = value
        }</span>
        <span class="cov0" title="0">if nodes := _c.mutation.TaskIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   taskdependency.TaskTable,
                        Columns: []string{taskdependency.TaskColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_node.TaskID = nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">if nodes := _c.mutation.DependsOnTaskIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   taskdependency.DependsOnTaskTable,
                        Columns: []string{taskdependency.DependsOnTaskColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_node.DependsOnTaskID = nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov0" title="0">return _node, _spec</span>
}

// TaskDependencyCreateBulk is the builder for creating many TaskDependency entities in bulk.
type TaskDependencyCreateBulk struct {
        config
        err      error
        builders []*TaskDependencyCreate
}

// Save creates the TaskDependency entities in the database.
func (_c *TaskDependencyCreateBulk) Save(ctx context.Context) ([]*TaskDependency, error) <span class="cov0" title="0">{
        if _c.err != nil </span><span class="cov0" title="0">{
                return nil, _c.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(_c.builders))
        nodes := make([]*TaskDependency, len(_c.builders))
        mutators := make([]Mutator, len(_c.builders))
        for i := range _c.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := _c.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*TaskDependencyMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, _c.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, _c.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, _c.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (_c *TaskDependencyCreateBulk) SaveX(ctx context.Context) []*TaskDependency <span class="cov0" title="0">{
        v, err := _c.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (_c *TaskDependencyCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _c.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_c *TaskDependencyCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _c.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
)

// TaskDependencyDelete is the builder for deleting a TaskDependency entity.
type TaskDependencyDelete struct {
        config
        hooks    []Hook
        mutation *TaskDependencyMutation
}

// Where appends a list predicates to the TaskDependencyDelete builder.
func (_d *TaskDependencyDelete) Where(ps ...predicate.TaskDependency) *TaskDependencyDelete <span class="cov0" title="0">{
        _d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (_d *TaskDependencyDelete) Exec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _d.sqlExec, _d.mutation, _d.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_d *TaskDependencyDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := _d.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (_d *TaskDependencyDelete) sqlExec(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := sqlgraph.NewDeleteSpec(taskdependency.Table, sqlgraph.NewFieldSpec(taskdependency.FieldID, field.TypeUUID))
        if ps := _d.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">affected, err := sqlgraph.DeleteNodes(ctx, _d.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov0" title="0">_d.mutation.done = true
        return affected, err</span>
}

// TaskDependencyDeleteOne is the builder for deleting a single TaskDependency entity.
type TaskDependencyDeleteOne struct {
        _d *TaskDependencyDelete
}

// Where appends a list predicates to the TaskDependencyDelete builder.
func (_d *TaskDependencyDeleteOne) Where(ps ...predicate.TaskDependency) *TaskDependencyDeleteOne <span class="cov0" title="0">{
        _d._d.mutation.Where(ps...)
        return _d
}</span>

// Exec executes the deletion query.
func (_d *TaskDependencyDeleteOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        n, err := _d._d.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov0" title="0">
                return &amp;NotFoundError{taskdependency.Label}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (_d *TaskDependencyDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _d.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file69" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "fmt"
        "math"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
        "github.com/google/uuid"
)

// TaskDependencyQuery is the builder for querying TaskDependency entities.
type TaskDependencyQuery struct {
        config
        ctx               *QueryContext
        order             []taskdependency.OrderOption
        inters            []Interceptor
        predicates        []predicate.TaskDependency
        withTask          *TaskQuery
        withDependsOnTask *TaskQuery
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the TaskDependencyQuery builder.
func (_q *TaskDependencyQuery) Where(ps ...predicate.TaskDependency) *TaskDependencyQuery <span class="cov0" title="0">{
        _q.predicates = append(_q.predicates, ps...)
        return _q
}</span>

// Limit the number of records to be returned by this query.
func (_q *TaskDependencyQuery) Limit(limit int) *TaskDependencyQuery <span class="cov0" title="0">{
        _q.ctx.Limit = &amp;limit
        return _q
}</span>

// Offset to start from.
func (_q *TaskDependencyQuery) Offset(offset int) *TaskDependencyQuery <span class="cov0" title="0">{
        _q.ctx.Offset = &amp;offset
        return _q
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (_q *TaskDependencyQuery) Unique(unique bool) *TaskDependencyQuery <span class="cov0" title="0">{
        _q.ctx.Unique = &amp;unique
        return _q
}</span>

// Order specifies how the records should be ordered.
func (_q *TaskDependencyQuery) Order(o ...taskdependency.OrderOption) *TaskDependencyQuery <span class="cov0" title="0">{
        _q.order = append(_q.order, o...)
        return _q
}</span>

// QueryTask chains the current query on the "task" edge.
func (_q *TaskDependencyQuery) QueryTask() *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(taskdependency.Table, taskdependency.FieldID, selector),
                        sqlgraph.To(task.Table, task.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, false, taskdependency.TaskTable, taskdependency.TaskColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// QueryDependsOnTask chains the current query on the "depends_on_task" edge.
func (_q *TaskDependencyQuery) QueryDependsOnTask() *TaskQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: _q.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := _q.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(taskdependency.Table, taskdependency.FieldID, selector),
                        sqlgraph.To(task.Table, task.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, false, taskdependency.DependsOnTaskTable, taskdependency.DependsOnTaskColumn),
                )
                fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first TaskDependency entity from the query.
// Returns a *NotFoundError when no TaskDependency was found.
func (_q *TaskDependencyQuery) First(ctx context.Context) (*TaskDependency, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(1).All(setContextOp(ctx, _q.ctx, ent.OpQueryFirst))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{taskdependency.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (_q *TaskDependencyQuery) FirstX(ctx context.Context) *TaskDependency <span class="cov0" title="0">{
        node, err := _q.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first TaskDependency ID from the query.
// Returns a *NotFoundError when no TaskDependency ID was found.
func (_q *TaskDependencyQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) <span class="cov0" title="0">{
        var ids []uuid.UUID
        if ids, err = _q.Limit(1).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryFirstID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{taskdependency.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (_q *TaskDependencyQuery) FirstIDX(ctx context.Context) uuid.UUID <span class="cov0" title="0">{
        id, err := _q.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single TaskDependency entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one TaskDependency entity is found.
// Returns a *NotFoundError when no TaskDependency entities are found.
func (_q *TaskDependencyQuery) Only(ctx context.Context) (*TaskDependency, error) <span class="cov0" title="0">{
        nodes, err := _q.Limit(2).All(setContextOp(ctx, _q.ctx, ent.OpQueryOnly))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch len(nodes) </span>{
        case 1:<span class="cov0" title="0">
                return nodes[0], nil</span>
        case 0:<span class="cov0" title="0">
                return nil, &amp;NotFoundError{taskdependency.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{taskdependency.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (_q *TaskDependencyQuery) OnlyX(ctx context.Context) *TaskDependency <span class="cov0" title="0">{
        node, err := _q.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only TaskDependency ID in the query.
// Returns a *NotSingularError when more than one TaskDependency ID is found.
// Returns a *NotFoundError when no entities are found.
func (_q *TaskDependencyQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) <span class="cov0" title="0">{
        var ids []uuid.UUID
        if ids, err = _q.Limit(2).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryOnlyID)); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{taskdependency.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{taskdependency.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (_q *TaskDependencyQuery) OnlyIDX(ctx context.Context) uuid.UUID <span class="cov0" title="0">{
        id, err := _q.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of TaskDependencies.
func (_q *TaskDependencyQuery) All(ctx context.Context) ([]*TaskDependency, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryAll)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">qr := querierAll[[]*TaskDependency, *TaskDependencyQuery]()
        return withInterceptors[[]*TaskDependency](ctx, _q, qr, _q.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (_q *TaskDependencyQuery) AllX(ctx context.Context) []*TaskDependency <span class="cov0" title="0">{
        nodes, err := _q.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of TaskDependency IDs.
func (_q *TaskDependencyQuery) IDs(ctx context.Context) (ids []uuid.UUID, err error) <span class="cov0" title="0">{
        if _q.ctx.Unique == nil &amp;&amp; _q.path != nil </span><span class="cov0" title="0">{
                _q.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, _q.ctx, ent.OpQueryIDs)
        if err = _q.Select(taskdependency.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (_q *TaskDependencyQuery) IDsX(ctx context.Context) []uuid.UUID <span class="cov0" title="0">{
        ids, err := _q.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (_q *TaskDependencyQuery) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryCount)
        if err := _q.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return withInterceptors[int](ctx, _q, querierCount[*TaskDependencyQuery](), _q.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (_q *TaskDependencyQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := _q.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (_q *TaskDependencyQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _q.ctx, ent.OpQueryExist)
        switch _, err := _q.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (_q *TaskDependencyQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := _q.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the TaskDependencyQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (_q *TaskDependencyQuery) Clone() *TaskDependencyQuery <span class="cov0" title="0">{
        if _q == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;TaskDependencyQuery{
                config:            _q.config,
                ctx:               _q.ctx.Clone(),
                order:             append([]taskdependency.OrderOption{}, _q.order...),
                inters:            append([]Interceptor{}, _q.inters...),
                predicates:        append([]predicate.TaskDependency{}, _q.predicates...),
                withTask:          _q.withTask.Clone(),
                withDependsOnTask: _q.withDependsOnTask.Clone(),
                // clone intermediate query.
                sql:  _q.sql.Clone(),
                path: _q.path,
        }</span>
}

// WithTask tells the query-builder to eager-load the nodes that are connected to
// the "task" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TaskDependencyQuery) WithTask(opts ...func(*TaskQuery)) *TaskDependencyQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withTask = query
        return _q</span>
}

// WithDependsOnTask tells the query-builder to eager-load the nodes that are connected to
// the "depends_on_task" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *TaskDependencyQuery) WithDependsOnTask(opts ...func(*TaskQuery)) *TaskDependencyQuery <span class="cov0" title="0">{
        query := (&amp;TaskClient{config: _q.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">_q.withDependsOnTask = query
        return _q</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                TaskID uuid.UUID `json:"task_id,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.TaskDependency.Query().
//                GroupBy(taskdependency.FieldTaskID).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (_q *TaskDependencyQuery) GroupBy(field string, fields ...string) *TaskDependencyGroupBy <span class="cov0" title="0">{
        _q.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;TaskDependencyGroupBy{build: _q}
        grbuild.flds = &amp;_q.ctx.Fields
        grbuild.label = taskdependency.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                TaskID uuid.UUID `json:"task_id,omitempty"`
//        }
//
//        client.TaskDependency.Query().
//                Select(taskdependency.FieldTaskID).
//                Scan(ctx, &amp;v)
func (_q *TaskDependencyQuery) Select(fields ...string) *TaskDependencySelect <span class="cov0" title="0">{
        _q.ctx.Fields = append(_q.ctx.Fields, fields...)
        sbuild := &amp;TaskDependencySelect{TaskDependencyQuery: _q}
        sbuild.label = taskdependency.Label
        sbuild.flds, sbuild.scan = &amp;_q.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a TaskDependencySelect configured with the given aggregations.
func (_q *TaskDependencyQuery) Aggregate(fns ...AggregateFunc) *TaskDependencySelect <span class="cov0" title="0">{
        return _q.Select().Aggregate(fns...)
}</span>

func (_q *TaskDependencyQuery) prepareQuery(ctx context.Context) error <span class="cov0" title="0">{
        for _, inter := range _q.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, _q); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, f := range _q.ctx.Fields </span><span class="cov0" title="0">{
                if !taskdependency.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov0" title="0">if _q.path != nil </span><span class="cov0" title="0">{
                prev, err := _q.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_q.sql = prev</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *TaskDependencyQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*TaskDependency, error) <span class="cov0" title="0">{
        var (
                nodes       = []*TaskDependency{}
                _spec       = _q.querySpec()
                loadedTypes = [2]bool{
                        _q.withTask != nil,
                        _q.withDependsOnTask != nil,
                }
        )
        _spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov0" title="0">{
                return (*TaskDependency).scanValues(nil, columns)
        }</span>
        <span class="cov0" title="0">_spec.Assign = func(columns []string, values []any) error </span><span class="cov0" title="0">{
                node := &amp;TaskDependency{config: _q.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov0" title="0">for i := range hooks </span><span class="cov0" title="0">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov0" title="0">if err := sqlgraph.QueryNodes(ctx, _q.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nodes, nil
        }</span>
        <span class="cov0" title="0">if query := _q.withTask; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadTask(ctx, query, nodes, nil,
                        func(n *TaskDependency, e *Task) </span><span class="cov0" title="0">{ n.Edges.Task = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if query := _q.withDependsOnTask; query != nil </span><span class="cov0" title="0">{
                if err := _q.loadDependsOnTask(ctx, query, nodes, nil,
                        func(n *TaskDependency, e *Task) </span><span class="cov0" title="0">{ n.Edges.DependsOnTask = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

func (_q *TaskDependencyQuery) loadTask(ctx context.Context, query *TaskQuery, nodes []*TaskDependency, init func(*TaskDependency), assign func(*TaskDependency, *Task)) error <span class="cov0" title="0">{
        ids := make([]uuid.UUID, 0, len(nodes))
        nodeids := make(map[uuid.UUID][]*TaskDependency)
        for i := range nodes </span><span class="cov0" title="0">{
                fk := nodes[i].TaskID
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(task.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "task_id" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
func (_q *TaskDependencyQuery) loadDependsOnTask(ctx context.Context, query *TaskQuery, nodes []*TaskDependency, init func(*TaskDependency), assign func(*TaskDependency, *Task)) error <span class="cov0" title="0">{
        ids := make([]uuid.UUID, 0, len(nodes))
        nodeids := make(map[uuid.UUID][]*TaskDependency)
        for i := range nodes </span><span class="cov0" title="0">{
                fk := nodes[i].DependsOnTaskID
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(task.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "depends_on_task_id" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (_q *TaskDependencyQuery) sqlCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := _q.querySpec()
        _spec.Node.Columns = _q.ctx.Fields
        if len(_q.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique
        }</span>
        <span class="cov0" title="0">return sqlgraph.CountNodes(ctx, _q.driver, _spec)</span>
}

func (_q *TaskDependencyQuery) querySpec() *sqlgraph.QuerySpec <span class="cov0" title="0">{
        _spec := sqlgraph.NewQuerySpec(taskdependency.Table, taskdependency.Columns, sqlgraph.NewFieldSpec(taskdependency.FieldID, field.TypeUUID))
        _spec.From = _q.sql
        if unique := _q.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov0" title="0"> if _q.path != nil </span><span class="cov0" title="0">{
                _spec.Unique = true
        }</span>
        <span class="cov0" title="0">if fields := _q.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, taskdependency.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != taskdependency.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
                <span class="cov0" title="0">if _q.withTask != nil </span><span class="cov0" title="0">{
                        _spec.Node.AddColumnOnce(taskdependency.FieldTaskID)
                }</span>
                <span class="cov0" title="0">if _q.withDependsOnTask != nil </span><span class="cov0" title="0">{
                        _spec.Node.AddColumnOnce(taskdependency.FieldDependsOnTaskID)
                }</span>
        }
        <span class="cov0" title="0">if ps := _q.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                _spec.Limit = *limit
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                _spec.Offset = *offset
        }</span>
        <span class="cov0" title="0">if ps := _q.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">return _spec</span>
}

func (_q *TaskDependencyQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(_q.driver.Dialect())
        t1 := builder.Table(taskdependency.Table)
        columns := _q.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = taskdependency.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if _q.sql != nil </span><span class="cov0" title="0">{
                selector = _q.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if _q.ctx.Unique != nil &amp;&amp; *_q.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range _q.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range _q.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := _q.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := _q.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// TaskDependencyGroupBy is the group-by builder for TaskDependency entities.
type TaskDependencyGroupBy struct {
        selector
        build *TaskDependencyQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (_g *TaskDependencyGroupBy) Aggregate(fns ...AggregateFunc) *TaskDependencyGroupBy <span class="cov0" title="0">{
        _g.fns = append(_g.fns, fns...)
        return _g
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_g *TaskDependencyGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _g.build.ctx, ent.OpQueryGroupBy)
        if err := _g.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*TaskDependencyQuery, *TaskDependencyGroupBy](ctx, _g.build, _g, _g.build.inters, v)</span>
}

func (_g *TaskDependencyGroupBy) sqlScan(ctx context.Context, root *TaskDependencyQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(_g.fns))
        for _, fn := range _g.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*_g.flds)+len(_g.fns))
                for _, f := range *_g.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*_g.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _g.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// TaskDependencySelect is the builder for selecting fields of TaskDependency entities.
type TaskDependencySelect struct {
        *TaskDependencyQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (_s *TaskDependencySelect) Aggregate(fns ...AggregateFunc) *TaskDependencySelect <span class="cov0" title="0">{
        _s.fns = append(_s.fns, fns...)
        return _s
}</span>

// Scan applies the selector query and scans the result into the given value.
func (_s *TaskDependencySelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, _s.ctx, ent.OpQuerySelect)
        if err := _s.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*TaskDependencyQuery, *TaskDependencySelect](ctx, _s.TaskDependencyQuery, _s, _s.inters, v)</span>
}

func (_s *TaskDependencySelect) sqlScan(ctx context.Context, root *TaskDependencyQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(_s.fns))
        for _, fn := range _s.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*_s.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := _s.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/predicate"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
        "github.com/google/uuid"
)

// TaskDependencyUpdate is the builder for updating TaskDependency entities.
type TaskDependencyUpdate struct {
        config
        hooks    []Hook
        mutation *TaskDependencyMutation
}

// Where appends a list predicates to the TaskDependencyUpdate builder.
func (_u *TaskDependencyUpdate) Where(ps ...predicate.TaskDependency) *TaskDependencyUpdate <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// SetTaskID sets the "task_id" field.
func (_u *TaskDependencyUpdate) SetTaskID(v uuid.UUID) *TaskDependencyUpdate <span class="cov0" title="0">{
        _u.mutation.SetTaskID(v)
        return _u
}</span>

// SetNillableTaskID sets the "task_id" field if the given value is not nil.
func (_u *TaskDependencyUpdate) SetNillableTaskID(v *uuid.UUID) *TaskDependencyUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetTaskID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetDependsOnTaskID sets the "depends_on_task_id" field.
func (_u *TaskDependencyUpdate) SetDependsOnTaskID(v uuid.UUID) *TaskDependencyUpdate <span class="cov0" title="0">{
        _u.mutation.SetDependsOnTaskID(v)
        return _u
}</span>

// SetNillableDependsOnTaskID sets the "depends_on_task_id" field if the given value is not nil.
func (_u *TaskDependencyUpdate) SetNillableDependsOnTaskID(v *uuid.UUID) *TaskDependencyUpdate <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetDependsOnTaskID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetTask sets the "task" edge to the Task entity.
func (_u *TaskDependencyUpdate) SetTask(v *Task) *TaskDependencyUpdate <span class="cov0" title="0">{
        return _u.SetTaskID(v.ID)
}</span>

// SetDependsOnTask sets the "depends_on_task" edge to the Task entity.
func (_u *TaskDependencyUpdate) SetDependsOnTask(v *Task) *TaskDependencyUpdate <span class="cov0" title="0">{
        return _u.SetDependsOnTaskID(v.ID)
}</span>

// Mutation returns the TaskDependencyMutation object of the builder.
func (_u *TaskDependencyUpdate) Mutation() *TaskDependencyMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearTask clears the "task" edge to the Task entity.
func (_u *TaskDependencyUpdate) ClearTask() *TaskDependencyUpdate <span class="cov0" title="0">{
        _u.mutation.ClearTask()
        return _u
}</span>

// ClearDependsOnTask clears the "depends_on_task" edge to the Task entity.
func (_u *TaskDependencyUpdate) ClearDependsOnTask() *TaskDependencyUpdate <span class="cov0" title="0">{
        _u.mutation.ClearDependsOnTask()
        return _u
}</span>

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *TaskDependencyUpdate) Save(ctx context.Context) (int, error) <span class="cov0" title="0">{
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *TaskDependencyUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (_u *TaskDependencyUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *TaskDependencyUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// check runs all checks and user-defined validators on the builder.
func (_u *TaskDependencyUpdate) check() error <span class="cov0" title="0">{
        if _u.mutation.TaskCleared() &amp;&amp; len(_u.mutation.TaskIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "TaskDependency.task"`)
        }</span>
        <span class="cov0" title="0">if _u.mutation.DependsOnTaskCleared() &amp;&amp; len(_u.mutation.DependsOnTaskIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "TaskDependency.depends_on_task"`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_u *TaskDependencyUpdate) sqlSave(ctx context.Context) (_node int, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(taskdependency.Table, taskdependency.Columns, sqlgraph.NewFieldSpec(taskdependency.FieldID, field.TypeUUID))
        if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if _u.mutation.TaskCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   taskdependency.TaskTable,
                        Columns: []string{taskdependency.TaskColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.TaskIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   taskdependency.TaskTable,
                        Columns: []string{taskdependency.TaskColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.DependsOnTaskCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   taskdependency.DependsOnTaskTable,
                        Columns: []string{taskdependency.DependsOnTaskColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.DependsOnTaskIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   taskdependency.DependsOnTaskTable,
                        Columns: []string{taskdependency.DependsOnTaskColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{taskdependency.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}

// TaskDependencyUpdateOne is the builder for updating a single TaskDependency entity.
type TaskDependencyUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *TaskDependencyMutation
}

// SetTaskID sets the "task_id" field.
func (_u *TaskDependencyUpdateOne) SetTaskID(v uuid.UUID) *TaskDependencyUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetTaskID(v)
        return _u
}</span>

// SetNillableTaskID sets the "task_id" field if the given value is not nil.
func (_u *TaskDependencyUpdateOne) SetNillableTaskID(v *uuid.UUID) *TaskDependencyUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetTaskID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetDependsOnTaskID sets the "depends_on_task_id" field.
func (_u *TaskDependencyUpdateOne) SetDependsOnTaskID(v uuid.UUID) *TaskDependencyUpdateOne <span class="cov0" title="0">{
        _u.mutation.SetDependsOnTaskID(v)
        return _u
}</span>

// SetNillableDependsOnTaskID sets the "depends_on_task_id" field if the given value is not nil.
func (_u *TaskDependencyUpdateOne) SetNillableDependsOnTaskID(v *uuid.UUID) *TaskDependencyUpdateOne <span class="cov0" title="0">{
        if v != nil </span><span class="cov0" title="0">{
                _u.SetDependsOnTaskID(*v)
        }</span>
        <span class="cov0" title="0">return _u</span>
}

// SetTask sets the "task" edge to the Task entity.
func (_u *TaskDependencyUpdateOne) SetTask(v *Task) *TaskDependencyUpdateOne <span class="cov0" title="0">{
        return _u.SetTaskID(v.ID)
}</span>

// SetDependsOnTask sets the "depends_on_task" edge to the Task entity.
func (_u *TaskDependencyUpdateOne) SetDependsOnTask(v *Task) *TaskDependencyUpdateOne <span class="cov0" title="0">{
        return _u.SetDependsOnTaskID(v.ID)
}</span>

// Mutation returns the TaskDependencyMutation object of the builder.
func (_u *TaskDependencyUpdateOne) Mutation() *TaskDependencyMutation <span class="cov0" title="0">{
        return _u.mutation
}</span>

// ClearTask clears the "task" edge to the Task entity.
func (_u *TaskDependencyUpdateOne) ClearTask() *TaskDependencyUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearTask()
        return _u
}</span>

// ClearDependsOnTask clears the "depends_on_task" edge to the Task entity.
func (_u *TaskDependencyUpdateOne) ClearDependsOnTask() *TaskDependencyUpdateOne <span class="cov0" title="0">{
        _u.mutation.ClearDependsOnTask()
        return _u
}</span>

// Where appends a list predicates to the TaskDependencyUpdate builder.
func (_u *TaskDependencyUpdateOne) Where(ps ...predicate.TaskDependency) *TaskDependencyUpdateOne <span class="cov0" title="0">{
        _u.mutation.Where(ps...)
        return _u
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *TaskDependencyUpdateOne) Select(field string, fields ...string) *TaskDependencyUpdateOne <span class="cov0" title="0">{
        _u.fields = append([]string{field}, fields...)
        return _u
}</span>

// Save executes the query and returns the updated TaskDependency entity.
func (_u *TaskDependencyUpdateOne) Save(ctx context.Context) (*TaskDependency, error) <span class="cov0" title="0">{
        return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (_u *TaskDependencyUpdateOne) SaveX(ctx context.Context) *TaskDependency <span class="cov0" title="0">{
        node, err := _u.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (_u *TaskDependencyUpdateOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := _u.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (_u *TaskDependencyUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := _u.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// check runs all checks and user-defined validators on the builder.
func (_u *TaskDependencyUpdateOne) check() error <span class="cov0" title="0">{
        if _u.mutation.TaskCleared() &amp;&amp; len(_u.mutation.TaskIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "TaskDependency.task"`)
        }</span>
        <span class="cov0" title="0">if _u.mutation.DependsOnTaskCleared() &amp;&amp; len(_u.mutation.DependsOnTaskIDs()) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "TaskDependency.depends_on_task"`)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (_u *TaskDependencyUpdateOne) sqlSave(ctx context.Context) (_node *TaskDependency, err error) <span class="cov0" title="0">{
        if err := _u.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov0" title="0">_spec := sqlgraph.NewUpdateSpec(taskdependency.Table, taskdependency.Columns, sqlgraph.NewFieldSpec(taskdependency.FieldID, field.TypeUUID))
        id, ok := _u.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "TaskDependency.id" for update`)}
        }</span>
        <span class="cov0" title="0">_spec.Node.ID.Value = id
        if fields := _u.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, taskdependency.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !taskdependency.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != taskdependency.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov0" title="0">if ps := _u.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if _u.mutation.TaskCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   taskdependency.TaskTable,
                        Columns: []string{taskdependency.TaskColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.TaskIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   taskdependency.TaskTable,
                        Columns: []string{taskdependency.TaskColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if _u.mutation.DependsOnTaskCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   taskdependency.DependsOnTaskTable,
                        Columns: []string{taskdependency.DependsOnTaskColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := _u.mutation.DependsOnTaskIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: false,
                        Table:   taskdependency.DependsOnTaskTable,
                        Columns: []string{taskdependency.DependsOnTaskColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(task.FieldID, field.TypeUUID),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">_node = &amp;TaskDependency{config: _u.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{taskdependency.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">_u.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "sync"

        "entgo.io/ent/dialect"
)

// Tx is a transactional client that is created by calling Client.Tx().
type Tx struct {
        config
        // Project is the client for interacting with the Project builders.
        Project *ProjectClient
        // ProjectContext is the client for interacting with the ProjectContext builders.
        ProjectContext *ProjectContextClient
        // Task is the client for interacting with the Task builders.
        Task *TaskClient
        // TaskDependency is the client for interacting with the TaskDependency builders.
        TaskDependency *TaskDependencyClient

        // lazily loaded.
        client     *Client
        clientOnce sync.Once
        // ctx lives for the life of the transaction. It is
        // the same context used by the underlying connection.
        ctx context.Context
}

type (
        // Committer is the interface that wraps the Commit method.
        Committer interface {
                Commit(context.Context, *Tx) error
        }

        // The CommitFunc type is an adapter to allow the use of ordinary
        // function as a Committer. If f is a function with the appropriate
        // signature, CommitFunc(f) is a Committer that calls f.
        CommitFunc func(context.Context, *Tx) error

        // CommitHook defines the "commit middleware". A function that gets a Committer
        // and returns a Committer. For example:
        //
        //        hook := func(next ent.Committer) ent.Committer {
        //                return ent.CommitFunc(func(ctx context.Context, tx *ent.Tx) error {
        //                        // Do some stuff before.
        //                        if err := next.Commit(ctx, tx); err != nil {
        //                                return err
        //                        }
        //                        // Do some stuff after.
        //                        return nil
        //                })
        //        }
        //
        CommitHook func(Committer) Committer
)

// Commit calls f(ctx, m).
func (f CommitFunc) Commit(ctx context.Context, tx *Tx) error <span class="cov0" title="0">{
        return f(ctx, tx)
}</span>

// Commit commits the transaction.
func (tx *Tx) Commit() error <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        var fn Committer = CommitFunc(func(context.Context, *Tx) error </span><span class="cov0" title="0">{
                return txDriver.tx.Commit()
        }</span>)
        <span class="cov0" title="0">txDriver.mu.Lock()
        hooks := append([]CommitHook(nil), txDriver.onCommit...)
        txDriver.mu.Unlock()
        for i := len(hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                fn = hooks[i](fn)
        }</span>
        <span class="cov0" title="0">return fn.Commit(tx.ctx, tx)</span>
}

// OnCommit adds a hook to call on commit.
func (tx *Tx) OnCommit(f CommitHook) <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        txDriver.mu.Lock()
        txDriver.onCommit = append(txDriver.onCommit, f)
        txDriver.mu.Unlock()
}</span>

type (
        // Rollbacker is the interface that wraps the Rollback method.
        Rollbacker interface {
                Rollback(context.Context, *Tx) error
        }

        // The RollbackFunc type is an adapter to allow the use of ordinary
        // function as a Rollbacker. If f is a function with the appropriate
        // signature, RollbackFunc(f) is a Rollbacker that calls f.
        RollbackFunc func(context.Context, *Tx) error

        // RollbackHook defines the "rollback middleware". A function that gets a Rollbacker
        // and returns a Rollbacker. For example:
        //
        //        hook := func(next ent.Rollbacker) ent.Rollbacker {
        //                return ent.RollbackFunc(func(ctx context.Context, tx *ent.Tx) error {
        //                        // Do some stuff before.
        //                        if err := next.Rollback(ctx, tx); err != nil {
        //                                return err
        //                        }
        //                        // Do some stuff after.
        //                        return nil
        //                })
        //        }
        //
        RollbackHook func(Rollbacker) Rollbacker
)

// Rollback calls f(ctx, m).
func (f RollbackFunc) Rollback(ctx context.Context, tx *Tx) error <span class="cov0" title="0">{
        return f(ctx, tx)
}</span>

// Rollback rollbacks the transaction.
func (tx *Tx) Rollback() error <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        var fn Rollbacker = RollbackFunc(func(context.Context, *Tx) error </span><span class="cov0" title="0">{
                return txDriver.tx.Rollback()
        }</span>)
        <span class="cov0" title="0">txDriver.mu.Lock()
        hooks := append([]RollbackHook(nil), txDriver.onRollback...)
        txDriver.mu.Unlock()
        for i := len(hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                fn = hooks[i](fn)
        }</span>
        <span class="cov0" title="0">return fn.Rollback(tx.ctx, tx)</span>
}

// OnRollback adds a hook to call on rollback.
func (tx *Tx) OnRollback(f RollbackHook) <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        txDriver.mu.Lock()
        txDriver.onRollback = append(txDriver.onRollback, f)
        txDriver.mu.Unlock()
}</span>

// Client returns a Client that binds to current transaction.
func (tx *Tx) Client() *Client <span class="cov0" title="0">{
        tx.clientOnce.Do(func() </span><span class="cov0" title="0">{
                tx.client = &amp;Client{config: tx.config}
                tx.client.init()
        }</span>)
        <span class="cov0" title="0">return tx.client</span>
}

func (tx *Tx) init() <span class="cov0" title="0">{
        tx.Project = NewProjectClient(tx.config)
        tx.ProjectContext = NewProjectContextClient(tx.config)
        tx.Task = NewTaskClient(tx.config)
        tx.TaskDependency = NewTaskDependencyClient(tx.config)
}</span>

// txDriver wraps the given dialect.Tx with a nop dialect.Driver implementation.
// The idea is to support transactions without adding any extra code to the builders.
// When a builder calls to driver.Tx(), it gets the same dialect.Tx instance.
// Commit and Rollback are nop for the internal builders and the user must call one
// of them in order to commit or rollback the transaction.
//
// If a closed transaction is embedded in one of the generated entities, and the entity
// applies a query, for example: Project.QueryXXX(), the query will be executed
// through the driver which created this transaction.
//
// Note that txDriver is not goroutine safe.
type txDriver struct {
        // the driver we started the transaction from.
        drv dialect.Driver
        // tx is the underlying transaction.
        tx dialect.Tx
        // completion hooks.
        mu         sync.Mutex
        onCommit   []CommitHook
        onRollback []RollbackHook
}

// newTx creates a new transactional driver.
func newTx(ctx context.Context, drv dialect.Driver) (*txDriver, error) <span class="cov0" title="0">{
        tx, err := drv.Tx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;txDriver{tx: tx, drv: drv}, nil</span>
}

// Tx returns the transaction wrapper (txDriver) to avoid Commit or Rollback calls
// from the internal builders. Should be called only by the internal builders.
func (tx *txDriver) Tx(context.Context) (dialect.Tx, error) <span class="cov0" title="0">{ return tx, nil }</span>

// Dialect returns the dialect of the driver we started the transaction from.
func (tx *txDriver) Dialect() string <span class="cov0" title="0">{ return tx.drv.Dialect() }</span>

// Close is a nop close.
func (*txDriver) Close() error <span class="cov0" title="0">{ return nil }</span>

// Commit is a nop commit for the internal builders.
// User must call `Tx.Commit` in order to commit the transaction.
func (*txDriver) Commit() error <span class="cov0" title="0">{ return nil }</span>

// Rollback is a nop rollback for the internal builders.
// User must call `Tx.Rollback` in order to rollback the transaction.
func (*txDriver) Rollback() error <span class="cov0" title="0">{ return nil }</span>

// Exec calls tx.Exec.
func (tx *txDriver) Exec(ctx context.Context, query string, args, v any) error <span class="cov0" title="0">{
        return tx.tx.Exec(ctx, query, args, v)
}</span>

// Query calls tx.Query.
func (tx *txDriver) Query(ctx context.Context, query string, args, v any) error <span class="cov0" title="0">{
        return tx.tx.Query(ctx, query, args, v)
}</span>

var _ dialect.Driver = (*txDriver)(nil)
</pre>
		
		<pre class="file" id="file72" style="display: none">package sqlite

import (
        "errors"
        "fmt"
)

// RepositoryError represents a repository operation error
type RepositoryError struct {
        Type    ErrorType
        Message string
        Cause   error
}

// ErrorType represents different types of repository errors
type ErrorType int

const (
        ErrorTypeNotFound ErrorType = iota
        ErrorTypeConstraintViolation
        ErrorTypeCircularDependency
        ErrorTypeMaxDepthExceeded
        ErrorTypeMaxTasksExceeded
        ErrorTypeConnectionError
        ErrorTypeTransactionError
        ErrorTypeMigrationError
        ErrorTypeValidationError
)

// Error returns the error message
func (e *RepositoryError) Error() string <span class="cov0" title="0">{
        if e.Cause != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %v", e.Message, e.Cause)
        }</span>
        <span class="cov0" title="0">return e.Message</span>
}

// Unwrap returns the underlying error
func (e *RepositoryError) Unwrap() error <span class="cov0" title="0">{
        return e.Cause
}</span>

// Is checks if the error is of a specific type
func (e *RepositoryError) Is(target error) bool <span class="cov0" title="0">{
        if re, ok := target.(*RepositoryError); ok </span><span class="cov0" title="0">{
                return e.Type == re.Type
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Helper functions for creating specific errors

// NewNotFoundError creates a new not found error
func NewNotFoundError(entity string, id string) *RepositoryError <span class="cov8" title="1">{
        return &amp;RepositoryError{
                Type:    ErrorTypeNotFound,
                Message: fmt.Sprintf("%s with ID %s not found", entity, id),
        }
}</span>

// NewConstraintViolationError creates a new constraint violation error
func NewConstraintViolationError(constraint string, cause error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Type:    ErrorTypeConstraintViolation,
                Message: fmt.Sprintf("constraint violation: %s", constraint),
                Cause:   cause,
        }
}</span>

// NewCircularDependencyError creates a new circular dependency error
func NewCircularDependencyError(message string) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Type:    ErrorTypeCircularDependency,
                Message: message,
        }
}</span>

// NewMaxDepthExceededError creates a new max depth exceeded error
func NewMaxDepthExceededError(maxDepth int) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Type:    ErrorTypeMaxDepthExceeded,
                Message: fmt.Sprintf("maximum task depth of %d exceeded", maxDepth),
        }
}</span>

// NewMaxTasksExceededError creates a new max tasks exceeded error
func NewMaxTasksExceededError(maxTasks int) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Type:    ErrorTypeMaxTasksExceeded,
                Message: fmt.Sprintf("maximum number of tasks (%d) exceeded", maxTasks),
        }
}</span>

// NewConnectionError creates a new connection error
func NewConnectionError(message string, cause error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Type:    ErrorTypeConnectionError,
                Message: message,
                Cause:   cause,
        }
}</span>

// NewTransactionError creates a new transaction error
func NewTransactionError(message string, cause error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Type:    ErrorTypeTransactionError,
                Message: message,
                Cause:   cause,
        }
}</span>

// NewMigrationError creates a new migration error
func NewMigrationError(message string, cause error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Type:    ErrorTypeMigrationError,
                Message: message,
                Cause:   cause,
        }
}</span>

// NewValidationError creates a new validation error
func NewValidationError(message string, cause error) *RepositoryError <span class="cov0" title="0">{
        return &amp;RepositoryError{
                Type:    ErrorTypeValidationError,
                Message: message,
                Cause:   cause,
        }
}</span>

// Error type check helpers

// IsNotFoundError checks if an error is a not found error
func IsNotFoundError(err error) bool <span class="cov0" title="0">{
        var re *RepositoryError
        return errors.As(err, &amp;re) &amp;&amp; re.Type == ErrorTypeNotFound
}</span>

// IsConstraintViolationError checks if an error is a constraint violation error
func IsConstraintViolationError(err error) bool <span class="cov0" title="0">{
        var re *RepositoryError
        return errors.As(err, &amp;re) &amp;&amp; re.Type == ErrorTypeConstraintViolation
}</span>

// IsCircularDependencyError checks if an error is a circular dependency error
func IsCircularDependencyError(err error) bool <span class="cov0" title="0">{
        var re *RepositoryError
        return errors.As(err, &amp;re) &amp;&amp; re.Type == ErrorTypeCircularDependency
}</span>

// IsMaxDepthExceededError checks if an error is a max depth exceeded error
func IsMaxDepthExceededError(err error) bool <span class="cov0" title="0">{
        var re *RepositoryError
        return errors.As(err, &amp;re) &amp;&amp; re.Type == ErrorTypeMaxDepthExceeded
}</span>

// IsMaxTasksExceededError checks if an error is a max tasks exceeded error
func IsMaxTasksExceededError(err error) bool <span class="cov0" title="0">{
        var re *RepositoryError
        return errors.As(err, &amp;re) &amp;&amp; re.Type == ErrorTypeMaxTasksExceeded
}</span>

// IsConnectionError checks if an error is a connection error
func IsConnectionError(err error) bool <span class="cov0" title="0">{
        var re *RepositoryError
        return errors.As(err, &amp;re) &amp;&amp; re.Type == ErrorTypeConnectionError
}</span>

// IsTransactionError checks if an error is a transaction error
func IsTransactionError(err error) bool <span class="cov0" title="0">{
        var re *RepositoryError
        return errors.As(err, &amp;re) &amp;&amp; re.Type == ErrorTypeTransactionError
}</span>

// IsMigrationError checks if an error is a migration error
func IsMigrationError(err error) bool <span class="cov0" title="0">{
        var re *RepositoryError
        return errors.As(err, &amp;re) &amp;&amp; re.Type == ErrorTypeMigrationError
}</span>

// IsValidationError checks if an error is a validation error
func IsValidationError(err error) bool <span class="cov0" title="0">{
        var re *RepositoryError
        return errors.As(err, &amp;re) &amp;&amp; re.Type == ErrorTypeValidationError
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package sqlite

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "go.uber.org/zap"
)

// HealthStatus represents the health status of the database connection
type HealthStatus struct {
        Healthy          bool          `json:"healthy"`
        ConnectionActive bool          `json:"connection_active"`
        PingLatency      time.Duration `json:"ping_latency"`
        OpenConnections  int           `json:"open_connections"`
        IdleConnections  int           `json:"idle_connections"`
        InUseConnections int           `json:"in_use_connections"`
        ErrorMessage     string        `json:"error_message,omitempty"`
        LastChecked      time.Time     `json:"last_checked"`
        DatabasePath     string        `json:"database_path"`
        WALModeEnabled   bool          `json:"wal_mode_enabled"`
        ForeignKeys      bool          `json:"foreign_keys_enabled"`
}

// HealthCheck performs a comprehensive health check of the database connection
func (r *sqliteRepository) HealthCheck(ctx context.Context) (*HealthStatus, error) <span class="cov0" title="0">{
        status := &amp;HealthStatus{
                LastChecked:  time.Now(),
                DatabasePath: r.config.DatabasePath,
        }

        // Get underlying database connection
        db, err := r.getUnderlyingDB()
        if err != nil </span><span class="cov0" title="0">{
                status.ErrorMessage = fmt.Sprintf("failed to get database connection: %v", err)
                return status, nil
        }</span>

        // Test basic connectivity with ping
        <span class="cov0" title="0">start := time.Now()
        if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                status.ErrorMessage = fmt.Sprintf("ping failed: %v", err)
                return status, nil
        }</span>
        <span class="cov0" title="0">status.PingLatency = time.Since(start)
        status.ConnectionActive = true

        // Get connection pool statistics
        stats := db.Stats()
        status.OpenConnections = stats.OpenConnections
        status.IdleConnections = stats.Idle
        status.InUseConnections = stats.InUse

        // Test basic query execution
        if err := r.testBasicQuery(ctx, db); err != nil </span><span class="cov0" title="0">{
                status.ErrorMessage = fmt.Sprintf("basic query test failed: %v", err)
                return status, nil
        }</span>

        // Check SQLite-specific settings
        <span class="cov0" title="0">if err := r.checkSQLiteSettings(ctx, db, status); err != nil </span><span class="cov0" title="0">{
                r.config.Logger.Warn("Failed to check SQLite settings", zap.Error(err))
                // Don't fail health check for settings check failure
        }</span>

        <span class="cov0" title="0">status.Healthy = true
        return status, nil</span>
}

// Ping performs a simple connectivity test
func (r *sqliteRepository) Ping(ctx context.Context) error <span class="cov0" title="0">{
        db, err := r.getUnderlyingDB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get database connection: %w", err)
        }</span>

        <span class="cov0" title="0">return db.PingContext(ctx)</span>
}

// ValidateConnection performs a comprehensive connection validation
func (r *sqliteRepository) ValidateConnection(ctx context.Context) error <span class="cov0" title="0">{
        health, err := r.HealthCheck(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !health.Healthy </span><span class="cov0" title="0">{
                return fmt.Errorf("database connection unhealthy: %s", health.ErrorMessage)
        }</span>

        // Additional validations
        <span class="cov0" title="0">if health.PingLatency &gt; time.Second </span><span class="cov0" title="0">{
                r.config.Logger.Warn("High database latency detected", 
                        zap.Duration("latency", health.PingLatency))
        }</span>

        <span class="cov0" title="0">if health.OpenConnections == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no active database connections")
        }</span>

        <span class="cov0" title="0">r.config.Logger.Info("Database connection validation successful",
                zap.Duration("ping_latency", health.PingLatency),
                zap.Int("open_connections", health.OpenConnections),
                zap.Bool("wal_mode", health.WALModeEnabled))

        return nil</span>
}

// getUnderlyingDB extracts the underlying sql.DB from ent client
func (r *sqliteRepository) getUnderlyingDB() (*sql.DB, error) <span class="cov0" title="0">{
        if r.client == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ent client not initialized")
        }</span>

        // For now, we'll use a simpler approach - test through ent client
        // TODO: Find a way to access underlying sql.DB if needed for advanced health checks
        <span class="cov0" title="0">return nil, fmt.Errorf("direct database access not available through ent client")</span>
}

// testBasicQuery tests basic database functionality
func (r *sqliteRepository) testBasicQuery(ctx context.Context, db *sql.DB) error <span class="cov0" title="0">{
        // Test a simple SELECT query
        var result int
        err := db.QueryRowContext(ctx, "SELECT 1").Scan(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("basic query failed: %w", err)
        }</span>

        <span class="cov0" title="0">if result != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected query result: got %d, expected 1", result)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkSQLiteSettings verifies SQLite-specific configuration
func (r *sqliteRepository) checkSQLiteSettings(ctx context.Context, db *sql.DB, status *HealthStatus) error <span class="cov0" title="0">{
        settings := []struct {
                name     string
                query    string
                expected string
                field    *bool
        }{
                {"journal_mode", "PRAGMA journal_mode", "wal", &amp;status.WALModeEnabled},
                {"foreign_keys", "PRAGMA foreign_keys", "1", &amp;status.ForeignKeys},
        }

        for _, setting := range settings </span><span class="cov0" title="0">{
                var value string
                err := db.QueryRowContext(ctx, setting.query).Scan(&amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        r.config.Logger.Warn("Failed to check SQLite setting",
                                zap.String("setting", setting.name),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if setting.field != nil </span><span class="cov0" title="0">{
                        *setting.field = (value == setting.expected)
                }</span>

                <span class="cov0" title="0">r.config.Logger.Debug("SQLite setting checked",
                        zap.String("setting", setting.name),
                        zap.String("value", value),
                        zap.String("expected", setting.expected))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// MonitorConnection starts a background health monitoring routine
func (r *sqliteRepository) MonitorConnection(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        r.config.Logger.Info("Database connection monitoring stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        health, err := r.HealthCheck(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                r.config.Logger.Error("Health check failed", zap.Error(err))
                                continue</span>
                        }

                        <span class="cov0" title="0">if !health.Healthy </span><span class="cov0" title="0">{
                                r.config.Logger.Error("Database connection unhealthy",
                                        zap.String("error", health.ErrorMessage),
                                        zap.Duration("ping_latency", health.PingLatency))
                        }</span> else<span class="cov0" title="0"> {
                                r.config.Logger.Debug("Database connection healthy",
                                        zap.Duration("ping_latency", health.PingLatency),
                                        zap.Int("open_connections", health.OpenConnections))
                        }</span>
                }
        }
}</pre>
		
		<pre class="file" id="file74" style="display: none">package sqlite

import (
        "github.com/denkhaus/knot/internal/repository/sqlite/ent"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
)

// Project entity mapping functions

// entProjectToProject converts ent Project entity to domain Project model
func entProjectToProject(ep *ent.Project) *types.Project <span class="cov8" title="1">{
        return &amp;types.Project{
                ID:             ep.ID,
                Title:          ep.Title,
                Description:    ep.Description,
                State:          entStateToProjectState(string(ep.State)),
                CreatedAt:      ep.CreatedAt,
                UpdatedAt:      ep.UpdatedAt,
                TotalTasks:     ep.TotalTasks,
                CompletedTasks: ep.CompletedTasks,
                Progress:       ep.Progress,
        }
}</span>

// projectToEntProjectCreate converts domain Project model to ent ProjectCreate
func projectToEntProjectCreate(p *types.Project, client *ent.Client) *ent.ProjectCreate <span class="cov8" title="1">{
        create := client.Project.Create().
                SetTitle(p.Title).
                SetDescription(p.Description).
                SetState(projectStateToEntState(p.State))

        if p.ID != uuid.Nil </span><span class="cov8" title="1">{
                create.SetID(p.ID)
        }</span>
        <span class="cov8" title="1">if !p.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                create.SetCreatedAt(p.CreatedAt)
        }</span>
        <span class="cov8" title="1">if !p.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                create.SetUpdatedAt(p.UpdatedAt)
        }</span>
        <span class="cov8" title="1">if p.TotalTasks &gt; 0 </span><span class="cov0" title="0">{
                create.SetTotalTasks(p.TotalTasks)
        }</span>
        <span class="cov8" title="1">if p.CompletedTasks &gt; 0 </span><span class="cov0" title="0">{
                create.SetCompletedTasks(p.CompletedTasks)
        }</span>
        <span class="cov8" title="1">if p.Progress &gt; 0 </span><span class="cov0" title="0">{
                create.SetProgress(p.Progress)
        }</span>

        <span class="cov8" title="1">return create</span>
}

// Task entity mapping functions

// entTaskToTask converts ent Task entity to domain Task model
func entTaskToTask(et *ent.Task) *types.Task <span class="cov8" title="1">{
        domainTask := &amp;types.Task{
                ID:          et.ID,
                ProjectID:   et.ProjectID,
                Title:       et.Title,
                Description: et.Description,
                State:       types.TaskState(et.State),
                Priority:    types.TaskPriority(et.Priority),
                Complexity:  et.Complexity,
                Depth:       et.Depth,
                CreatedAt:   et.CreatedAt,
                UpdatedAt:   et.UpdatedAt,
        }

        // Handle optional/nullable fields
        if et.ParentID != nil </span><span class="cov0" title="0">{
                domainTask.ParentID = et.ParentID
        }</span>
        <span class="cov8" title="1">if et.Estimate != nil </span><span class="cov0" title="0">{
                domainTask.Estimate = et.Estimate
        }</span>
        <span class="cov8" title="1">if et.AssignedAgent != nil </span><span class="cov0" title="0">{
                domainTask.AssignedAgent = et.AssignedAgent
        }</span>
        <span class="cov8" title="1">if et.CompletedAt != nil </span><span class="cov0" title="0">{
                domainTask.CompletedAt = et.CompletedAt
        }</span>

        // Initialize slices to avoid nil pointer issues
        <span class="cov8" title="1">domainTask.Dependencies = make([]uuid.UUID, 0)
        domainTask.Dependents = make([]uuid.UUID, 0)

        return domainTask</span>
}

// taskToEntTaskCreate converts domain Task model to ent TaskCreate
func taskToEntTaskCreate(t *types.Task, client *ent.Client) *ent.TaskCreate <span class="cov8" title="1">{
        create := client.Task.Create().
                SetProjectID(t.ProjectID).
                SetTitle(t.Title).
                SetDescription(t.Description).
                SetState(task.State(t.State)).
                SetPriority(task.Priority(t.Priority)).
                SetComplexity(t.Complexity).
                SetDepth(t.Depth)

        if t.ID != uuid.Nil </span><span class="cov8" title="1">{
                create.SetID(t.ID)
        }</span>
        <span class="cov8" title="1">if t.ParentID != nil </span><span class="cov0" title="0">{
                create.SetParentID(*t.ParentID)
        }</span>
        <span class="cov8" title="1">if t.Estimate != nil </span><span class="cov0" title="0">{
                create.SetEstimate(*t.Estimate)
        }</span>
        <span class="cov8" title="1">if t.AssignedAgent != nil </span><span class="cov0" title="0">{
                create.SetAssignedAgent(*t.AssignedAgent)
        }</span>
        <span class="cov8" title="1">if !t.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                create.SetCreatedAt(t.CreatedAt)
        }</span>
        <span class="cov8" title="1">if !t.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                create.SetUpdatedAt(t.UpdatedAt)
        }</span>
        <span class="cov8" title="1">if t.CompletedAt != nil </span><span class="cov0" title="0">{
                create.SetCompletedAt(*t.CompletedAt)
        }</span>

        <span class="cov8" title="1">return create</span>
}

// taskToEntTaskUpdate converts domain Task model to ent TaskUpdateOne
func taskToEntTaskUpdate(t *types.Task, update *ent.TaskUpdateOne) *ent.TaskUpdateOne <span class="cov8" title="1">{
        update = update.
                SetTitle(t.Title).
                SetDescription(t.Description).
                SetState(task.State(t.State)).
                SetPriority(task.Priority(t.Priority)).
                SetComplexity(t.Complexity).
                SetUpdatedAt(t.UpdatedAt)

        if t.Estimate != nil </span><span class="cov0" title="0">{
                update.SetEstimate(*t.Estimate)
        }</span> else<span class="cov8" title="1"> {
                update.ClearEstimate()
        }</span>

        <span class="cov8" title="1">if t.AssignedAgent != nil </span><span class="cov0" title="0">{
                update.SetAssignedAgent(*t.AssignedAgent)
        }</span> else<span class="cov8" title="1"> {
                update.ClearAssignedAgent()
        }</span>

        <span class="cov8" title="1">if t.CompletedAt != nil </span><span class="cov0" title="0">{
                update.SetCompletedAt(*t.CompletedAt)
        }</span> else<span class="cov8" title="1"> {
                update.ClearCompletedAt()
        }</span>

        <span class="cov8" title="1">return update</span>
}

// TaskDependency entity mapping functions

// entTaskDependenciesToTaskIDs extracts task IDs from ent TaskDependency entities
func entTaskDependenciesToTaskIDs(dependencies []*ent.TaskDependency) []uuid.UUID <span class="cov8" title="1">{
        ids := make([]uuid.UUID, len(dependencies))
        for i, dep := range dependencies </span><span class="cov0" title="0">{
                ids[i] = dep.DependsOnTaskID
        }</span>
        <span class="cov8" title="1">return ids</span>
}

// entTaskDependentsToTaskIDs extracts dependent task IDs from ent TaskDependency entities
func entTaskDependentsToTaskIDs(dependents []*ent.TaskDependency) []uuid.UUID <span class="cov8" title="1">{
        ids := make([]uuid.UUID, len(dependents))
        for i, dep := range dependents </span><span class="cov0" title="0">{
                ids[i] = dep.TaskID
        }</span>
        <span class="cov8" title="1">return ids</span>
}

// Helper functions for slice conversions

// entProjectsToProjects converts slice of ent Projects to domain Projects
func entProjectsToProjects(entProjects []*ent.Project) []*types.Project <span class="cov8" title="1">{
        projects := make([]*types.Project, len(entProjects))
        for i, ep := range entProjects </span><span class="cov8" title="1">{
                projects[i] = entProjectToProject(ep)
        }</span>
        <span class="cov8" title="1">return projects</span>
}

// entTasksToTasks converts slice of ent Tasks to domain Tasks
// Currently unused but kept for potential future use
// func entTasksToTasks(entTasks []*ent.Task) []*types.Task {
//         tasks := make([]*types.Task, len(entTasks))
//         for i, et := range entTasks {
//                 tasks[i] = entTaskToTask(et)
//         }
//         return tasks
// }

// Helper functions for filtering

// filterMatchesTaskFilter checks if an ent Task matches the given TaskFilter
// Currently unused but kept for potential future use
// func filterMatchesTaskFilter(task *ent.Task, filter types.TaskFilter) bool {
//         if filter.ProjectID != nil &amp;&amp; task.ProjectID != *filter.ProjectID {
//                 return false
//         }
//         if filter.ParentID != nil {
//                 if task.ParentID == nil &amp;&amp; *filter.ParentID != uuid.Nil {
//                         return false
//                 }
//                 if task.ParentID != nil &amp;&amp; *task.ParentID != *filter.ParentID {
//                         return false
//                 }
//         }
//         if filter.State != nil &amp;&amp; types.TaskState(task.State) != *filter.State {
//                 return false
//         }
//         if filter.Priority != nil &amp;&amp; types.TaskPriority(task.Priority) != *filter.Priority {
//                 return false
//         }
//         if filter.MinDepth != nil &amp;&amp; task.Depth &lt; *filter.MinDepth {
//                 return false
//         }
//         if filter.MaxDepth != nil &amp;&amp; task.Depth &gt; *filter.MaxDepth {
//                 return false
//         }
//         if filter.MinComplexity != nil &amp;&amp; task.Complexity &lt; *filter.MinComplexity {
//                 return false
//         }
//         if filter.MaxComplexity != nil &amp;&amp; task.Complexity &gt; *filter.MaxComplexity {
//                 return false
//         }
//         return true
// }

// Project state conversion functions

// projectStateToEntState converts domain ProjectState to ent project state
func projectStateToEntState(state types.ProjectState) project.State <span class="cov8" title="1">{
        switch state </span>{
        case types.ProjectStateActive:<span class="cov0" title="0">
                return project.StateActive</span>
        case types.ProjectStateCompleted:<span class="cov0" title="0">
                return project.StateCompleted</span>
        case types.ProjectStateArchived:<span class="cov0" title="0">
                return project.StateArchived</span>
        case types.ProjectStateDeletionPending:<span class="cov0" title="0">
                return project.StateDeletionPending</span>
        default:<span class="cov8" title="1">
                return project.StateActive</span> // Default to active for empty/unknown states
        }
}

// entStateToProjectState converts ent project state to domain ProjectState
func entStateToProjectState(state string) types.ProjectState <span class="cov8" title="1">{
        switch state </span>{
        case "active":<span class="cov8" title="1">
                return types.ProjectStateActive</span>
        case "completed":<span class="cov0" title="0">
                return types.ProjectStateCompleted</span>
        case "archived":<span class="cov0" title="0">
                return types.ProjectStateArchived</span>
        case "deletion-pending":<span class="cov0" title="0">
                return types.ProjectStateDeletionPending</span>
        default:<span class="cov0" title="0">
                return types.ProjectStateActive</span> // Default to active for unknown states
        }
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package sqlite

import (
        "time"

        "go.uber.org/zap"
)

// Config holds configuration for the SQLite repository
type Config struct {
        // Database connection settings
        DatabasePath    string
        MaxOpenConns    int
        MaxIdleConns    int
        ConnMaxLifetime time.Duration
        ConnMaxIdleTime time.Duration

        // Migration settings
        AutoMigrate      bool
        MigrationTimeout time.Duration
        Logger           *zap.Logger
}

// DefaultConfig returns a default configuration optimized for SQLite
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                DatabasePath:     "",
                // SQLite optimized connection pool settings:
                // SQLite works best with limited concurrent connections due to file locking
                MaxOpenConns:     1,  // SQLite is single-writer, multiple readers - limit to 1 for writes
                MaxIdleConns:     1,  // Keep 1 idle connection to avoid reconnection overhead
                ConnMaxLifetime:  0,  // No connection lifetime limit for SQLite (file-based)
                ConnMaxIdleTime:  time.Minute * 30, // Longer idle time for file-based DB
                AutoMigrate:      true,
                MigrationTimeout: time.Minute * 5,
                Logger:           zap.NewNop(),
        }
}</span>

// Option is a function that configures a SQLite repository
type Option func(*sqliteRepository)

// WithConfig sets the entire configuration
func WithConfig(config *Config) Option <span class="cov0" title="0">{
        return func(r *sqliteRepository) </span><span class="cov0" title="0">{
                r.config = config
        }</span>
}

// WithDatabasePath sets the database file path
func WithDatabasePath(path string) Option <span class="cov8" title="1">{
        return func(r *sqliteRepository) </span><span class="cov8" title="1">{
                r.config.DatabasePath = path
        }</span>
}

// WithLogger sets a logger for debugging reasons
func WithLogger(logger *zap.Logger) Option <span class="cov8" title="1">{
        return func(r *sqliteRepository) </span><span class="cov8" title="1">{
                r.config.Logger = logger
        }</span>
}

// WithAutoMigrate enables or disables auto-migration
func WithAutoMigrate(enable bool) Option <span class="cov8" title="1">{
        return func(r *sqliteRepository) </span><span class="cov8" title="1">{
                r.config.AutoMigrate = enable
        }</span>
}

// WithConnectionPool configures the connection pool
func WithConnectionPool(maxOpen, maxIdle int) Option <span class="cov8" title="1">{
        return func(r *sqliteRepository) </span><span class="cov8" title="1">{
                r.config.MaxOpenConns = maxOpen
                r.config.MaxIdleConns = maxIdle
        }</span>
}

// WithConnectionLifetime configures connection lifetimes
func WithConnectionLifetime(maxLifetime, maxIdleTime time.Duration) Option <span class="cov8" title="1">{
        return func(r *sqliteRepository) </span><span class="cov8" title="1">{
                r.config.ConnMaxLifetime = maxLifetime
                r.config.ConnMaxIdleTime = maxIdleTime
        }</span>
}

// WithMigrationTimeout sets the migration timeout
func WithMigrationTimeout(timeout time.Duration) Option <span class="cov0" title="0">{
        return func(r *sqliteRepository) </span><span class="cov0" title="0">{
                r.config.MigrationTimeout = timeout
        }</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package sqlite

import (
        "os"
        "runtime"
        "strconv"
        "time"
)

// OptimizedConfig returns SQLite-optimized configuration based on environment and workload
func OptimizedConfig() *Config <span class="cov8" title="1">{
        config := DefaultConfig()
        
        // Check for environment variable overrides
        if maxOpenStr := os.Getenv("KNOT_SQLITE_MAX_OPEN_CONNS"); maxOpenStr != "" </span><span class="cov0" title="0">{
                if maxOpen, err := strconv.Atoi(maxOpenStr); err == nil &amp;&amp; maxOpen &gt; 0 </span><span class="cov0" title="0">{
                        config.MaxOpenConns = maxOpen
                }</span>
        }
        
        <span class="cov8" title="1">if maxIdleStr := os.Getenv("KNOT_SQLITE_MAX_IDLE_CONNS"); maxIdleStr != "" </span><span class="cov0" title="0">{
                if maxIdle, err := strconv.Atoi(maxIdleStr); err == nil &amp;&amp; maxIdle &gt; 0 </span><span class="cov0" title="0">{
                        config.MaxIdleConns = maxIdle
                }</span>
        }
        
        // Auto-tune based on system resources and workload patterns
        <span class="cov8" title="1">config = autoTuneForSQLite(config)
        
        return config</span>
}

// autoTuneForSQLite optimizes connection pool settings for SQLite workloads
func autoTuneForSQLite(config *Config) *Config <span class="cov8" title="1">{
        numCPU := runtime.NumCPU()
        
        // SQLite connection pool optimization rules:
        // 1. SQLite uses file-level locking, so too many connections can cause contention
        // 2. Read operations can be concurrent, but writes are serialized
        // 3. WAL mode allows better concurrency than default journal mode
        
        // For read-heavy workloads, allow more connections
        // For write-heavy workloads, keep it minimal
        if config.MaxOpenConns == 1 </span><span class="cov8" title="1">{ // Only auto-tune if using default
                // Conservative approach: limit to CPU count but cap at reasonable maximum
                readConnections := min(numCPU, 4)
                config.MaxOpenConns = readConnections
                config.MaxIdleConns = min(readConnections/2, 2)
        }</span>
        
        // Optimize connection lifetimes for SQLite
        <span class="cov8" title="1">if config.ConnMaxLifetime == 0 </span><span class="cov8" title="1">{
                // SQLite doesn't need connection rotation like network databases
                config.ConnMaxLifetime = 0 // Unlimited lifetime
        }</span>
        
        // Longer idle time for file-based databases
        <span class="cov8" title="1">if config.ConnMaxIdleTime == time.Minute*30 </span><span class="cov8" title="1">{
                config.ConnMaxIdleTime = time.Hour // Keep connections longer
        }</span>
        
        <span class="cov8" title="1">return config</span>
}

// GetWorkloadOptimizedConfig returns configuration optimized for specific workload patterns
func GetWorkloadOptimizedConfig(workloadType WorkloadType) *Config <span class="cov0" title="0">{
        config := DefaultConfig()
        
        switch workloadType </span>{
        case WorkloadReadHeavy:<span class="cov0" title="0">
                // Optimize for read-heavy workloads (CLI queries, reports)
                config.MaxOpenConns = min(runtime.NumCPU(), 6)
                config.MaxIdleConns = 3
                config.ConnMaxIdleTime = time.Hour</span>
                
        case WorkloadWriteHeavy:<span class="cov0" title="0">
                // Optimize for write-heavy workloads (bulk operations, imports)
                config.MaxOpenConns = 1 // SQLite serializes writes anyway
                config.MaxIdleConns = 1
                config.ConnMaxIdleTime = time.Minute * 15</span>
                
        case WorkloadMixed:<span class="cov0" title="0">
                // Balanced configuration for mixed workloads
                config.MaxOpenConns = min(runtime.NumCPU()/2+1, 3)
                config.MaxIdleConns = 2
                config.ConnMaxIdleTime = time.Minute * 30</span>
                
        case WorkloadBatch:<span class="cov0" title="0">
                // Optimize for batch processing
                config.MaxOpenConns = 1 // Single connection for consistency
                config.MaxIdleConns = 1
                config.ConnMaxLifetime = 0 // Long-running operations
                config.ConnMaxIdleTime = time.Hour * 2</span>
        }
        
        <span class="cov0" title="0">return config</span>
}

// WorkloadType defines different database workload patterns
type WorkloadType int

const (
        WorkloadReadHeavy WorkloadType = iota // Mostly SELECT operations
        WorkloadWriteHeavy                    // Mostly INSERT/UPDATE/DELETE operations  
        WorkloadMixed                         // Balanced read/write operations
        WorkloadBatch                         // Long-running batch operations
)

// min returns the minimum of two integers
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}</pre>
		
		<pre class="file" id="file77" style="display: none">package sqlite

import (
        "context"
        "fmt"

        "github.com/denkhaus/knot/internal/repository/sqlite/ent"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/projectcontext"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
)

// Project CRUD Operations

func (r *sqliteRepository) CreateProject(ctx context.Context, project *types.Project) error <span class="cov8" title="1">{
        _, err := projectToEntProjectCreate(project, r.client).Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return r.mapError("create project", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetProject retrieves a project by ID using ent
func (r *sqliteRepository) GetProject(ctx context.Context, id uuid.UUID) (*types.Project, error) <span class="cov8" title="1">{
        entProject, err := r.client.Project.Get(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                if ent.IsNotFound(err) </span><span class="cov8" title="1">{
                        return nil, NewNotFoundError("project", id.String())
                }</span>
                <span class="cov0" title="0">return nil, r.mapError("get project", err)</span>
        }
        <span class="cov8" title="1">return entProjectToProject(entProject), nil</span>
}

// UpdateProject updates an existing project using ent
func (r *sqliteRepository) UpdateProject(ctx context.Context, project *types.Project) error <span class="cov8" title="1">{
        err := r.client.Project.UpdateOneID(project.ID).
                SetTitle(project.Title).
                SetDescription(project.Description).
                SetState(projectStateToEntState(project.State)).
                SetUpdatedAt(project.UpdatedAt).
                SetTotalTasks(project.TotalTasks).
                SetCompletedTasks(project.CompletedTasks).
                SetProgress(project.Progress).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                        return NewNotFoundError("project", project.ID.String())
                }</span>
                <span class="cov0" title="0">return r.mapError("update project", err)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// DeleteProject deletes a project and all its tasks using ent transaction
func (r *sqliteRepository) DeleteProject(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        return r.withTx(ctx, func(ctx context.Context, tx *ent.Tx) error </span><span class="cov8" title="1">{
                // First, clear any project context that references this project
                _, err := tx.ProjectContext.Delete().
                        Where(projectcontext.SelectedProjectIDEQ(id)).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear project context: %w", err)
                }</span>

                // Delete all task dependencies for tasks in this project
                <span class="cov8" title="1">taskIDs, err := tx.Task.Query().
                        Where(task.ProjectID(id)).
                        IDs(ctx)
                if err != nil &amp;&amp; !ent.IsNotFound(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get task IDs for project: %w", err)
                }</span>

                <span class="cov8" title="1">if len(taskIDs) &gt; 0 </span><span class="cov0" title="0">{
                        // Delete all task dependencies
                        _, err = tx.TaskDependency.Delete().
                                Where(taskdependency.Or(
                                        taskdependency.TaskIDIn(taskIDs...),
                                        taskdependency.DependsOnTaskIDIn(taskIDs...),
                                )).
                                Exec(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete task dependencies: %w", err)
                        }</span>

                        // Delete all tasks in the project
                        <span class="cov0" title="0">_, err = tx.Task.Delete().
                                Where(task.ProjectID(id)).
                                Exec(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete tasks: %w", err)
                        }</span>
                }

                // Delete the project
                <span class="cov8" title="1">err = tx.Project.DeleteOneID(id).Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                                return NewNotFoundError("project", id.String())
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to delete project: %w", err)</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

// ListProjects retrieves all projects using ent
func (r *sqliteRepository) ListProjects(ctx context.Context) ([]*types.Project, error) <span class="cov8" title="1">{
        entProjects, err := r.client.Project.Query().
                Order(ent.Asc(project.FieldCreatedAt)).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.mapError("list projects", err)
        }</span>

        <span class="cov8" title="1">return entProjectsToProjects(entProjects), nil</span>
}

// updateProjectMetrics updates project metrics (total tasks, completed tasks, progress)
// Currently unused but kept for potential future use
// func (r *sqliteRepository) updateProjectMetrics(ctx context.Context, projectID uuid.UUID) error {
//         // Get task counts by state using ent aggregation
//         var totalTasks int
//         var completedTasks int
//
//         // Count total tasks
//         totalTasks, err := r.client.Task.Query().
//                 Where(task.ProjectID(projectID)).
//                 Count(ctx)
//         if err != nil {
//                 return fmt.Errorf("failed to count total tasks: %w", err)
//         }
//
//         // Count completed tasks
//         completedTasks, err = r.client.Task.Query().
//                 Where(
//                         task.ProjectID(projectID),
//                         task.StateEQ(task.StateCompleted),
//                 ).
//                 Count(ctx)
//         if err != nil {
//                 return fmt.Errorf("failed to count completed tasks: %w", err)
//         }
//
//         // Calculate progress
//         progress := 0.0
//         if totalTasks &gt; 0 {
//                 progress = float64(completedTasks) / float64(totalTasks) * 100.0
//         }
//
//         // Update project metrics
//         err = r.client.Project.UpdateOneID(projectID).
//                 SetTotalTasks(totalTasks).
//                 SetCompletedTasks(completedTasks).
//                 SetProgress(progress).
//                 Exec(ctx)
//
//         if err != nil {
//                 return fmt.Errorf("failed to update project metrics: %w", err)
//         }
//
//         return nil
// }

// updateProjectMetricsInTx updates project metrics within a transaction
func (r *sqliteRepository) updateProjectMetricsInTx(ctx context.Context, tx *ent.Tx, projectID uuid.UUID) error <span class="cov8" title="1">{
        // Get task counts by state using ent aggregation within transaction
        var totalTasks int
        var completedTasks int

        // Count total tasks
        totalTasks, err := tx.Task.Query().
                Where(task.ProjectID(projectID)).
                Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count total tasks: %w", err)
        }</span>

        // Count completed tasks
        <span class="cov8" title="1">completedTasks, err = tx.Task.Query().
                Where(
                        task.ProjectID(projectID),
                        task.StateEQ(task.StateCompleted),
                ).
                Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to count completed tasks: %w", err)
        }</span>

        // Calculate progress
        <span class="cov8" title="1">progress := 0.0
        if totalTasks &gt; 0 </span><span class="cov8" title="1">{
                progress = float64(completedTasks) / float64(totalTasks) * 100.0
        }</span>

        // Update project metrics within transaction
        <span class="cov8" title="1">err = tx.Project.UpdateOneID(projectID).
                SetTotalTasks(totalTasks).
                SetCompletedTasks(completedTasks).
                SetProgress(progress).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update project metrics: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package sqlite

import (
        "context"
        "database/sql"
        "fmt"

        "entgo.io/ent/dialect"
        entsql "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/schema"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent"
        "github.com/denkhaus/knot/internal/types"
        _ "modernc.org/sqlite"
        "go.uber.org/zap"
)

// sqliteRepository implements the Repository interface using ent ORM
type sqliteRepository struct {
        client *ent.Client
        config *Config
        logger *zap.Logger
}

// NewRepository creates a new SQLite repository using ent ORM
func NewRepository(opts ...Option) (types.Repository, error) <span class="cov8" title="1">{
        config := OptimizedConfig() // Use optimized config by default

        repo := &amp;sqliteRepository{
                config: config,
                logger: config.Logger,
        }

        // Apply options
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(repo)
        }</span>

        <span class="cov8" title="1">if err := repo.initialize(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize repository: %w", err)
        }</span>

        <span class="cov8" title="1">return repo, nil</span>
}

// initialize sets up the ent client and performs migrations
func (r *sqliteRepository) initialize() error <span class="cov8" title="1">{
        // Get SQLite connection string
        connStr, err := GetSQLiteConnectionString()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get SQLite connection string: %w", err)
        }</span>

        <span class="cov8" title="1">r.config.Logger.Info("initialize database", zap.String("database_path", connStr))

        db, err := sql.Open("sqlite", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return NewConnectionError("failed to open database connection", err)
        }</span>
        
        // Configure SQLite for optimal performance
        <span class="cov8" title="1">if err := r.configureSQLiteOptimizations(db); err != nil </span><span class="cov0" title="0">{
                return NewConnectionError("failed to configure SQLite optimizations", err)
        }</span>

        // Configure connection pool
        <span class="cov8" title="1">db.SetMaxOpenConns(r.config.MaxOpenConns)
        db.SetMaxIdleConns(r.config.MaxIdleConns)
        db.SetConnMaxLifetime(r.config.ConnMaxLifetime)
        db.SetConnMaxIdleTime(r.config.ConnMaxIdleTime)

        // Test connection with comprehensive validation
        if err := r.validateInitialConnection(db); err != nil </span><span class="cov0" title="0">{
                return NewConnectionError("database connection validation failed", err)
        }</span>

        // Create ent client with SQLite driver
        <span class="cov8" title="1">drv := entsql.OpenDB(dialect.SQLite, db)
        r.client = ent.NewClient(ent.Driver(drv))

        // Run auto-migration if enabled
        if r.config.AutoMigrate </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(context.Background(), r.config.MigrationTimeout)
                defer cancel()

                // Use safe migration options to add new tables without affecting existing data
                if err := r.client.Schema.Create(ctx, 
                        schema.WithDropIndex(false),
                        schema.WithDropColumn(false),
                ); err != nil </span><span class="cov0" title="0">{
                        return NewMigrationError("auto-migration failed", err)
                }</span>
                
                <span class="cov8" title="1">r.logger.Info("Database schema migration completed successfully")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Close closes the ent client and database connection
func (r *sqliteRepository) Close() error <span class="cov8" title="1">{
        if r.client != nil </span><span class="cov8" title="1">{
                return r.client.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// mapError converts ent/database errors to repository errors
func (r *sqliteRepository) mapError(operation string, err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                return NewNotFoundError("resource", "unknown")
        }</span>

        <span class="cov0" title="0">if ent.IsConstraintError(err) </span><span class="cov0" title="0">{
                return NewConstraintViolationError("constraint violation", err)
        }</span>

        // TODO: Add more specific error mapping for different ent error types
        <span class="cov0" title="0">return NewConnectionError(fmt.Sprintf("database operation failed: %s", operation), err)</span>
}

// configureSQLiteOptimizations applies SQLite-specific performance optimizations
func (r *sqliteRepository) configureSQLiteOptimizations(db *sql.DB) error <span class="cov8" title="1">{
        optimizations := []struct {
                name   string
                pragma string
        }{
                {"foreign_keys", "PRAGMA foreign_keys = ON"},
                {"wal_mode", "PRAGMA journal_mode = WAL"},           // Enable WAL mode for better concurrency
                {"synchronous", "PRAGMA synchronous = NORMAL"},      // Balance between safety and performance
                {"cache_size", "PRAGMA cache_size = -64000"},        // 64MB cache (negative = KB)
                {"temp_store", "PRAGMA temp_store = MEMORY"},        // Store temp tables in memory
                {"mmap_size", "PRAGMA mmap_size = 268435456"},       // 256MB memory-mapped I/O
                {"optimize", "PRAGMA optimize"},                     // Analyze and optimize query planner
        }

        for _, opt := range optimizations </span><span class="cov8" title="1">{
                if _, err := db.Exec(opt.pragma); err != nil </span><span class="cov0" title="0">{
                        r.config.Logger.Warn("Failed to apply SQLite optimization", 
                                zap.String("optimization", opt.name),
                                zap.String("pragma", opt.pragma),
                                zap.Error(err))
                        // Continue with other optimizations even if one fails
                }</span> else<span class="cov8" title="1"> {
                        r.config.Logger.Debug("Applied SQLite optimization", 
                                zap.String("optimization", opt.name))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateInitialConnection performs initial connection validation during setup
func (r *sqliteRepository) validateInitialConnection(db *sql.DB) error <span class="cov8" title="1">{
        // Basic ping test
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ping failed: %w", err)
        }</span>

        // Test basic query execution
        <span class="cov8" title="1">var result int
        if err := db.QueryRow("SELECT 1").Scan(&amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("basic query test failed: %w", err)
        }</span>

        <span class="cov8" title="1">if result != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected query result: got %d, expected 1", result)
        }</span>

        // Verify database file is writable by creating a test table
        <span class="cov8" title="1">testTableSQL := `
                CREATE TABLE IF NOT EXISTS _knot_connection_test (
                        id INTEGER PRIMARY KEY,
                        test_value TEXT
                )
        `
        if _, err := db.Exec(testTableSQL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write test failed: %w", err)
        }</span>

        // Clean up test table
        <span class="cov8" title="1">if _, err := db.Exec("DROP TABLE IF EXISTS _knot_connection_test"); err != nil </span><span class="cov0" title="0">{
                r.config.Logger.Warn("Failed to clean up test table", zap.Error(err))
                // Don not fail initialization for cleanup failure
        }</span>

        <span class="cov8" title="1">r.config.Logger.Info("Database connection validation successful")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package sqlite

import (
        "context"
        "fmt"
        "time"

        "github.com/denkhaus/knot/internal/repository/sqlite/ent"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        taskpred "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/taskdependency"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
)

// Task CRUD Operations

// CreateTask creates a new task using ent with dependency handling
func (r *sqliteRepository) CreateTask(ctx context.Context, task *types.Task) error <span class="cov8" title="1">{
        return r.withTx(ctx, func(ctx context.Context, tx *ent.Tx) error </span><span class="cov8" title="1">{
                // Validate project exists
                exists, err := tx.Project.Query().Where(project.ID(task.ProjectID)).Exist(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check project existence: %w", err)
                }</span>
                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                        return NewNotFoundError("project", task.ProjectID.String())
                }</span>

                // Validate parent task if specified
                <span class="cov8" title="1">if task.ParentID != nil </span><span class="cov0" title="0">{
                        parentTask, err := tx.Task.Get(ctx, *task.ParentID)
                        if err != nil </span><span class="cov0" title="0">{
                                if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                                        return NewNotFoundError("parent task", task.ParentID.String())
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("failed to get parent task: %w", err)</span>
                        }
                        <span class="cov0" title="0">if parentTask.ProjectID != task.ProjectID </span><span class="cov0" title="0">{
                                return NewConstraintViolationError("parent task must be in the same project", nil)
                        }</span>
                        // Set correct depth
                        <span class="cov0" title="0">task.Depth = parentTask.Depth + 1</span>
                } else<span class="cov8" title="1"> {
                        task.Depth = 0
                }</span>

                // Set timestamps if not already set
                <span class="cov8" title="1">if task.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                        task.CreatedAt = time.Now()
                }</span>
                <span class="cov8" title="1">if task.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                        task.UpdatedAt = task.CreatedAt
                }</span>

                // Create the task
                <span class="cov8" title="1">_, err = taskToEntTaskCreate(task, tx.Client()).Save(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to create task: %w", err)
                }</span>

                // Create task dependencies if any
                <span class="cov8" title="1">if len(task.Dependencies) &gt; 0 </span><span class="cov0" title="0">{
                        dependencies := make([]TaskDependencyPair, len(task.Dependencies))
                        for i, depID := range task.Dependencies </span><span class="cov0" title="0">{
                                // Validate dependency exists and is in the same project
                                depTask, err := tx.Task.Get(ctx, depID)
                                if err != nil </span><span class="cov0" title="0">{
                                        if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                                                return NewNotFoundError("dependency task", depID.String())
                                        }</span>
                                        <span class="cov0" title="0">return fmt.Errorf("failed to get dependency task: %w", err)</span>
                                }
                                <span class="cov0" title="0">if depTask.ProjectID != task.ProjectID </span><span class="cov0" title="0">{
                                        return NewConstraintViolationError("dependency task must be in the same project", nil)
                                }</span>

                                <span class="cov0" title="0">dependencies[i] = TaskDependencyPair{
                                        TaskID:          task.ID,
                                        DependsOnTaskID: depID,
                                }</span>
                        }

                        // Check for circular dependencies before creating
                        <span class="cov0" title="0">for _, dep := range dependencies </span><span class="cov0" title="0">{
                                if err := r.hasCircularDependencyInTx(ctx, tx, dep.TaskID, dep.DependsOnTaskID, make(map[uuid.UUID]bool)); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        // Create dependencies
                        <span class="cov0" title="0">bulk := make([]*ent.TaskDependencyCreate, len(dependencies))
                        for i, dep := range dependencies </span><span class="cov0" title="0">{
                                bulk[i] = tx.TaskDependency.Create().
                                        SetTaskID(dep.TaskID).
                                        SetDependsOnTaskID(dep.DependsOnTaskID)
                        }</span>
                        <span class="cov0" title="0">if _, err := tx.TaskDependency.CreateBulk(bulk...).Save(ctx); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create task dependencies: %w", err)
                        }</span>
                }

                // Update project metrics
                <span class="cov8" title="1">return r.updateProjectMetricsInTx(ctx, tx, task.ProjectID)</span>
        })
}

// GetTask retrieves a task by ID with dependencies using ent
func (r *sqliteRepository) GetTask(ctx context.Context, id uuid.UUID) (*types.Task, error) <span class="cov8" title="1">{
        entTask, err := r.client.Task.Query().
                Where(taskpred.ID(id)).
                Only(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if ent.IsNotFound(err) </span><span class="cov8" title="1">{
                        return nil, NewNotFoundError("task", id.String())
                }</span>
                <span class="cov0" title="0">return nil, r.mapError("get task", err)</span>
        }

        <span class="cov8" title="1">domainTask := entTaskToTask(entTask)

        // Load dependencies
        dependencies, err := r.client.TaskDependency.Query().
                Where(taskdependency.TaskID(id)).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load dependencies: %w", err)
        }</span>
        <span class="cov8" title="1">domainTask.Dependencies = entTaskDependenciesToTaskIDs(dependencies)

        // Load dependents (tasks that depend on this task)
        dependents, err := r.client.TaskDependency.Query().
                Where(taskdependency.DependsOnTaskID(id)).
                Select(taskdependency.FieldTaskID).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load dependents: %w", err)
        }</span>
        <span class="cov8" title="1">domainTask.Dependents = entTaskDependentsToTaskIDs(dependents)

        return domainTask, nil</span>
}

// UpdateTask updates an existing task using ent
func (r *sqliteRepository) UpdateTask(ctx context.Context, task *types.Task) error <span class="cov8" title="1">{
        return r.withTx(ctx, func(ctx context.Context, tx *ent.Tx) error </span><span class="cov8" title="1">{
                // Get existing task to preserve certain fields
                existingTask, err := tx.Task.Get(ctx, task.ID)
                if err != nil </span><span class="cov0" title="0">{
                        if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                                return NewNotFoundError("task", task.ID.String())
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get existing task: %w", err)</span>
                }

                // Preserve immutable fields
                <span class="cov8" title="1">task.CreatedAt = existingTask.CreatedAt
                task.ProjectID = existingTask.ProjectID
                task.ParentID = existingTask.ParentID
                task.Depth = existingTask.Depth
                task.UpdatedAt = time.Now()

                // Handle completion timestamp
                if task.State == types.TaskStateCompleted &amp;&amp; string(existingTask.State) != string(types.TaskStateCompleted) </span><span class="cov0" title="0">{
                        now := time.Now()
                        task.CompletedAt = &amp;now
                }</span> else<span class="cov8" title="1"> if task.State != types.TaskStateCompleted </span><span class="cov8" title="1">{
                        task.CompletedAt = nil
                }</span>

                // Update the task
                <span class="cov8" title="1">update := tx.Task.UpdateOneID(task.ID)
                taskToEntTaskUpdate(task, update)
                err = update.Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update task: %w", err)
                }</span>

                // Update project metrics if state changed
                <span class="cov8" title="1">if string(existingTask.State) != string(task.State) </span><span class="cov8" title="1">{
                        return r.updateProjectMetricsInTx(ctx, tx, task.ProjectID)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}

// DeleteTask deletes a task if it has no children using ent
func (r *sqliteRepository) DeleteTask(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        return r.withTx(ctx, func(ctx context.Context, tx *ent.Tx) error </span><span class="cov8" title="1">{
                // Get task info
                task, err := tx.Task.Get(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                                return NewNotFoundError("task", id.String())
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get task: %w", err)</span>
                }

                // Check if task has children
                <span class="cov8" title="1">childrenCount, err := tx.Task.Query().
                        Where(taskpred.ParentIDEQ(id)).
                        Count(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to count children: %w", err)
                }</span>
                <span class="cov8" title="1">if childrenCount &gt; 0 </span><span class="cov0" title="0">{
                        return NewConstraintViolationError("cannot delete task with children", nil)
                }</span>

                // Delete all task dependencies (both incoming and outgoing)
                <span class="cov8" title="1">_, err = tx.TaskDependency.Delete().
                        Where(taskdependency.Or(
                                taskdependency.TaskID(id),
                                taskdependency.DependsOnTaskID(id),
                        )).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete task dependencies: %w", err)
                }</span>

                // Delete the task
                <span class="cov8" title="1">err = tx.Task.DeleteOneID(id).Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete task: %w", err)
                }</span>

                // Update project metrics
                <span class="cov8" title="1">return r.updateProjectMetricsInTx(ctx, tx, task.ProjectID)</span>
        })
}

// DeleteTaskSubtree deletes a task and all its descendants using ent with recursive CTE
func (r *sqliteRepository) DeleteTaskSubtree(ctx context.Context, taskID uuid.UUID) error <span class="cov0" title="0">{
        return r.withTx(ctx, func(ctx context.Context, tx *ent.Tx) error </span><span class="cov0" title="0">{
                // Get the task to ensure it exists and get project ID
                task, err := tx.Task.Get(ctx, taskID)
                if err != nil </span><span class="cov0" title="0">{
                        if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                                return NewNotFoundError("task", taskID.String())
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get task: %w", err)</span>
                }

                // Get all descendant task IDs using recursive query
                <span class="cov0" title="0">descendantIDs, err := r.getDescendantTaskIDsInTx(ctx, tx, taskID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get descendant task IDs: %w", err)
                }</span>

                // Add the root task to the list
                <span class="cov0" title="0">allTaskIDs := append(descendantIDs, taskID)

                // Delete all task dependencies for these tasks
                _, err = tx.TaskDependency.Delete().
                        Where(taskdependency.Or(
                                taskdependency.TaskIDIn(allTaskIDs...),
                                taskdependency.DependsOnTaskIDIn(allTaskIDs...),
                        )).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete task dependencies: %w", err)
                }</span>

                // Delete all tasks in the subtree (children first due to foreign key constraints)
                <span class="cov0" title="0">_, err = tx.Task.Delete().
                        Where(taskpred.IDIn(allTaskIDs...)).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete tasks: %w", err)
                }</span>

                // Update project metrics
                <span class="cov0" title="0">return r.updateProjectMetricsInTx(ctx, tx, task.ProjectID)</span>
        })
}

// getDescendantTaskIDsInTx gets all descendant task IDs using recursive approach
func (r *sqliteRepository) getDescendantTaskIDsInTx(ctx context.Context, tx *ent.Tx, taskID uuid.UUID) ([]uuid.UUID, error) <span class="cov0" title="0">{
        var allDescendants []uuid.UUID
        queue := []uuid.UUID{taskID}
        visited := make(map[uuid.UUID]bool)

        for len(queue) &gt; 0 </span><span class="cov0" title="0">{
                currentID := queue[0]
                queue = queue[1:]

                if visited[currentID] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">visited[currentID] = true

                // Get direct children
                children, err := tx.Task.Query().
                        Where(taskpred.ParentIDEQ(currentID)).
                        IDs(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get children for task %s: %w", currentID, err)
                }</span>

                <span class="cov0" title="0">for _, childID := range children </span><span class="cov0" title="0">{
                        if !visited[childID] </span><span class="cov0" title="0">{
                                allDescendants = append(allDescendants, childID)
                                queue = append(queue, childID)
                        }</span>
                }
        }

        <span class="cov0" title="0">return allDescendants, nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package sqlite

import (
        "context"
        "fmt"

        "github.com/denkhaus/knot/internal/repository/sqlite/ent"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/project"
        task "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
)

// Task Query Operations

// ListTasks retrieves tasks with filtering using ent
func (r *sqliteRepository) ListTasks(ctx context.Context, filter types.TaskFilter) ([]*types.Task, error) <span class="cov0" title="0">{
        query := r.client.Task.Query()

        // Apply filters using ent predicates
        if filter.ProjectID != nil </span><span class="cov0" title="0">{
                query = query.Where(task.ProjectID(*filter.ProjectID))
        }</span>
        <span class="cov0" title="0">if filter.ParentID != nil </span><span class="cov0" title="0">{
                if *filter.ParentID == uuid.Nil </span><span class="cov0" title="0">{
                        query = query.Where(task.ParentIDIsNil())
                }</span> else<span class="cov0" title="0"> {
                        query = query.Where(task.ParentID(*filter.ParentID))
                }</span>
        }
        <span class="cov0" title="0">if filter.State != nil </span><span class="cov0" title="0">{
                query = query.Where(task.StateEQ(task.State(string(*filter.State))))
        }</span>
        <span class="cov0" title="0">if filter.MinDepth != nil </span><span class="cov0" title="0">{
                query = query.Where(task.DepthGTE(*filter.MinDepth))
        }</span>
        <span class="cov0" title="0">if filter.MaxDepth != nil </span><span class="cov0" title="0">{
                query = query.Where(task.DepthLTE(*filter.MaxDepth))
        }</span>
        <span class="cov0" title="0">if filter.MinComplexity != nil </span><span class="cov0" title="0">{
                query = query.Where(task.ComplexityGTE(*filter.MinComplexity))
        }</span>
        <span class="cov0" title="0">if filter.MaxComplexity != nil </span><span class="cov0" title="0">{
                query = query.Where(task.ComplexityLTE(*filter.MaxComplexity))
        }</span>

        // Execute query
        <span class="cov0" title="0">entTasks, err := query.
                Order(ent.Asc(task.FieldCreatedAt)).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.mapError("list tasks", err)
        }</span>

        // Convert to domain models
        <span class="cov0" title="0">tasks := make([]*types.Task, len(entTasks))
        for i, entTask := range entTasks </span><span class="cov0" title="0">{
                tasks[i] = entTaskToTask(entTask)
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

// GetTasksByProject retrieves all tasks for a specific project using ent
func (r *sqliteRepository) GetTasksByProject(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error) <span class="cov8" title="1">{
        entTasks, err := r.client.Task.Query().
                Where(task.ProjectID(projectID)).
                Order(ent.Asc(task.FieldCreatedAt)).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.mapError("get tasks by project", err)
        }</span>

        // Convert to domain models
        <span class="cov8" title="1">tasks := make([]*types.Task, len(entTasks))
        for i, entTask := range entTasks </span><span class="cov8" title="1">{
                tasks[i] = entTaskToTask(entTask)
        }</span>

        <span class="cov8" title="1">return tasks, nil</span>
}

// GetTasksByParent retrieves all direct children of a parent task using ent
func (r *sqliteRepository) GetTasksByParent(ctx context.Context, parentID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        entTasks, err := r.client.Task.Query().
                Where(task.ParentID(parentID)).
                Order(ent.Asc(task.FieldCreatedAt)).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.mapError("get tasks by parent", err)
        }</span>

        <span class="cov0" title="0">tasks := make([]*types.Task, len(entTasks))
        for i, entTask := range entTasks </span><span class="cov0" title="0">{
                tasks[i] = entTaskToTask(entTask)
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

// GetRootTasks retrieves all root tasks (tasks without parents) for a project using ent
func (r *sqliteRepository) GetRootTasks(ctx context.Context, projectID uuid.UUID) ([]*types.Task, error) <span class="cov0" title="0">{
        entTasks, err := r.client.Task.Query().
                Where(
                        task.ProjectID(projectID),
                        task.ParentIDIsNil(),
                ).
                Order(ent.Asc(task.FieldCreatedAt)).
                All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.mapError("get root tasks", err)
        }</span>

        <span class="cov0" title="0">tasks := make([]*types.Task, len(entTasks))
        for i, entTask := range entTasks </span><span class="cov0" title="0">{
                tasks[i] = entTaskToTask(entTask)
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

// GetParentTask retrieves the parent task of a given task using ent
func (r *sqliteRepository) GetParentTask(ctx context.Context, taskID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        // Get the task first to get parent ID
        task, err := r.client.Task.Get(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, NewNotFoundError("task", taskID.String())
                }</span>
                <span class="cov0" title="0">return nil, r.mapError("get task for parent lookup", err)</span>
        }

        <span class="cov0" title="0">if task.ParentID == nil </span><span class="cov0" title="0">{
                return nil, NewNotFoundError("parent task", "nil")
        }</span>

        // Get the parent taskpred
        <span class="cov0" title="0">return r.GetTask(ctx, *task.ParentID)</span>
}

// GetProjectProgress calculates project progress using ent aggregations
func (r *sqliteRepository) GetProjectProgress(ctx context.Context, projectID uuid.UUID) (*types.ProjectProgress, error) <span class="cov0" title="0">{
        // Verify project exists
        exists, err := r.client.Project.Query().Where(project.ID(projectID)).Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, r.mapError("check project existence", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, NewNotFoundError("project", projectID.String())
        }</span>

        // Get task counts by state
        <span class="cov0" title="0">taskCounts := make(map[types.TaskState]int)

        states := []types.TaskState{
                types.TaskStatePending,
                types.TaskStateInProgress,
                types.TaskStateCompleted,
                types.TaskStateBlocked,
                types.TaskStateCancelled,
        }

        totalTasks := 0
        for _, state := range states </span><span class="cov0" title="0">{
                count, err := r.client.Task.Query().
                        Where(
                                task.ProjectID(projectID),
                                task.StateEQ(task.State(string(state))),
                        ).
                        Count(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to count tasks with state %s: %w", state, err)
                }</span>
                <span class="cov0" title="0">taskCounts[state] = count
                totalTasks += count</span>
        }

        // Get task counts by depth
        <span class="cov0" title="0">tasksByDepth := make(map[int]int)
        if totalTasks &gt; 0 </span><span class="cov0" title="0">{
                // Get max depth first
                maxDepthResult, err := r.client.Task.Query().
                        Where(task.ProjectID(projectID)).
                        Aggregate(ent.Max(task.FieldDepth)).
                        Int(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get max depth: %w", err)
                }</span>

                // Count tasks for each depth level
                <span class="cov0" title="0">for depth := 0; depth &lt;= maxDepthResult; depth++ </span><span class="cov0" title="0">{
                        count, err := r.client.Task.Query().
                                Where(
                                        task.ProjectID(projectID),
                                        task.DepthEQ(depth),
                                ).
                                Count(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to count tasks at depth %d: %w", depth, err)
                        }</span>
                        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                                tasksByDepth[depth] = count
                        }</span>
                }
        }

        // Calculate overall progress
        <span class="cov0" title="0">progress := 0.0
        if totalTasks &gt; 0 </span><span class="cov0" title="0">{
                progress = float64(taskCounts[types.TaskStateCompleted]) / float64(totalTasks) * 100.0
        }</span>

        <span class="cov0" title="0">return &amp;types.ProjectProgress{
                ProjectID:       projectID,
                TotalTasks:      totalTasks,
                CompletedTasks:  taskCounts[types.TaskStateCompleted],
                InProgressTasks: taskCounts[types.TaskStateInProgress],
                PendingTasks:    taskCounts[types.TaskStatePending],
                BlockedTasks:    taskCounts[types.TaskStateBlocked],
                CancelledTasks:  taskCounts[types.TaskStateCancelled],
                OverallProgress: progress,
                TasksByDepth:    tasksByDepth,
        }, nil</span>
}

// GetTaskCountByDepth returns task counts by depth level for a project using ent
func (r *sqliteRepository) GetTaskCountByDepth(ctx context.Context, projectID uuid.UUID, maxDepth int) (map[int]int, error) <span class="cov0" title="0">{
        tasksByDepth := make(map[int]int)

        for depth := 0; depth &lt;= maxDepth; depth++ </span><span class="cov0" title="0">{
                count, err := r.client.Task.Query().
                        Where(
                                task.ProjectID(projectID),
                                task.DepthEQ(depth),
                        ).
                        Count(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to count tasks at depth %d: %w", depth, err)
                }</span>
                <span class="cov0" title="0">tasksByDepth[depth] = count</span>
        }

        <span class="cov0" title="0">return tasksByDepth, nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package sqlite

import (
        "context"
        "fmt"

        "github.com/denkhaus/knot/internal/repository/sqlite/ent"
        "github.com/denkhaus/knot/internal/repository/sqlite/ent/task"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
)

// TxFunc represents a function that executes within an ent transaction
type TxFunc func(ctx context.Context, tx *ent.Tx) error

// withTx executes a function within an ent transaction
func (r *sqliteRepository) withTx(ctx context.Context, fn TxFunc) error <span class="cov8" title="1">{
        tx, err := r.client.Tx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return NewTransactionError("failed to begin transaction", err)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        // Rollback on panic and re-panic
                        if rollbackErr := tx.Rollback(); rollbackErr != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("rollback failed after panic: %v (original panic: %v)", rollbackErr, p)
                        }</span>
                        <span class="cov0" title="0">panic(p)</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        // Rollback on error
                        if rollbackErr := tx.Rollback(); rollbackErr != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("rollback failed: %v (original error: %w)", rollbackErr, err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Commit on success
                        err = tx.Commit()
                        if err != nil </span><span class="cov0" title="0">{
                                err = NewTransactionError("failed to commit transaction", err)
                        }</span>
                }
        }()

        <span class="cov8" title="1">err = fn(ctx, tx)
        return err</span>
}

// DuplicateTaskWithDependencies duplicates a task and its dependencies to a new project
func (r *sqliteRepository) DuplicateTaskWithDependencies(ctx context.Context, taskID, newProjectID uuid.UUID) (*types.Task, error) <span class="cov0" title="0">{
        var result *types.Task
        err := r.withTx(ctx, func(ctx context.Context, tx *ent.Tx) error </span><span class="cov0" title="0">{
                // Get original task
                originalTask, err := tx.Task.Query().
                        Where(task.ID(taskID)).
                        Only(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        if ent.IsNotFound(err) </span><span class="cov0" title="0">{
                                return NewNotFoundError("task", taskID.String())
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get original task: %w", err)</span>
                }

                // Create new task with new ID and project
                <span class="cov0" title="0">newTaskID := uuid.New()
                newTask := entTaskToTask(originalTask)
                newTask.ID = newTaskID
                newTask.ProjectID = newProjectID
                newTask.ParentID = nil // Don't duplicate parent relationships across projects

                // Create the new task
                _, err = taskToEntTaskCreate(newTask, tx.Client()).Save(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create duplicated task: %w", err)
                }</span>

                // Note: Dependencies are not duplicated across projects as they may not exist
                // This is intentional to avoid creating invalid dependencies

                // Update project metrics for the new project
                <span class="cov0" title="0">err = r.updateProjectMetricsInTx(ctx, tx, newProjectID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update project metrics: %w", err)
                }</span>

                <span class="cov0" title="0">result = newTask
                return nil</span>
        })
        <span class="cov0" title="0">return result, err</span>
}

// TaskDependencyPair represents a task dependency relationship
type TaskDependencyPair struct {
        TaskID          uuid.UUID
        DependsOnTaskID uuid.UUID
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package shared

import (
        "github.com/denkhaus/knot/internal/manager"
        "go.uber.org/zap"
)

// AppContext holds the application dependencies
// This is in a shared package to avoid import cycles
type AppContext struct {
        ProjectManager manager.ProjectManager
        Logger         *zap.Logger
        Actor          string
}

// NewAppContext creates a new application context with all dependencies
func NewAppContext(projectManager manager.ProjectManager, logger *zap.Logger) *AppContext <span class="cov8" title="1">{
        return &amp;AppContext{
                ProjectManager: projectManager,
                Logger:         logger,
        }
}</span>

func (p *AppContext) SetActor(actor string) <span class="cov0" title="0">{
        p.Actor = actor
}</span>

// GetActor returns the current actor
func (p *AppContext) GetActor() string <span class="cov0" title="0">{
        if p.Actor == "" </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return p.Actor</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package shared

import (
        "context"
        "fmt"
        
        "github.com/denkhaus/knot/internal/errors"
        "github.com/google/uuid"
        "github.com/urfave/cli/v2"
)

// ResolveProjectID resolves the project ID from stored context
func ResolveProjectID(c *cli.Context, appCtx *AppContext) (uuid.UUID, error) <span class="cov8" title="1">{
        // Get project from database stored context
        if contextProjectID, err := appCtx.ProjectManager.GetSelectedProject(c.Context); err == nil &amp;&amp; contextProjectID != nil </span><span class="cov8" title="1">{
                return *contextProjectID, nil
        }</span>
        
        // No project available
        <span class="cov8" title="1">return uuid.Nil, errors.NoProjectContextError()</span>
}

// ShowProjectContext displays the current project context if one is selected
// Returns true if context was shown, false if no project is selected
func ShowProjectContext(c *cli.Context, appCtx *AppContext) bool <span class="cov0" title="0">{
        // Skip context display for JSON output
        if c.Bool("json") </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Get selected project
        <span class="cov0" title="0">selectedProjectID, err := appCtx.ProjectManager.GetSelectedProject(c.Context)
        if err != nil || selectedProjectID == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Get project details
        <span class="cov0" title="0">project, err := appCtx.ProjectManager.GetProject(context.Background(), *selectedProjectID)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Display context indicator
        <span class="cov0" title="0">fmt.Printf("[Project: %s]\n", project.Title)
        return true</span>
}

// ShowProjectContextWithSeparator displays project context with a separator line
func ShowProjectContextWithSeparator(c *cli.Context, appCtx *AppContext) bool <span class="cov0" title="0">{
        if ShowProjectContext(c, appCtx) </span><span class="cov0" title="0">{
                fmt.Println()
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

</pre>
		
		<pre class="file" id="file84" style="display: none">package templates

import (
        "crypto/sha256"
        "embed"
        "fmt"
        "io/fs"
        "strings"

        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "gopkg.in/yaml.v3"
)

//go:embed bug-fix.yaml code-review.yaml feature-development.yaml
var embeddedTemplates embed.FS

// LoadBuiltInTemplates loads all built-in templates from embedded filesystem
func LoadBuiltInTemplates() ([]*types.TaskTemplate, error) <span class="cov0" title="0">{
        var templates []*types.TaskTemplate

        entries, err := embeddedTemplates.ReadDir(".")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read embedded templates: %w", err)
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".yaml") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">template, err := loadTemplateFromEmbedded(entry.Name())
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other templates
                        continue</span>
                }

                <span class="cov0" title="0">template.IsBuiltIn = true
                templates = append(templates, template)</span>
        }

        <span class="cov0" title="0">return templates, nil</span>
}

// loadTemplateFromEmbedded loads a template from the embedded filesystem
func loadTemplateFromEmbedded(filename string) (*types.TaskTemplate, error) <span class="cov0" title="0">{
        data, err := embeddedTemplates.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read embedded template %s: %w", filename, err)
        }</span>

        <span class="cov0" title="0">var template types.TaskTemplate
        if err := yaml.Unmarshal(data, &amp;template); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse template YAML %s: %w", filename, err)
        }</span>

        // Generate deterministic ID for built-in templates based on filename
        <span class="cov0" title="0">if template.ID == uuid.Nil </span><span class="cov0" title="0">{
                template.ID = generateDeterministicUUID(filename)
        }</span>

        <span class="cov0" title="0">return &amp;template, nil</span>
}

// GetEmbeddedTemplateFS returns the embedded filesystem for external access
func GetEmbeddedTemplateFS() fs.FS <span class="cov0" title="0">{
        return embeddedTemplates
}</span>

// ListEmbeddedTemplateFiles returns a list of embedded template filenames
func ListEmbeddedTemplateFiles() ([]string, error) <span class="cov0" title="0">{
        var files []string

        entries, err := embeddedTemplates.ReadDir(".")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read embedded templates: %w", err)
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() &amp;&amp; strings.HasSuffix(entry.Name(), ".yaml") </span><span class="cov0" title="0">{
                        files = append(files, entry.Name())
                }</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

// GetEmbeddedTemplateContent returns the raw content of an embedded template
func GetEmbeddedTemplateContent(filename string) ([]byte, error) <span class="cov0" title="0">{
        return embeddedTemplates.ReadFile(filename)
}</span>

// generateDeterministicUUID creates a deterministic UUID based on filename
// This ensures built-in templates always have the same UUID
func generateDeterministicUUID(filename string) uuid.UUID <span class="cov0" title="0">{
        // Create deterministic UUID based on filename
        hash := sha256.Sum256([]byte("knot-builtin-template:" + filename))
        
        // Use first 16 bytes of hash to create UUID
        var uuidBytes [16]byte
        copy(uuidBytes[:], hash[:16])
        
        // Set version (4) and variant bits
        uuidBytes[6] = (uuidBytes[6] &amp; 0x0f) | 0x40 // Version 4
        uuidBytes[8] = (uuidBytes[8] &amp; 0x3f) | 0x80 // Variant 10
        
        return uuid.UUID(uuidBytes)
}</pre>
		
		<pre class="file" id="file85" style="display: none">package templates

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "gopkg.in/yaml.v3"
)

// LoadSeedingMetadata loads seeding metadata from file
func LoadSeedingMetadata() (*SeedingMetadata, error) <span class="cov0" title="0">{
        templatesDir, err := GetUserTemplatesDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metadataPath := filepath.Join(templatesDir, "metadata.yaml")
        if _, err := os.Stat(metadataPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Return empty metadata if file doesn't exist
                return &amp;SeedingMetadata{
                        SeededTemplates: make(map[string]SeededTemplateInfo),
                        LastSeedTime:    "",
                }, nil
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(metadataPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read metadata file: %w", err)
        }</span>

        <span class="cov0" title="0">var metadata SeedingMetadata
        if err := yaml.Unmarshal(data, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse metadata YAML: %w", err)
        }</span>

        // Initialize map if nil (for backward compatibility)
        <span class="cov0" title="0">if metadata.SeededTemplates == nil </span><span class="cov0" title="0">{
                metadata.SeededTemplates = make(map[string]SeededTemplateInfo)
        }</span>

        <span class="cov0" title="0">return &amp;metadata, nil</span>
}

// IsTemplateSeeded checks if a template with given UUID has been seeded
func IsTemplateSeeded(templateID uuid.UUID) (bool, error) <span class="cov0" title="0">{
        metadata, err := LoadSeedingMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">_, exists := metadata.SeededTemplates[templateID.String()]
        return exists, nil</span>
}

// GetSeededTemplateInfo returns information about a seeded template
func GetSeededTemplateInfo(templateID uuid.UUID) (*SeededTemplateInfo, error) <span class="cov0" title="0">{
        metadata, err := LoadSeedingMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">info, exists := metadata.SeededTemplates[templateID.String()]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("template %s not found in seeded templates", templateID.String())
        }</span>

        <span class="cov0" title="0">return &amp;info, nil</span>
}

// UpdateSeededTemplate updates or adds a seeded template entry
func UpdateSeededTemplate(template *types.TaskTemplate) error <span class="cov0" title="0">{
        metadata, err := LoadSeedingMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">templateKey := template.ID.String()
        metadata.SeededTemplates[templateKey] = SeededTemplateInfo{
                Name:     template.Name,
                SeededAt: getCurrentTimestamp(),
        }

        return saveSeedingMetadata(metadata)</span>
}

// RemoveSeededTemplate removes a template from seeded templates tracking
func RemoveSeededTemplate(templateID uuid.UUID) error <span class="cov0" title="0">{
        metadata, err := LoadSeedingMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">delete(metadata.SeededTemplates, templateID.String())
        return saveSeedingMetadata(metadata)</span>
}

// saveSeedingMetadata saves metadata to file
func saveSeedingMetadata(metadata *SeedingMetadata) error <span class="cov0" title="0">{
        templatesDir, err := GetUserTemplatesDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">metadataPath := filepath.Join(templatesDir, "metadata.yaml")
        return saveMetadata(metadataPath, metadata)</span>
}

// ListSeededTemplates returns all seeded template information
func ListSeededTemplates() (map[string]SeededTemplateInfo, error) <span class="cov0" title="0">{
        metadata, err := LoadSeedingMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return metadata.SeededTemplates, nil</span>
}

// GetSeedingStats returns statistics about seeded templates
func GetSeedingStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        metadata, err := LoadSeedingMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">stats := map[string]interface{}{
                "total_seeded":   len(metadata.SeededTemplates),
                "last_seed_time": metadata.LastSeedTime,
                "templates":      make([]map[string]string, 0),
        }

        for uuid, info := range metadata.SeededTemplates </span><span class="cov0" title="0">{
                templateInfo := map[string]string{
                        "uuid":      uuid,
                        "name":      info.Name,
                        "seeded_at": info.SeededAt,
                }
                stats["templates"] = append(stats["templates"].([]map[string]string), templateInfo)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}</pre>
		
		<pre class="file" id="file86" style="display: none">package templates

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/denkhaus/knot/internal/types"
        "gopkg.in/yaml.v3"
)

// SeedingMetadata tracks which templates have been seeded
type SeedingMetadata struct {
        SeededTemplates map[string]SeededTemplateInfo `yaml:"seeded_templates"`
        LastSeedTime    string                        `yaml:"last_seed_time"`
}

// SeededTemplateInfo contains information about a seeded template
type SeededTemplateInfo struct {
        Name     string `yaml:"name"`
        SeededAt string `yaml:"seeded_at"`
}

// AutoSeedTemplates automatically seeds built-in templates to user directory on first .knot creation
func AutoSeedTemplates() error <span class="cov0" title="0">{
        // Check if this is first-time setup by looking for seeding metadata
        templatesDir, err := GetUserTemplatesDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get templates directory: %w", err)
        }</span>
        <span class="cov0" title="0">metadataPath := filepath.Join(templatesDir, "metadata.yaml")
        if _, err := os.Stat(metadataPath); err == nil </span><span class="cov0" title="0">{
                // Metadata exists, seeding already done
                return nil
        }</span>

        // Ensure templates directory exists
        <span class="cov0" title="0">if err := EnsureUserTemplatesDir(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure templates directory: %w", err)
        }</span>

        // Load built-in templates
        <span class="cov0" title="0">builtInTemplates, err := LoadBuiltInTemplates()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load built-in templates: %w", err)
        }</span>

        // Seed each built-in template
        <span class="cov0" title="0">metadata := &amp;SeedingMetadata{
                SeededTemplates: make(map[string]SeededTemplateInfo),
                LastSeedTime:    getCurrentTimestamp(),
        }

        for _, template := range builtInTemplates </span><span class="cov0" title="0">{
                if err := seedTemplate(template); err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other templates
                        fmt.Printf("Warning: Failed to seed template '%s': %v\n", template.Name, err)
                        continue</span>
                }
                
                // Use template UUID as key, store template info as value
                <span class="cov0" title="0">templateKey := template.ID.String()
                metadata.SeededTemplates[templateKey] = SeededTemplateInfo{
                        Name:     template.Name,
                        SeededAt: getCurrentTimestamp(),
                }</span>
        }

        // Save seeding metadata
        <span class="cov0" title="0">if err := saveMetadata(metadataPath, metadata); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save seeding metadata: %w", err)
        }</span>

        <span class="cov0" title="0">seededCount := len(metadata.SeededTemplates)
        fmt.Printf("Auto-seeded %d built-in templates to .knot/templates/\n", seededCount)
        return nil</span>
}

// seedTemplate copies a built-in template to the user templates directory
func seedTemplate(template *types.TaskTemplate) error <span class="cov0" title="0">{
        templatesDir, err := GetUserTemplatesDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate filename from template name
        <span class="cov0" title="0">filename := strings.ToLower(strings.ReplaceAll(template.Name, " ", "-")) + ".yaml"
        filePath := filepath.Join(templatesDir, filename)

        // Check if file already exists (user might have created it manually)
        if _, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                // File exists, don't overwrite
                return nil
        }</span>

        // Marshal template to YAML
        <span class="cov0" title="0">data, err := yaml.Marshal(template)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal template to YAML: %w", err)
        }</span>

        // Write to file
        <span class="cov0" title="0">if err := os.WriteFile(filePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write template file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getKnotDir returns the .knot directory path
func getKnotDir() (string, error) <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current working directory: %w", err)
        }</span>
        <span class="cov0" title="0">return filepath.Join(cwd, ".knot"), nil</span>
}

// saveMetadata saves seeding metadata to file
func saveMetadata(path string, metadata *SeedingMetadata) error <span class="cov0" title="0">{
        data, err := yaml.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(path, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write metadata file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getCurrentTimestamp returns current timestamp as string
func getCurrentTimestamp() string <span class="cov0" title="0">{
        // Use a simple timestamp format
        return fmt.Sprintf("%d", 1640995200) // Unix timestamp placeholder
}</span>

// CheckAndSeedIfNeeded checks if seeding is needed and performs it
func CheckAndSeedIfNeeded() error <span class="cov0" title="0">{
        knotDir, err := getKnotDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if .knot directory exists
        <span class="cov0" title="0">if _, err := os.Stat(knotDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // .knot directory doesn't exist, no need to seed
                return nil
        }</span>

        // Check if templates directory exists
        <span class="cov0" title="0">templatesDir, err := GetUserTemplatesDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(templatesDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Templates directory doesn't exist, create it and seed
                return AutoSeedTemplates()
        }</span>

        // Load current seeding metadata
        <span class="cov0" title="0">metadata, err := LoadSeedingMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load seeding metadata: %w", err)
        }</span>

        // If no templates have been seeded yet, perform seeding
        <span class="cov0" title="0">if len(metadata.SeededTemplates) == 0 </span><span class="cov0" title="0">{
                return AutoSeedTemplates()
        }</span>

        // Check if there are new built-in templates that haven't been seeded
        <span class="cov0" title="0">builtInTemplates, err := LoadBuiltInTemplates()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load built-in templates: %w", err)
        }</span>

        <span class="cov0" title="0">newTemplatesFound := false
        for _, template := range builtInTemplates </span><span class="cov0" title="0">{
                if _, exists := metadata.SeededTemplates[template.ID.String()]; !exists </span><span class="cov0" title="0">{
                        // New template found, seed it
                        if err := seedTemplate(template); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: Failed to seed new template '%s': %v\n", template.Name, err)
                                continue</span>
                        }
                        
                        // Update metadata
                        <span class="cov0" title="0">if err := UpdateSeededTemplate(template); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: Failed to update metadata for template '%s': %v\n", template.Name, err)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("Auto-seeded new template: %s\n", template.Name)
                                newTemplatesFound = true
                        }</span>
                }
        }

        <span class="cov0" title="0">if newTemplatesFound </span><span class="cov0" title="0">{
                fmt.Println("New built-in templates have been seeded to .knot/templates/")
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file87" style="display: none">package templates

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "gopkg.in/yaml.v3"
)

// GetUserTemplatesDir returns the local project templates directory path
func GetUserTemplatesDir() (string, error) <span class="cov0" title="0">{
        // Use local .knot directory in current working directory
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current working directory: %w", err)
        }</span>
        <span class="cov0" title="0">return filepath.Join(cwd, ".knot", "templates"), nil</span>
}

// EnsureUserTemplatesDir creates the user templates directory if it doesn't exist
func EnsureUserTemplatesDir() error <span class="cov0" title="0">{
        dir, err := GetUserTemplatesDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.MkdirAll(dir, 0755)</span>
}

// LoadUserTemplates loads all user templates from ~/.knot/templates/
func LoadUserTemplates() ([]*types.TaskTemplate, error) <span class="cov0" title="0">{
        var templates []*types.TaskTemplate

        templatesDir, err := GetUserTemplatesDir()
        if err != nil </span><span class="cov0" title="0">{
                return templates, err
        }</span>

        // Check if directory exists
        <span class="cov0" title="0">if _, err := os.Stat(templatesDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return templates, nil // No user templates directory, return empty list
        }</span>

        // Find all YAML files in the directory
        <span class="cov0" title="0">files, err := filepath.Glob(filepath.Join(templatesDir, "*.yaml"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find user template files: %w", err)
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                template, err := LoadTemplateFromFile(file)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other templates
                        continue</span>
                }
                <span class="cov0" title="0">template.IsBuiltIn = false
                templates = append(templates, template)</span>
        }

        <span class="cov0" title="0">return templates, nil</span>
}

// LoadTemplateFromFile loads a template from a YAML file
func LoadTemplateFromFile(filePath string) (*types.TaskTemplate, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read template file: %w", err)
        }</span>

        <span class="cov0" title="0">var template types.TaskTemplate
        if err := yaml.Unmarshal(data, &amp;template); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse template YAML: %w", err)
        }</span>

        // Generate ID if not present
        <span class="cov0" title="0">if template.ID == uuid.Nil </span><span class="cov0" title="0">{
                template.ID = uuid.New()
        }</span>

        <span class="cov0" title="0">return &amp;template, nil</span>
}

// SaveUserTemplate saves a template to the user templates directory
func SaveUserTemplate(template *types.TaskTemplate) error <span class="cov0" title="0">{
        if err := EnsureUserTemplatesDir(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">templatesDir, err := GetUserTemplatesDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate filename from template name
        <span class="cov0" title="0">filename := strings.ToLower(strings.ReplaceAll(template.Name, " ", "-")) + ".yaml"
        filePath := filepath.Join(templatesDir, filename)

        data, err := yaml.Marshal(template)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal template to YAML: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(filePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write template file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteUserTemplate deletes a user template by name
func DeleteUserTemplate(templateName string) error <span class="cov0" title="0">{
        templatesDir, err := GetUserTemplatesDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate filename from template name
        <span class="cov0" title="0">filename := strings.ToLower(strings.ReplaceAll(templateName, " ", "-")) + ".yaml"
        filePath := filepath.Join(templatesDir, filename)

        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("user template '%s' not found", templateName)
        }</span>

        <span class="cov0" title="0">if err := os.Remove(filePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete template file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetUserTemplateFilePath returns the file path for a user template
func GetUserTemplateFilePath(templateName string) (string, error) <span class="cov0" title="0">{
        templatesDir, err := GetUserTemplatesDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">filename := strings.ToLower(strings.ReplaceAll(templateName, " ", "-")) + ".yaml"
        return filepath.Join(templatesDir, filename), nil</span>
}

// UserTemplateExists checks if a user template exists
func UserTemplateExists(templateName string) bool <span class="cov0" title="0">{
        filePath, err := GetUserTemplateFilePath(templateName)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">_, err = os.Stat(filePath)
        return !os.IsNotExist(err)</span>
}</pre>
		
		<pre class="file" id="file88" style="display: none">package testutil

import (
        "context"
        "os"
        "testing"
        "time"

        "github.com/denkhaus/knot/internal/manager"
        "github.com/denkhaus/knot/internal/repository/inmemory"
        "github.com/denkhaus/knot/internal/repository/sqlite"
        "github.com/denkhaus/knot/internal/types"
        "github.com/google/uuid"
        "github.com/stretchr/testify/require"
        "go.uber.org/zap"
        "go.uber.org/zap/zaptest"
)

// TestConfig holds configuration for tests
type TestConfig struct {
        UseInMemoryDB bool
        TempDir       string
        Logger        *zap.Logger
}

// NewTestConfig creates a new test configuration
func NewTestConfig(t *testing.T) *TestConfig <span class="cov0" title="0">{
        return &amp;TestConfig{
                UseInMemoryDB: true, // Default to in-memory for speed
                Logger:        zaptest.NewLogger(t),
        }
}</span>

// WithSQLiteDB configures the test to use SQLite database
func (tc *TestConfig) WithSQLiteDB() *TestConfig <span class="cov0" title="0">{
        tc.UseInMemoryDB = false
        return tc
}</span>

// WithTempDir sets a custom temp directory
func (tc *TestConfig) WithTempDir(dir string) *TestConfig <span class="cov0" title="0">{
        tc.TempDir = dir
        return tc
}</span>

// SetupTestRepository creates a test repository based on configuration
func (tc *TestConfig) SetupTestRepository(t *testing.T) types.Repository <span class="cov0" title="0">{
        if tc.UseInMemoryDB </span><span class="cov0" title="0">{
                return inmemory.NewMemoryRepository()
        }</span>

        // Setup temporary directory for SQLite tests
        <span class="cov0" title="0">tempDir := tc.TempDir
        if tempDir == "" </span><span class="cov0" title="0">{
                var err error
                tempDir, err = os.MkdirTemp("", "knot_test_*")
                require.NoError(t, err)
                t.Cleanup(func() </span><span class="cov0" title="0">{
                        os.RemoveAll(tempDir)
                }</span>)
        }

        // Change to temp directory for SQLite database creation
        <span class="cov0" title="0">originalDir, err := os.Getwd()
        require.NoError(t, err)
        
        err = os.Chdir(tempDir)
        require.NoError(t, err)
        
        t.Cleanup(func() </span><span class="cov0" title="0">{
                _ = os.Chdir(originalDir)
        }</span>)

        // Create SQLite repository
        <span class="cov0" title="0">repo, err := sqlite.NewRepository(
                sqlite.WithLogger(tc.Logger),
                sqlite.WithAutoMigrate(true),
        )
        require.NoError(t, err)

        // Note: Repository interface doesn't have Close method
        // SQLite repository will be cleaned up when temp directory is removed

        return repo</span>
}

// SetupTestManager creates a test project manager
func (tc *TestConfig) SetupTestManager(t *testing.T) manager.ProjectManager <span class="cov0" title="0">{
        repo := tc.SetupTestRepository(t)
        config := manager.DefaultConfig()
        return manager.NewManagerWithRepository(repo, config)
}</span>

// CreateTestProject creates a test project for testing
func CreateTestProject(t *testing.T, mgr manager.ProjectManager) *types.Project <span class="cov0" title="0">{
        ctx := context.Background()
        
        project, err := mgr.CreateProject(ctx, "Test Project", "Test Description", "test-user")
        require.NoError(t, err)
        require.NotNil(t, project)
        
        return project
}</span>

// CreateTestTask creates a test task for testing
func CreateTestTask(t *testing.T, mgr manager.ProjectManager, projectID uuid.UUID) *types.Task <span class="cov0" title="0">{
        ctx := context.Background()
        
        task, err := mgr.CreateTask(ctx, projectID, nil, "Test Task", "Test Description", 5, types.TaskPriorityMedium, "test-user")
        require.NoError(t, err)
        require.NotNil(t, task)
        
        return task
}</span>

// CreateTestTaskWithParent creates a test task with a parent
func CreateTestTaskWithParent(t *testing.T, mgr manager.ProjectManager, projectID, parentID uuid.UUID) *types.Task <span class="cov0" title="0">{
        ctx := context.Background()
        
        task, err := mgr.CreateTask(ctx, projectID, &amp;parentID, "Test Subtask", "Test Subtask Description", 3, types.TaskPriorityMedium, "test-user")
        require.NoError(t, err)
        require.NotNil(t, task)
        
        return task
}</span>

// AssertTaskState asserts that a task has the expected state
func AssertTaskState(t *testing.T, mgr manager.ProjectManager, taskID uuid.UUID, expectedState types.TaskState) <span class="cov0" title="0">{
        ctx := context.Background()
        
        task, err := mgr.GetTask(ctx, taskID)
        require.NoError(t, err)
        require.Equal(t, expectedState, task.State)
}</span>

// AssertTaskCount asserts the number of tasks in a project
func AssertTaskCount(t *testing.T, mgr manager.ProjectManager, projectID uuid.UUID, expectedCount int) <span class="cov0" title="0">{
        ctx := context.Background()
        
        tasks, err := mgr.ListTasksForProject(ctx, projectID)
        require.NoError(t, err)
        require.Len(t, tasks, expectedCount)
}</span>

// WaitForCondition waits for a condition to be true with timeout
func WaitForCondition(t *testing.T, condition func() bool, timeout time.Duration, message string) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        
        ticker := time.NewTicker(10 * time.Millisecond)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        t.Fatalf("Timeout waiting for condition: %s", message)</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if condition() </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// TempFile creates a temporary file for testing
func TempFile(t *testing.T, content string) string <span class="cov0" title="0">{
        tmpFile, err := os.CreateTemp("", "knot_test_*.tmp")
        require.NoError(t, err)
        
        _, err = tmpFile.WriteString(content)
        require.NoError(t, err)
        
        err = tmpFile.Close()
        require.NoError(t, err)
        
        t.Cleanup(func() </span><span class="cov0" title="0">{
                os.Remove(tmpFile.Name())
        }</span>)
        
        <span class="cov0" title="0">return tmpFile.Name()</span>
}

// TempDir creates a temporary directory for testing
func TempDir(t *testing.T) string <span class="cov0" title="0">{
        dir, err := os.MkdirTemp("", "knot_test_*")
        require.NoError(t, err)
        
        t.Cleanup(func() </span><span class="cov0" title="0">{
                os.RemoveAll(dir)
        }</span>)
        
        <span class="cov0" title="0">return dir</span>
}

// MockAppContext provides a mock implementation for testing
type MockAppContext struct {
        Manager manager.ProjectManager
        Logger  *zap.Logger
        Actor   string
}

func (m *MockAppContext) SetActor(actor string) <span class="cov0" title="0">{
        m.Actor = actor
}</span>

func (m *MockAppContext) ProjectManager() manager.ProjectManager <span class="cov0" title="0">{
        return m.Manager
}</pre>
		
		<pre class="file" id="file89" style="display: none">package validation

import (
        "fmt"
        "html"
        "regexp"
        "strings"
        "unicode/utf8"
)

// InputValidator provides validation for user inputs
type InputValidator struct {
        MaxTitleLength       int
        MaxDescriptionLength int
        AllowHTML           bool
}

// NewInputValidator creates a new input validator with default limits
func NewInputValidator() *InputValidator <span class="cov8" title="1">{
        return &amp;InputValidator{
                MaxTitleLength:       200,  // Reasonable limit for task titles
                MaxDescriptionLength: 2000, // Reasonable limit for descriptions
                AllowHTML:           false, // Disable HTML by default for security
        }
}</span>

// ValidateTaskTitle validates a task title
func (v *InputValidator) ValidateTaskTitle(title string) error <span class="cov8" title="1">{
        if title == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("title cannot be empty")
        }</span>

        // Check length
        <span class="cov8" title="1">if utf8.RuneCountInString(title) &gt; v.MaxTitleLength </span><span class="cov8" title="1">{
                return fmt.Errorf("title too long: %d characters (max: %d)", 
                        utf8.RuneCountInString(title), v.MaxTitleLength)
        }</span>

        // Check for dangerous content
        <span class="cov8" title="1">if err := v.validateContent(title, "title"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateTaskDescription validates a task description
func (v *InputValidator) ValidateTaskDescription(description string) error <span class="cov8" title="1">{
        // Empty description is allowed
        if description == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check length
        <span class="cov8" title="1">if utf8.RuneCountInString(description) &gt; v.MaxDescriptionLength </span><span class="cov8" title="1">{
                return fmt.Errorf("description too long: %d characters (max: %d)", 
                        utf8.RuneCountInString(description), v.MaxDescriptionLength)
        }</span>

        // Check for dangerous content
        <span class="cov8" title="1">if err := v.validateContent(description, "description"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateProjectTitle validates a project title
func (v *InputValidator) ValidateProjectTitle(title string) error <span class="cov8" title="1">{
        if title == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("project title cannot be empty")
        }</span>

        // Use same limits as task title
        <span class="cov8" title="1">if utf8.RuneCountInString(title) &gt; v.MaxTitleLength </span><span class="cov8" title="1">{
                return fmt.Errorf("project title too long: %d characters (max: %d)", 
                        utf8.RuneCountInString(title), v.MaxTitleLength)
        }</span>

        // Check for dangerous content
        <span class="cov8" title="1">if err := v.validateContent(title, "project title"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateProjectDescription validates a project description
func (v *InputValidator) ValidateProjectDescription(description string) error <span class="cov8" title="1">{
        // Empty description is allowed
        if description == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Use same limits as task description
        <span class="cov8" title="1">if utf8.RuneCountInString(description) &gt; v.MaxDescriptionLength </span><span class="cov8" title="1">{
                return fmt.Errorf("project description too long: %d characters (max: %d)", 
                        utf8.RuneCountInString(description), v.MaxDescriptionLength)
        }</span>

        // Check for dangerous content
        <span class="cov8" title="1">if err := v.validateContent(description, "project description"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateContent checks for potentially dangerous content
func (v *InputValidator) validateContent(content, fieldName string) error <span class="cov8" title="1">{
        // Check for null bytes (can cause issues in some contexts)
        if strings.Contains(content, "\x00") </span><span class="cov8" title="1">{
                return fmt.Errorf("%s contains null bytes", fieldName)
        }</span>

        // Check for control characters (except common whitespace)
        <span class="cov8" title="1">for _, r := range content </span><span class="cov8" title="1">{
                if r &lt; 32 &amp;&amp; r != '\t' &amp;&amp; r != '\n' &amp;&amp; r != '\r' </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s contains invalid control characters", fieldName)
                }</span>
        }

        // If HTML is not allowed, check for HTML-like content
        <span class="cov8" title="1">if !v.AllowHTML </span><span class="cov8" title="1">{
                if err := v.checkForHTML(content, fieldName); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// checkForHTML detects and blocks HTML-like content
func (v *InputValidator) checkForHTML(content, fieldName string) error <span class="cov8" title="1">{
        // Simple HTML tag detection
        htmlTagPattern := regexp.MustCompile(`&lt;[^&gt;]*&gt;`)
        if htmlTagPattern.MatchString(content) </span><span class="cov8" title="1">{
                return fmt.Errorf("%s contains HTML tags which are not allowed", fieldName)
        }</span>

        // Check for script-like patterns
        <span class="cov8" title="1">scriptPatterns := []string{
                "javascript:",
                "data:",
                "vbscript:",
                "onload=",
                "onerror=",
                "onclick=",
        }

        lowerContent := strings.ToLower(content)
        for _, pattern := range scriptPatterns </span><span class="cov8" title="1">{
                if strings.Contains(lowerContent, pattern) </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s contains potentially dangerous script content", fieldName)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SanitizeContent sanitizes content by escaping HTML if needed
func (v *InputValidator) SanitizeContent(content string) string <span class="cov8" title="1">{
        if v.AllowHTML </span><span class="cov8" title="1">{
                return content
        }</span>
        
        // Escape HTML entities
        <span class="cov8" title="1">return html.EscapeString(content)</span>
}

// ValidateComplexity validates task complexity value
func (v *InputValidator) ValidateComplexity(complexity int) error <span class="cov8" title="1">{
        if complexity &lt; 1 || complexity &gt; 10 </span><span class="cov8" title="1">{
                return fmt.Errorf("complexity must be between 1 and 10, got %d", complexity)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateTaskPriority validates task priority value
func (v *InputValidator) ValidateTaskPriority(priority string) error <span class="cov8" title="1">{
        validPriorities := []string{"low", "medium", "high"}
        for _, valid := range validPriorities </span><span class="cov8" title="1">{
                if priority == valid </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("priority must be one of: %s, got %q", strings.Join(validPriorities, ", "), priority)</span>
}

// ValidateActor validates actor name
func (v *InputValidator) ValidateActor(actor string) error <span class="cov8" title="1">{
        if actor == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("actor cannot be empty")
        }</span>

        // Reasonable limit for actor names
        <span class="cov8" title="1">if utf8.RuneCountInString(actor) &gt; 100 </span><span class="cov8" title="1">{
                return fmt.Errorf("actor name too long: %d characters (max: 100)", 
                        utf8.RuneCountInString(actor))
        }</span>

        // Check for dangerous content
        <span class="cov8" title="1">if err := v.validateContent(actor, "actor name"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file90" style="display: none">package validation

import (
        "fmt"

        "github.com/denkhaus/knot/internal/errors"
        "github.com/denkhaus/knot/internal/types"
)

// StateTransition represents a valid state transition
type StateTransition struct {
        From types.TaskState
        To   types.TaskState
}

// StateValidationRule represents a validation rule for state transitions
type StateValidationRule struct {
        Name        string
        Description string
        Validate    func(from, to types.TaskState, task *types.Task) error
}

// StateValidator handles task state validation and transitions
type StateValidator struct {
        allowedTransitions map[StateTransition]bool
        validationRules    []StateValidationRule
}

// NewStateValidator creates a new state validator with default rules
func NewStateValidator() *StateValidator <span class="cov8" title="1">{
        validator := &amp;StateValidator{
                allowedTransitions: make(map[StateTransition]bool),
                validationRules:    make([]StateValidationRule, 0),
        }

        // Define allowed state transitions
        validator.defineAllowedTransitions()
        
        // Add validation rules
        validator.addValidationRules()

        return validator
}</span>

// defineAllowedTransitions sets up the allowed state transition matrix
func (sv *StateValidator) defineAllowedTransitions() <span class="cov8" title="1">{
        // Valid transitions from each state
        transitions := []StateTransition{
                // From pending
                {types.TaskStatePending, types.TaskStateInProgress},
                {types.TaskStatePending, types.TaskStateBlocked},
                {types.TaskStatePending, types.TaskStateCancelled},
                {types.TaskStatePending, types.TaskStateDeletionPending},
                
                // From in-progress
                {types.TaskStateInProgress, types.TaskStateCompleted},
                {types.TaskStateInProgress, types.TaskStateBlocked},
                {types.TaskStateInProgress, types.TaskStatePending},
                {types.TaskStateInProgress, types.TaskStateCancelled},
                {types.TaskStateInProgress, types.TaskStateDeletionPending},
                
                // From completed
                {types.TaskStateCompleted, types.TaskStateInProgress}, // Reopen for fixes
                {types.TaskStateCompleted, types.TaskStatePending},    // Reset if needed
                {types.TaskStateCompleted, types.TaskStateDeletionPending},
                
                // From blocked
                {types.TaskStateBlocked, types.TaskStatePending},
                {types.TaskStateBlocked, types.TaskStateInProgress},
                {types.TaskStateBlocked, types.TaskStateCancelled},
                {types.TaskStateBlocked, types.TaskStateDeletionPending},
                
                // From cancelled
                {types.TaskStateCancelled, types.TaskStatePending},    // Restore
                {types.TaskStateCancelled, types.TaskStateInProgress}, // Resume
                {types.TaskStateCancelled, types.TaskStateDeletionPending},
                
                // From deletion-pending - NO TRANSITIONS ALLOWED except delete operation
                // This ensures only the delete command can proceed from this state
                
                // Self-transitions (no-op but valid)
                {types.TaskStatePending, types.TaskStatePending},
                {types.TaskStateInProgress, types.TaskStateInProgress},
                {types.TaskStateCompleted, types.TaskStateCompleted},
                {types.TaskStateBlocked, types.TaskStateBlocked},
                {types.TaskStateCancelled, types.TaskStateCancelled},
                {types.TaskStateDeletionPending, types.TaskStateDeletionPending},
        }

        for _, transition := range transitions </span><span class="cov8" title="1">{
                sv.allowedTransitions[transition] = true
        }</span>
}

// addValidationRules adds business logic validation rules
func (sv *StateValidator) addValidationRules() <span class="cov8" title="1">{
        sv.validationRules = []StateValidationRule{
                {
                        Name:        "completed_requires_progress",
                        Description: "Tasks should generally go through in-progress before completion",
                        Validate: func(from, to types.TaskState, task *types.Task) error </span><span class="cov8" title="1">{
                                if from == types.TaskStatePending &amp;&amp; to == types.TaskStateCompleted </span><span class="cov0" title="0">{
                                        return &amp;errors.EnhancedError{
                                                Operation:   "validating state transition",
                                                Cause:       fmt.Errorf("direct transition from pending to completed"),
                                                Suggestion:  "Consider transitioning to in-progress first to track work progress",
                                                Example:     "knot task update-state --id " + task.ID.String() + " --state in-progress",
                                                HelpCommand: "knot task update-state --help",
                                        }
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        },
                },
                {
                        Name:        "blocked_requires_dependencies",
                        Description: "Tasks should only be blocked if they have unmet dependencies",
                        Validate: func(from, to types.TaskState, task *types.Task) error <span class="cov8" title="1">{
                                if to == types.TaskStateBlocked &amp;&amp; len(task.Dependencies) == 0 </span><span class="cov0" title="0">{
                                        return &amp;errors.EnhancedError{
                                                Operation:   "validating state transition",
                                                Cause:       fmt.Errorf("cannot block task without dependencies"),
                                                Suggestion:  "Add dependencies first, or use a different state like pending",
                                                Example:     "knot dependency add --task-id " + task.ID.String() + " --depends-on &lt;dependency-id&gt;",
                                                HelpCommand: "knot dependency --help",
                                        }
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        },
                },
                {
                        Name:        "high_complexity_warning",
                        Description: "High complexity tasks should be broken down before completion",
                        Validate: func(from, to types.TaskState, task *types.Task) error <span class="cov8" title="1">{
                                if to == types.TaskStateCompleted &amp;&amp; task.Complexity &gt;= 8 </span><span class="cov8" title="1">{
                                        // This is a warning, not an error - return nil but could log
                                        return &amp;errors.EnhancedError{
                                                Operation:   "validating state transition",
                                                Cause:       fmt.Errorf("completing high complexity task (complexity: %d)", task.Complexity),
                                                Suggestion:  "Consider breaking down high complexity tasks into smaller subtasks",
                                                Example:     "knot breakdown --threshold 7",
                                                HelpCommand: "knot task create --help  # to create subtasks",
                                        }
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        },
                },
                {
                        Name:        "deletion_pending_protection",
                        Description: "Tasks marked for deletion cannot transition to other states except via delete operation",
                        Validate: func(from, to types.TaskState, task *types.Task) error <span class="cov8" title="1">{
                                if from == types.TaskStateDeletionPending &amp;&amp; to != types.TaskStateDeletionPending </span><span class="cov0" title="0">{
                                        return &amp;errors.EnhancedError{
                                                Operation:   "validating state transition",
                                                Cause:       fmt.Errorf("task is marked for deletion and cannot transition to '%s'", to),
                                                Suggestion:  "Complete the deletion process or use the delete command to cancel deletion",
                                                Example:     "knot task delete --id " + task.ID.String() + " # to complete deletion",
                                                HelpCommand: "knot task delete --help",
                                        }
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        },
                },
        }
}

// ValidateTransition validates a state transition
func (sv *StateValidator) ValidateTransition(from, to types.TaskState, task *types.Task) error <span class="cov8" title="1">{
        // Check if transition is allowed
        transition := StateTransition{From: from, To: to}
        if !sv.allowedTransitions[transition] </span><span class="cov8" title="1">{
                return sv.createInvalidTransitionError(from, to, task)
        }</span>

        // Apply validation rules
        <span class="cov8" title="1">for _, rule := range sv.validationRules </span><span class="cov8" title="1">{
                if err := rule.Validate(from, to, task); err != nil </span><span class="cov0" title="0">{
                        // For warnings, we might want to log but not fail
                        // For now, treat all as errors
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateTransitionStrict validates with strict rules (no warnings allowed)
func (sv *StateValidator) ValidateTransitionStrict(from, to types.TaskState, task *types.Task) error <span class="cov0" title="0">{
        return sv.ValidateTransition(from, to, task)
}</span>

// ValidateTransitionLenient validates with lenient rules (warnings become suggestions)
func (sv *StateValidator) ValidateTransitionLenient(from, to types.TaskState, task *types.Task) (error, []string) <span class="cov8" title="1">{
        // Check if transition is allowed
        transition := StateTransition{From: from, To: to}
        if !sv.allowedTransitions[transition] </span><span class="cov8" title="1">{
                return sv.createInvalidTransitionError(from, to, task), nil
        }</span>

        <span class="cov8" title="1">var warnings []string
        
        // Apply validation rules and collect warnings
        for _, rule := range sv.validationRules </span><span class="cov8" title="1">{
                if err := rule.Validate(from, to, task); err != nil </span><span class="cov8" title="1">{
                        // Convert errors to warnings in lenient mode
                        if enhancedErr, ok := err.(*errors.EnhancedError); ok </span><span class="cov8" title="1">{
                                warnings = append(warnings, fmt.Sprintf("‚ö†Ô∏è  %s: %s", rule.Name, enhancedErr.Suggestion))
                        }</span> else<span class="cov0" title="0"> {
                                warnings = append(warnings, fmt.Sprintf("‚ö†Ô∏è  %s: %s", rule.Name, err.Error()))
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil, warnings</span>
}

// createInvalidTransitionError creates an enhanced error for invalid transitions
func (sv *StateValidator) createInvalidTransitionError(from, to types.TaskState, task *types.Task) error <span class="cov8" title="1">{
        validTransitions := sv.getValidTransitionsFrom(from)
        
        var example string
        if len(validTransitions) &gt; 0 </span><span class="cov8" title="1">{
                example = fmt.Sprintf("knot task update-state --id %s --state %s", task.ID.String(), validTransitions[0])
        }</span> else<span class="cov8" title="1"> {
                example = fmt.Sprintf("knot task delete --id %s  # only deletion allowed", task.ID.String())
        }</span>
        
        <span class="cov8" title="1">return &amp;errors.EnhancedError{
                Operation:   "validating state transition",
                Cause:       fmt.Errorf("invalid state transition from '%s' to '%s'", from, to),
                Suggestion:  fmt.Sprintf("Valid transitions from '%s': %v", from, validTransitions),
                Example:     example,
                HelpCommand: "knot task update-state --help",
        }</span>
}

// getValidTransitionsFrom returns valid target states from a given state
func (sv *StateValidator) getValidTransitionsFrom(from types.TaskState) []string <span class="cov8" title="1">{
        var validStates []string
        
        for transition := range sv.allowedTransitions </span><span class="cov8" title="1">{
                if transition.From == from &amp;&amp; transition.To != from </span><span class="cov8" title="1">{ // Exclude self-transitions
                        validStates = append(validStates, string(transition.To))
                }</span>
        }
        
        <span class="cov8" title="1">return validStates</span>
}

// GetAllValidStates returns all valid task states
func (sv *StateValidator) GetAllValidStates() []types.TaskState <span class="cov8" title="1">{
        return []types.TaskState{
                types.TaskStatePending,
                types.TaskStateInProgress,
                types.TaskStateCompleted,
                types.TaskStateBlocked,
                types.TaskStateCancelled,
                types.TaskStateDeletionPending,
        }
}</span>

// IsValidState checks if a state string is valid
func (sv *StateValidator) IsValidState(state string) bool <span class="cov8" title="1">{
        validStates := sv.GetAllValidStates()
        for _, validState := range validStates </span><span class="cov8" title="1">{
                if string(validState) == state </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GetStateTransitionMatrix returns the complete transition matrix for documentation
func (sv *StateValidator) GetStateTransitionMatrix() map[string][]string <span class="cov8" title="1">{
        matrix := make(map[string][]string)
        
        for _, state := range sv.GetAllValidStates() </span><span class="cov8" title="1">{
                matrix[string(state)] = sv.getValidTransitionsFrom(state)
        }</span>
        
        <span class="cov8" title="1">return matrix</span>
}</pre>
		
		<pre class="file" id="file91" style="display: none">package main

import (
        "fmt"
        "os"
        "time"

        "github.com/magefile/mage/mg"
        "github.com/magefile/mage/sh"
)

// Build namespace for build-related targets
type Build mg.Namespace

// Build builds the binary for current platform
func (Build) Build() error <span class="cov0" title="0">{
        mg.Deps(Build.Deps)
        fmt.Println("Building binary...")

        ldflags := fmt.Sprintf("-s -w -X main.version=%s -X main.commit=%s -X main.date=%s",
                getVersion(), getCommit(), time.Now().Format(time.RFC3339))

        return sh.Run("go", "build", "-ldflags", ldflags, "-o", binaryName, packagePath)
}</span>

// Deps downloads and installs dependencies
func (Build) Deps() error <span class="cov0" title="0">{
        fmt.Println("Installing dependencies...")
        return sh.Run("go", "mod", "download")
}</span>

// Install installs the binary to $GOPATH/bin with version information
func (Build) Install() error <span class="cov0" title="0">{
        mg.Deps(Build.Deps)
        fmt.Println("Installing binary with version information...")

        ldflags := fmt.Sprintf("-s -w -X main.version=%s -X main.commit=%s -X main.date=%s",
                getVersion(), getCommit(), time.Now().Format(time.RFC3339))

        return sh.Run("go", "install", "-ldflags", ldflags, packagePath)
}</span>

// Run builds and runs the application with help
func (Build) Run() error <span class="cov0" title="0">{
        mg.Deps(Build.Build)
        fmt.Println("Running application...")
        return sh.Run("./"+binaryName, "--help")
}</span>

// Clean removes build artifacts
func (Build) Clean() error <span class="cov0" title="0">{
        fmt.Println("Cleaning build artifacts...")

        artifacts := []string{
                binaryName,
                binaryName + ".exe",
                "bin/",
                "dist/",
                "coverage/coverage.out",
                "coverage/coverage.html",
                "coverage.out",  // Clean up any old files in root
                "coverage.html", // Clean up any old files in root
        }

        for _, artifact := range artifacts </span><span class="cov0" title="0">{
                if err := os.RemoveAll(artifact); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Clean Go cache
        <span class="cov0" title="0">_ = sh.Run("go", "clean", "-cache")
        _ = sh.Run("go", "clean", "-testcache")

        fmt.Println("Clean completed!")
        return nil</span>
}

// Version shows version information
func (Build) Version() error <span class="cov0" title="0">{
        fmt.Printf("Version: %s\n", getVersion())
        fmt.Printf("Commit: %s\n", getCommit())
        fmt.Printf("Date: %s\n", time.Now().Format(time.RFC3339))
        return nil
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package main

import (
        "fmt"
        "strings"

        "github.com/magefile/mage/mg"
        "github.com/magefile/mage/sh"
)

// Default target to run when none is specified
var Default = Build.Build

// Demo runs a demo workflow
func Demo() error <span class="cov0" title="0">{
        mg.Deps(Build{}.Build)
        fmt.Println("Running demo workflow...")

        commands := [][]string{
                {"./knot", "project", "create", "--name", "Demo Project", "--description", "A demo project"},
                {"./knot", "project", "list"},
                {"./knot", "health", "check"},
        }

        for _, cmd := range commands </span><span class="cov0" title="0">{
                fmt.Printf("$ %s\n", strings.Join(cmd, " "))
                if err := sh.Run(cmd[0], cmd[1:]...); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Help shows available targets with descriptions
func Help() error <span class="cov0" title="0">{
        fmt.Println("Knot Project Lifecycle Management")
        fmt.Println()

        fmt.Println("Main Targets:")
        mainTargets := map[string]string{
                "build":   "Build binary for current platform",
                "install": "Install binary to $GOPATH/bin",
                "run":     "Build and run application",
                "demo":    "Run demo workflow",
                "clean":   "Remove build artifacts",
                "check":   "Run all quality checks",
                "setup":   "Setup development environment",
                "ci":      "Run CI pipeline",
                "version": "Show version information",
        }

        for target, desc := range mainTargets </span><span class="cov0" title="0">{
                fmt.Printf("  %-12s %s\n", target, desc)
        }</span>

        <span class="cov0" title="0">fmt.Println("\nBuild Targets:")
        fmt.Println("  build:build         Build binary for current platform")
        fmt.Println("  build:deps          Download and install dependencies")
        fmt.Println("  build:install       Install binary to $GOPATH/bin")
        fmt.Println("  build:run           Build and run application")
        fmt.Println("  build:clean         Remove build artifacts")
        fmt.Println("  build:version       Show version information")

        fmt.Println("\nTest Targets:")
        fmt.Println("  test:all            Run all tests")
        fmt.Println("  test:unit           Run unit tests only")
        fmt.Println("  test:integration    Run integration tests")
        fmt.Println("  test:coverage       Run tests with coverage and update badges")
        fmt.Println("  test:badge          Generate coverage badge and update README")
        fmt.Println("  test:race           Run tests with race detection")
        fmt.Println("  test:bench          Run benchmarks")
        fmt.Println("  test:view           Open coverage report")

        fmt.Println("\nUtility Targets:")
        fmt.Println("  util:fmt            Format code")
        fmt.Println("  util:vet            Run go vet")
        fmt.Println("  util:lint           Run golangci-lint")
        fmt.Println("  util:lintfix        Run linter with auto-fix")
        fmt.Println("  util:security       Run security checks")
        fmt.Println("  util:generate       Run go generate")
        fmt.Println("  util:tidy           Tidy go modules")
        fmt.Println("  util:update         Update dependencies")
        fmt.Println("  util:check          Run all quality checks")
        fmt.Println("  util:ci             Run CI pipeline")

        fmt.Println("\nDocker Targets:")
        fmt.Println("  docker:build        Build Docker image")
        fmt.Println("  docker:run          Run Docker container")

        fmt.Println("\nRelease Targets:")
        fmt.Println("  release:build       Build release binaries for all platforms")
        fmt.Println("  release:single      Build release binary for current platform")
        fmt.Println("  release:release     Create a full release using goreleaser")
        fmt.Println("  release:snapshot    Create a snapshot release")
        fmt.Println("  release:dryrun      Perform a dry run of the release process")
        fmt.Println("  release:manifest    Generate release manifest without publishing")

        fmt.Println("\nUsage: mage &lt;target&gt;")
        fmt.Println("Default target: build")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package main

import (
        "fmt"
        "os"
        "strings"

        "github.com/magefile/mage/mg"
        "github.com/magefile/mage/sh"
)

// Release namespace for release-related targets
type Release mg.Namespace

// Build builds release binaries for all platforms using goreleaser
func (Release) Build() error <span class="cov0" title="0">{
        mg.Deps(Util.Check)
        fmt.Println("Building release binaries with goreleaser...")
        return sh.Run("goreleaser", "build", "--clean", "--single-target=false")
}</span>

// BuildSingle builds release binary for current platform only
func (Release) BuildSingle() error <span class="cov0" title="0">{
        mg.Deps(Util.Check)
        fmt.Println("Building release binary for current platform...")
        return sh.Run("goreleaser", "build", "--clean", "--single-target=true")
}</span>

// Release creates a full release using goreleaser
func (Release) Release() error <span class="cov0" title="0">{
        mg.Deps(Util.Check)
        fmt.Println("Creating release with goreleaser...")

        // Check if we're on a tag
        if tag, err := sh.Output("git", "describe", "--tags", "--exact-match", "HEAD"); err == nil &amp;&amp; tag != "" </span><span class="cov0" title="0">{
                fmt.Printf("Creating release for tag: %s\n", strings.TrimSpace(tag))
                return sh.Run("goreleaser", "release", "--clean")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Warning: Not on a git tag. Releases should be created from tagged commits.")
                fmt.Println("To create a release, tag your commit first:")
                fmt.Println("  git tag -a v1.2.3 -m 'Release v1.2.3'")
                fmt.Println("  git push origin v1.2.3")
                return fmt.Errorf("not on a git tag - cannot create release")
        }</span>
}

// Snapshot creates a snapshot release (pre-release) using goreleaser
func (Release) Snapshot() error <span class="cov0" title="0">{
        mg.Deps(Util.Check)
        fmt.Println("Creating snapshot release with goreleaser...")
        return sh.Run("goreleaser", "release", "--clean", "--snapshot", "--skip-publish")
}</span>

// CheckPrerelease verifies that the environment is ready for a release
func (Release) CheckPrerelease() error <span class="cov0" title="0">{
        fmt.Println("Checking release prerequisites...")

        // Check if goreleaser is installed
        if _, err := sh.Output("which", "goreleaser"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("goreleaser not found. Install with: go install github.com/goreleaser/goreleaser@latest")
        }</span>

        // Check git status
        <span class="cov0" title="0">if status, err := sh.Output("git", "status", "--porcelain"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check git status: %v", err)
        }</span> else<span class="cov0" title="0"> if status != "" </span><span class="cov0" title="0">{
                fmt.Println("Warning: Working directory is not clean, this may affect the release:")
                fmt.Println(status)
        }</span>

        // Check if on a tagged commit
        <span class="cov0" title="0">if tag, err := sh.Output("git", "describe", "--tags", "--exact-match", "HEAD"); err == nil &amp;&amp; tag != "" </span><span class="cov0" title="0">{
                fmt.Printf("‚úì Ready to release from tag: %s\n", strings.TrimSpace(tag))
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Note: Not on a git tag. Use 'git tag -a v1.2.3 -m \"Release v1.2.3\"' to create a tag.")
        }</span>

        // Check for GitHub token if publishing
        <span class="cov0" title="0">if os.Getenv("GITHUB_TOKEN") == "" </span><span class="cov0" title="0">{
                fmt.Println("Warning: GITHUB_TOKEN not set. Release will not be published to GitHub.")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DryRun performs a dry run of the release process
func (Release) DryRun() error <span class="cov0" title="0">{
        mg.Deps(Util.Check)
        fmt.Println("Running release dry run with goreleaser...")
        return sh.Run("goreleaser", "release", "--clean", "--snapshot")
}</span>

// Manifest generates release manifest without publishing
func (Release) Manifest() error <span class="cov0" title="0">{
        mg.Deps(Util.Check)
        fmt.Println("Generating release manifest...")
        return sh.Run("goreleaser", "release", "--clean", "--skip-publish")
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package main

import (
        "fmt"
        "os"
        "runtime"
        "strconv"
        "strings"

        "github.com/magefile/mage/mg"
        "github.com/magefile/mage/sh"
)

// Test namespace for test-related targets
type Test mg.Namespace

// All runs all tests
func (Test) All() error <span class="cov0" title="0">{
        fmt.Println("Running all tests...")
        return sh.Run("go", "test", "-v", "./...")
}</span>

// Unit runs unit tests only
func (Test) Unit() error <span class="cov0" title="0">{
        fmt.Println("Running unit tests...")
        return sh.Run("go", "test", "-short", "-v", "./...")
}</span>

// Integration runs integration tests
func (Test) Integration() error <span class="cov0" title="0">{
        fmt.Println("Running integration tests...")
        return sh.Run("go", "test", "-run", "Integration", "-v", "./...")
}</span>

// Coverage runs tests with coverage
func (Test) Coverage() error <span class="cov0" title="0">{
        fmt.Println("Running tests with coverage...")
        
        // Create coverage directory if it doesn't exist
        if err := os.MkdirAll("coverage", 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">if err := sh.Run("go", "test", "-coverprofile="+coverageFile, "-covermode=set", "./..."); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := sh.Run("go", "tool", "cover", "-html="+coverageFile, "-o", coverageHTML); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Coverage report generated: " + coverageHTML)
        
        // Generate coverage badge
        t := Test{}
        if err := t.Badge(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to generate coverage badge: %v\n", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// Badge generates coverage badge and updates README
func (Test) Badge() error <span class="cov0" title="0">{
        fmt.Println("Generating coverage badge...")
        
        // Get coverage percentage
        output, err := sh.Output("go", "tool", "cover", "-func="+coverageFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Parse coverage percentage from output
        <span class="cov0" title="0">lines := strings.Split(output, "\n")
        var coveragePercent string
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "total:") </span><span class="cov0" title="0">{
                        parts := strings.Fields(line)
                        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                coveragePercent = strings.TrimSuffix(parts[2], "%")
                                break</span>
                        }
                }
        }
        
        <span class="cov0" title="0">if coveragePercent == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not parse coverage percentage")
        }</span>
        
        // Determine badge color
        <span class="cov0" title="0">coverage, err := strconv.ParseFloat(coveragePercent, 64)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">var color string
        switch </span>{
        case coverage &gt;= 80:<span class="cov0" title="0">
                color = "green"</span>
        case coverage &gt;= 50:<span class="cov0" title="0">
                color = "yellow"</span>
        default:<span class="cov0" title="0">
                color = "red"</span>
        }
        
        // Create coverage directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll("coverage", 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Write badge info to file
        <span class="cov0" title="0">badgeText := fmt.Sprintf("Coverage-%s%%-%s", coveragePercent, color)
        if err := os.WriteFile("coverage/badge.txt", []byte(badgeText), 0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Update README with new coverage percentage
        <span class="cov0" title="0">t := Test{}
        if err := t.UpdateReadmeBadge(coveragePercent); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to update README badge: %v\n", err)
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("Coverage badge generated: %s\n", badgeText)
        return nil</span>
}

// UpdateReadmeBadge updates the coverage badge in README.md
func (Test) UpdateReadmeBadge(coveragePercent string) error <span class="cov0" title="0">{
        readmePath := "README.md"
        
        // Read README content
        content, err := os.ReadFile(readmePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Replace coverage badge line
        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")
        
        // Determine badge color
        coverage, err := strconv.ParseFloat(coveragePercent, 64)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">var color string
        switch </span>{
        case coverage &gt;= 80:<span class="cov0" title="0">
                color = "green"</span>
        case coverage &gt;= 50:<span class="cov0" title="0">
                color = "yellow"</span>
        default:<span class="cov0" title="0">
                color = "red"</span>
        }
        
        <span class="cov0" title="0">for i, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "[![Coverage](https://img.shields.io/badge/Coverage-") </span><span class="cov0" title="0">{
                        lines[i] = fmt.Sprintf("[![Coverage](https://img.shields.io/badge/Coverage-%s%%25-%s.svg)](./coverage/coverage.html)", coveragePercent, color)
                        break</span>
                }
        }
        
        // Write updated content back
        <span class="cov0" title="0">updatedContent := strings.Join(lines, "\n")
        return os.WriteFile(readmePath, []byte(updatedContent), 0644)</span>
}

// Race runs tests with race detection
func (Test) Race() error <span class="cov0" title="0">{
        fmt.Println("Running tests with race detection...")
        return sh.Run("go", "test", "-race", "-v", "./...")
}</span>

// Bench runs benchmarks
func (Test) Bench() error <span class="cov0" title="0">{
        fmt.Println("Running benchmarks...")
        return sh.Run("go", "test", "-bench=.", "-benchmem", "./...")
}</span>

// View opens coverage report
func (Test) View() error <span class="cov0" title="0">{
        mg.Deps(Test.Coverage)
        fmt.Println("Opening coverage report...")

        var cmd string
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                cmd = "open"</span>
        case "linux":<span class="cov0" title="0">
                cmd = "xdg-open"</span>
        case "windows":<span class="cov0" title="0">
                cmd = "start"</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported platform")</span>
        }

        <span class="cov0" title="0">return sh.Run(cmd, coverageHTML)</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
        "strings"

        "github.com/magefile/mage/mg"
        "github.com/magefile/mage/sh"
)

const (
        binaryName   = "knot"
        packagePath  = "./cmd/knot"
        coverageFile = "coverage/coverage.out"
        coverageHTML = "coverage/coverage.html"
)

// Util namespace for utility targets
type Util mg.Namespace

// Fmt formats the code
func (Util) Fmt() error <span class="cov0" title="0">{
        fmt.Println("Formatting code...")
        return sh.Run("go", "fmt", "./...")
}</span>

// Vet runs go vet
func (Util) Vet() error <span class="cov0" title="0">{
        fmt.Println("Running go vet...")
        return sh.Run("go", "vet", "./...")
}</span>

// Generate runs go generate
func (Util) Generate() error <span class="cov0" title="0">{
        fmt.Println("Running go generate...")
        return sh.Run("go", "generate", "./...")
}</span>

// Tidy cleans up go.mod and go.sum
func (Util) Tidy() error <span class="cov0" title="0">{
        fmt.Println("Tidying go modules...")
        return sh.Run("go", "mod", "tidy")
}</span>

// Lint runs golangci-lint
func (Util) Lint() error <span class="cov0" title="0">{
        fmt.Println("Running linter...")
        return sh.Run("golangci-lint", "run", "--timeout=5m")
}</span>

// LintFix runs golangci-lint with auto-fix
func (Util) LintFix() error <span class="cov0" title="0">{
        fmt.Println("Running linter with auto-fix...")
        return sh.Run("golangci-lint", "run", "--fix", "--timeout=5m")
}</span>

// Security runs security checks
func (Util) Security() error <span class="cov0" title="0">{
        fmt.Println("Running security checks...")

        // Check if gosec is installed
        if _, err := exec.LookPath("gosec"); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Installing gosec...")
                if err := sh.Run("go", "install", "github.com/securecodewarrior/gosec/cmd/gosec@latest"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return sh.Run("gosec", "./...")</span>
}

// Update updates all dependencies
func (Util) Update() error <span class="cov0" title="0">{
        fmt.Println("Updating dependencies...")

        if err := sh.Run("go", "get", "-u", "./..."); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sh.Run("go", "mod", "tidy")</span>
}

// Setup sets up development environment
func (Util) Setup() error <span class="cov0" title="0">{
        fmt.Println("Setting up development environment...")

        tools := []string{
                "github.com/golangci/golangci-lint/cmd/golangci-lint@latest",
                "github.com/goreleaser/goreleaser@latest",
                "github.com/securecodewarrior/gosec/cmd/gosec@latest",
        }

        for _, tool := range tools </span><span class="cov0" title="0">{
                fmt.Printf("Installing %s...\n", tool)
                if err := sh.Run("go", "install", tool); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("Development environment ready!")
        return nil</span>
}

// Check runs all quality checks
func (Util) Check() error <span class="cov0" title="0">{
        fmt.Println("Running all quality checks...")
        mg.Deps(Util.Fmt, Util.Vet, Util.Lint, Test.Race)
        fmt.Println("All checks passed!")
        return nil
}</span>

// CI runs all CI checks
func (Util) CI() error <span class="cov0" title="0">{
        fmt.Println("Running CI pipeline...")
        mg.Deps(Util.Tidy, Util.Generate, Util.Check, Test.Coverage)
        fmt.Println("CI pipeline completed successfully!")
        return nil
}</span>

// Docker namespace for Docker-related targets
type Docker mg.Namespace

// Build builds Docker image
func (Docker) Build() error <span class="cov0" title="0">{
        mg.Deps(Test.All)
        fmt.Println("Building Docker image...")
        return sh.Run("docker", "build", "-t", "knot:latest", ".")
}</span>

// Run runs Docker container
func (Docker) Run() error <span class="cov0" title="0">{
        mg.Deps(Docker.Build)
        fmt.Println("Running Docker container...")
        return sh.Run("docker", "run", "--rm", "-it", "knot:latest", "--help")
}</span>

// Helper functions
func getVersion() string <span class="cov0" title="0">{
        if version := os.Getenv("VERSION"); version != "" </span><span class="cov0" title="0">{
                return version
        }</span>

        // Try to get version from git tag
        <span class="cov0" title="0">if output, err := sh.Output("git", "describe", "--tags", "--always", "--dirty"); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(output)
        }</span>

        <span class="cov0" title="0">return "dev"</span>
}

func getCommit() string <span class="cov0" title="0">{
        if output, err := sh.Output("git", "rev-parse", "--short", "HEAD"); err == nil </span><span class="cov0" title="0">{
                return strings.TrimSpace(output)
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
